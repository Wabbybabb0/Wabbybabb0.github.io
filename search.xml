<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试用</title>
      <link href="/2025/03/19/mla-fu-ben/"/>
      <url>/2025/03/19/mla-fu-ben/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2405.04434">DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model</a></p><p>相关论文：<a href="https://arxiv.org/abs/2405.04434">DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model</a></p><p>本文内容围绕多头注意力机制的演变过程，着重记录MLA的设计原理，对<a href="https://spaces.ac.cn/archives/10091">缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA</a>、<a href="https://www.bilibili.com/video/BV1BYXRYWEMj?spm_id_from=333.1245.0.0">DeepSeek-v2 MLA 原理讲解</a>的内容进行整合与分析，在我理解MLA的过程中，他们给予了很好的启迪！</p><p>假设所有输入都为行向量，输入序列为$\textbf{x}_1, \textbf{x}_2, …, \textbf{x}_l$，其中$\textbf{x}_i\in \mathbb{R}^{1\times d}$</p><ul><li>$l$：token数量</li><li>$d$：<code>embdeding dimension</code></li></ul><h1 id="1-MHA-Multi-Head-Attention"><a href="#1-MHA-Multi-Head-Attention" class="headerlink" title="1 MHA(Multi Head Attention)"></a>1 MHA(Multi Head Attention)</h1><ul><li>$\textbf{o}_t$：当前<strong>t</strong>oken的注意力输出</li></ul><p>MHA使每个Head都有对应的$K$和$V$，模型对token的理解效果是比较好的，而问题在于，虽然有KV Cache，但是随着句子序列变长，Key和Value的缓存的成本和推理时通信的短板会变大，下图的解释会更详细点。<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/Pasted%20image%2020250322123448.png" alt="《缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA》一文中对KV Cache的分析"></p><h1 id="2-MQA-Multi-Query-Attention"><a href="#2-MQA-Multi-Query-Attention" class="headerlink" title="2 MQA(Multi Query Attention)"></a>2 MQA(Multi Query Attention)</h1><p>$$\textbf{o}_t=[\textbf{o}_t^{(1)}, \textbf{o}_t^{(2)}, …, \textbf{o}<em>t^{(h)}]$$<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}, \textbf{v}</em>{i\leq t}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t^{(s)}\textbf{k}_i^T}{\sqrt{d_k}})\textbf{v}_i$$<br>$$\textbf{q}_i^{(s)}=\textbf{x}_i\textbf{W}_q^{(s)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_q^{(s)}\in \mathbb{R}^{d\times d_k}$$<br>$$\textbf{k}_i=\textbf{x}_i\textbf{W}_k\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_k\in \mathbb{R}^{d\times d_k}$$<br>$$$$\textbf{v}_i=\textbf{x}_i \textbf{W}_q\in \mathbb{R}^{1\times d_v},\ \ \ \ \  \textbf{W}_v\in \mathbb{R}^{d\times d_v}$$</p><ul><li>$\textbf{W}_k$、$\textbf{W}_v$：所有<code>head</code>共享的key、value权重矩阵</li></ul><p>与MHA相比，每个Head都共享同一组$K$和$V$，</p><ul><li>显存：其KV Cache为MHA的$\dfrac{1}{h}$，是目前很节省的方法，</li><li>效果：根据《<a href="https://spaces.ac.cn/archives/10091">缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA</a>》提到的，损失是有限的，参数量通过加大其他模块的规模来补足。</li></ul><h1 id="3-GQA-Grouped-Query-Attention"><a href="#3-GQA-Grouped-Query-Attention" class="headerlink" title="3 GQA(Grouped Query Attention)"></a>3 GQA(Grouped Query Attention)</h1><p>$$\textbf{o}_t=[\textbf{o}_t^{(1)}, \textbf{o}_t^{(2)}, …, \textbf{o}<em>t^{(h)}]$$<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}^{(\lceil sg/h \rceil)}, \textbf{v}</em>{i\leq t}^{(\lceil sg/h \rceil)}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t^{(s)}\textbf{k}_i^{(\lceil sg/h \rceil)}T}{\sqrt{d_k}})\textbf{v}_i^{(\lceil sg/h \rceil)}$$<br>$$\textbf{q}_i^{(s)}=\textbf{x}_i\textbf{W}_q^{(s)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_q^{(s)}\in \mathbb{R}^{d\times d_k}$$<br>$$\textbf{k}_i^{(\lceil sg/h \rceil)}=\textbf{x}_i\textbf{W}_k^{(\lceil sg/h \rceil)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_k^{(\lceil sg/h \rceil)}\in \mathbb{R}^{d\times d_k}$$<br>$$\textbf{v}_i^{(\lceil sg/h \rceil)}=\textbf{x}_i\textbf{W}_q^{(\lceil sg/h \rceil)}\in \mathbb{R}^{1\times d_v},\ \ \ \ \  \textbf{W}_v^{(\lceil sg/h \rceil)}\in \mathbb{R}^{d\times d_v}$$</p><ul><li>$\lceil · \rceil$是向上取整</li><li>$\textbf{W}_q^{(s)}$、$\textbf{W}_k^{(s)}$、$\textbf{W}_v^{(s)}$：分别为第$s$个<code>head</code>的query、key、value的权重矩阵，</li><li>$d_k=d_v=d/h$</li></ul><p>作为显存的压缩和效果都在MHA和MQA之间的版本，GQA将<code>head</code>分为$g$个组($g$可以整除$h$)，每组共享同一对$K$、$V$。当$g=1$时就是MQA，$g=h$时就是MHA。当$1&lt;g&lt;h$时，效果不如MHA，显存压缩没有MQA那么猛，但是KV Cache压缩到MHA的$g/h$，效果比MQA好，是一个折中的版本。</p><h1 id="4-MLA-Multi-head-Latent-Attention"><a href="#4-MLA-Multi-head-Latent-Attention" class="headerlink" title="4 MLA(Multi-head Latent Attention)"></a>4 MLA(Multi-head Latent Attention)</h1><p>对KV Cache做低秩投影，通过投影矩阵$\textbf{W}_c$将$\textbf{x}_i$投影为$\textbf{c}_i$<br><a href="https://spaces.ac.cn/archives/10091">缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA</a>文章中认为”DeepSeek-V2的技术报告里是从低秩投影的角度引入MLA的……然而，笔者认为低秩投影这个角度并不贴近本质，因为要说低秩投影的话，事实上只要我们将GQA的所有K、V叠在一起，就会发现GQA也相当于在做低秩投影：<br>$$[\textbf{k}_i^{(1)}, …,\textbf{k}_i^{(g)}, \textbf{v}_i^{(1)},…,\textbf{v}_i^{(g)}] = \textbf{x}_i[\textbf{W}_k^{(1)},…,\textbf{W}_k^{(g)},\textbf{W}_v^{(1)},…,\textbf{W}_v^{(g)}]$$</p><ul><li>$[\textbf{k}_i^{(1)}, …,\textbf{k}_i^{(g)}, \textbf{v}_i^{(1)},…,\textbf{v}_i^{(g)}] = \textbf{c}_i\in \mathbb{R}^{1\times d_c}$，将所有的$\textbf{k}_i^{(s)}$、$\textbf{v}_i^{(s)}$拼在一起记为$\textbf{c}_i$，</li><li>$[\textbf{W}_k^{(1)},…,\textbf{W}_k^{(g)},\textbf{W}_v^{(1)},…,\textbf{W}_v^{(g)}] = \textbf{W}_c\in \mathbb{R}^{d\times d_c}$，将相应的投影矩阵拼在一起记为$\textbf{W}_c$，</li><li>$d_c=g(d_k+d_v)&lt;d=h(d_k+d_v)$，所以$\textbf{x}_i$到$\textbf{c}_i$的变换就是一个低秩投影，<br><strong>所以，MLA的本质改进不是低秩投影，而是低秩投影之后的工作</strong>“</li></ul><h2 id="4-1-MLA的最初构想"><a href="#4-1-MLA的最初构想" class="headerlink" title="4.1 MLA的最初构想"></a>4.1 MLA的最初构想</h2><p>得到$\textbf{c}_i$后，GQA将其对半分为K和V，将它们分别均分为$g$份，每一份复制$h/g$次，凑够$h$份K和V，然后将其投入到计算Attention和KV Cache，MLA对$\textbf{c}_i$不是简单的分割和复制，他对$\textbf{c}_i$又进行了一次投影，“增强了模型的能力”：<br>$$\textbf{u}_t = \textbf{o}_t\textbf{W}_o,\ \ \ \ \ \textbf{W}_o\in \mathbb{R}^{d\times hd_k}$$</p><ul><li>$\textbf{W}_o$是输出投影矩阵，这里的$hd_k\neq d$<br>$$\textbf{o}_t=[\textbf{o}_t^{(1)}, \textbf{o}_t^{(2)}, …, \textbf{o}<em>t^{(h)}] \in \mathbb{R}^{1\times d}$$<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}^{(s)}, \textbf{v}</em>{i\leq t}^{(s)}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}}{\sqrt{d_k}})\textbf{v}_i^{(s)}$$<br>$$\textbf{c}_i=\textbf{x}_i\textbf{W}_c\in\mathbb{R}^{1\times d_c}$$<br>$$\textbf{q}_i^{(s)}=\textbf{x}_i\textbf{W}_q^{(s)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_q^{(s)}\in \mathbb{R}^{d\times d_k}$$<br>$$\textbf{k}<em>i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}</em>{Uk}^{(s)}\in \mathbb{R}^{d_c\times d_k}$$<br>$$\textbf{v}<em>i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{1\times d_v},\ \ \ \ \  \textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{d_c\times d_v}$$</li><li>$\textbf{W}<em>{Uk}^{(s)}$、$\textbf{W}</em>{Uv}^{(s)}$：分别为第$s$个<code>head</code>的key、value的再投影权重矩阵，为了“增强了模型的能力”<br>然而，原本已经低秩的$\textbf{c}<em>i$在$\textbf{W}</em>{Uk}^{(s)}$和$\textbf{W}_{Uv}^{(s)}$作用下被up-projection了，即$\textbf{k}_i^{(s)}$和$\textbf{v}_i^{(s)}$原本的<code>head</code>分组不存在了，一组<code>head</code>之间不再共享$K$、$V$，“出于节省计算和通信成本的考虑，我们一般会缓存的是投影后的$\textbf{k}_i$、$\textbf{v}_i$的而不是投影前的$\textbf{c}_i$或$\textbf{x}_i$”，所以，此做法的KV Cache与MHA无异，没有显存节省的作用。</li></ul><p>虽然在训练阶段MLA的优化空间不大，但是在推理阶段中：<br>$$\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}=(\textbf{x}_t\textbf{W}_q^{(s)})\cdot (\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)})^T=\textbf{x}_t(\textbf{W}<em>q^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T})\textbf{c}_i^T$$<br>$\textbf{W}<em>q^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T}$作为$Q$的投影矩阵，K Cache的内容可以从$\textbf{k}_i$变为$\textbf{c}_i$；根据$\textbf{v}_i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uv}^{(s)}$和$\textbf{u}_t^{(s)} = \textbf{o}_t^{(s)}\textbf{W}_o^{(s)}$，输出的计算过程包含$\textbf{c}<em>i\textbf{W}</em>{Uv}\textbf{W}<em>O$，那么$\textbf{W}</em>{Uv}\textbf{W}_O$作为$V$的投影矩阵，$\textbf{v}_i$可以用$\textbf{c}_i$代替，即V Cache的内容从$\textbf{v}_i$也变为$\textbf{c}_i$。<br>那么KV Cache的内容就是$\textbf{c}_i$，它与$(s)$无关 ，是所有<code>head</code>共享的，控制好$g/h$的值，在推理阶段达到GQA或MQA的效果。<br>实际上，因为up-projection提高了模型的效果，同时在推理阶段KV Cache效果与GQA相同($1&lt;g&lt;h$)。在效果和显存的平衡下，“如果我们只需要跟GQA相近的能力，那么是不是就可以再次减少KV Cache了？换言之，$d_c$没必要取$g(dk+dv)$，而是取更小的值，从而进一步压缩KV Cache，这就是MLA的核心思想”。</p><h2 id="4-2-RoPE的兼容"><a href="#4-2-RoPE的兼容" class="headerlink" title="4.2 RoPE的兼容"></a>4.2 RoPE的兼容</h2><p>RoPE与绝对位置相关，通过绝对位置计算两个token之间的相对位置信息：<br>$$\textbf{R}_m\textbf{R}<em>n^T=\textbf{R}</em>{m-n}$$<br>MLA加上RoPE之后：<br>$$\textbf{q}_i^{(s)}=x_iW_q^{(s)}\textbf{R}_i, \ \ \ \ \ \textbf{k}_i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)}\textbf{R}_i$$<br>$$\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}=(x_tW_q^{(s)}\textbf{R}<em>t)(\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)}\textbf{R}<em>i)^T=x_tW_q^{(s)}\textbf{R}</em>{t-i}{W}</em>{Uk}^{(s)T}\textbf{c}_i^T$$<br>不能固定$\textbf{W}<em>q^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T}$值作为$Q$的投影矩阵。<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/Pasted%20image%2020250323150831.png" alt="《缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA》一文中探讨的其他方法"><br>后来解决办法为每个<code>head</code>的$\textbf{Q}$和$\textbf{K}$新增$d_r$个维度来添加RoPE的信息，其中$\textbf{K}$新增的信息由每个<code>head</code>共享<br>$$\textbf{u}_t = \textbf{o}_t\textbf{W}_o,\ \ \ \ \ \textbf{W}_o\in \mathbb{R}^{d\times hd_k}$$<br>$$\textbf{o}_t=[\textbf{o}_t^{(1)}, \textbf{o}_t^{(2)}, …, \textbf{o}<em>t^{(h)}] \in \mathbb{R}^{1\times d}$$<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}^{(s)}, \textbf{v}</em>{i\leq t}^{(s)}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}}{\sqrt{d_k+d_r}})\textbf{v}_i^{(s)}$$</p><ul><li>dot-product的scaling变成了$\sqrt{d_k+d_r}$<br>$$RoPE(\textbf{x}<em>i\textbf{W}</em>{qR}^{(s)})=\textbf{x}<em>i\textbf{W}</em>{qR}^{(s)}\textbf{R}<em>i,\ \ \ \ \ \textbf{W}</em>{qR}^{(s)}\in \mathbb{R}^{d\times d_r}$$<br>$$RoPE(\textbf{x}<em>i\textbf{W}</em>{kR})=\textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}<em>i,\ \ \ \ \ \textbf{W}</em>{kR}\in \mathbb{R}^{d\times d_r}$$<br>$$\textbf{c}_i=\textbf{x}_i\textbf{W}_c\in\mathbb{R}^{1\times d_c}$$<br>$$\textbf{q}_i^{(s)}=[\textbf{x}_i\textbf{W}_q^{(s)}, \textbf{x}<em>i\textbf{W}</em>{qR}^{(s)}\textbf{R}_i]\in \mathbb{R}^{1\times [d_k+d_r]},\ \ \ \ \  \textbf{W}_q^{(s)}\in \mathbb{R}^{d\times d_r}$$<br>$$\textbf{k}<em>i^{(s)}=[\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)}, \textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}<em>i]\in \mathbb{R}^{1\times [d_k+d_r]},\ \ \ \ \  \textbf{W}</em>{Uk}^{(s)}\in \mathbb{R}^{d\times d_r}$$<br>$$\textbf{v}<em>i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{1\times d_v},\ \ \ \ \  \textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{d_c\times d_v}$$<br>👇可以看到保留了$Q$的固定投影$\textbf{W}<em>q^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T}$和相对位置信息$\textbf{R}</em>{t-i}$<br>$$\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}=(\textbf{x}_t\textbf{W}_q^{(s)})(\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)})^T+(\textbf{x}<em>t\textbf{W}</em>{qR}^{(s)}\textbf{R}_t)(\textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}_i)^T$$<br>$$=\textbf{x}<em>t(\textbf{W}<em>q^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T})\textbf{c}<em>i^T+\textbf{x}<em>t\textbf{W}</em>{qR}^{(s)}(\textbf{R}</em>{t-i})\textbf{W}</em>{kR}^T\textbf{x}_i^T$$</li></ul><h2 id="4-3-MLA最终版本"><a href="#4-3-MLA最终版本" class="headerlink" title="4.3 MLA最终版本"></a>4.3 MLA最终版本</h2><p>“in order to reduce the activation memory during training”，最后MLA在训练阶段对$Q$的输入$\textbf{x}_i$也做了低秩投影，即$$\textbf{c}<em>i’=\textbf{x}<em>i\textbf{W}</em>{Dq}\in \mathbb{R}^{1\times d_c’},\ \ \ \ \ \textbf{W}</em>{Dq}\in \mathbb{R}^{d\times d_c’}$$$$\textbf{q}<em>i^{(s)}=[\textbf{c}<em>i’\textbf{W}</em>{Uq}^{(s)}, \textbf{c}<em>i’\textbf{W}</em>{qR}^{(s)}\textbf{R}<em>i]\in \mathbb{R}^{1\times [d_k+d_r]},\ \ \ \ \  \textbf{W}</em>{Uq}^{(s)}\in \mathbb{R}^{d_c’\times d_k},\textbf{W}</em>{qR}^{(s)}\in \mathbb{R}^{d_c’\times d_k}$$最终版本的训练阶段：<br>$$\textbf{u}_t = \textbf{o}_t\textbf{W}_o,\ \ \ \ \ \textbf{W}_o\in \mathbb{R}^{d\times hd_k}$$<br>$$\textbf{o}_t=[\textbf{o}_t^{(1)}, \textbf{o}_t^{(2)}, …, \textbf{o}<em>t^{(h)}] \in \mathbb{R}^{1\times d}$$<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}^{(s)}, \textbf{v}</em>{i\leq t}^{(s)}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}}{\sqrt{d_k+d_r}})\textbf{v}_i^{(s)}$$<br>$$\textbf{c}_i=\textbf{x}_i\textbf{W}_c\in\mathbb{R}^{d_c},\ \ \ \ \ \textbf{W}_c\in\mathbb{R}^{d\times d_c}$$<br>$$\textbf{c}<em>i’=\textbf{x}<em>i\textbf{W}</em>{Dq}\in \mathbb{R}^{1\times d_c’},\ \ \ \ \ \textbf{W}</em>{Dq}\in \mathbb{R}^{d\times d_c’}$$<br>$$\textbf{q}<em>i^{(s)}=[\textbf{c}<em>i’\textbf{W}</em>{Uq}^{(s)}, \textbf{c}<em>i’\textbf{W}</em>{qR}^{(s)}\textbf{R}<em>i]\in \mathbb{R}^{1\times [d_k+d_r]},\ \ \ \ \  \textbf{W}</em>{Uq}^{(s)}\in \mathbb{R}^{d_c’\times d_k},\textbf{W}</em>{qR}^{(s)}\in \mathbb{R}^{d_c’\times d_k}$$<br>$$\textbf{k}_i^{(s)}=[\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)}, \textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}<em>i]\in \mathbb{R}^{1\times [d_k+d_r]},\ \ \ \ \  \textbf{W}</em>{Uk}^{(s)}\in \mathbb{R}^{d_c\times d_k}$$<br>$$\textbf{v}<em>i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{1\times d_v},\ \ \ \ \  \textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{d_c\times d_v}$$<br>$$\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}=(\textbf{c}’<em>t\textbf{W}</em>{Uq}^{(s)})(\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)})^T+(\textbf{c}<em>t\textbf{W}</em>{qR}^{(s)}\textbf{R}<em>t)(\textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}<em>i)^T$$<br>$$=\textbf{c}’<em>t(\textbf{W}</em>{Uq}^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T})\textbf{c}<em>i^T+\textbf{c}’<em>t\textbf{W}</em>{qR}^{(s)}(\textbf{R}</em>{t-i})\textbf{W}</em>{kR}^T\textbf{x}_i^T$$</p><p>最终版本的推理阶段：<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/Pasted%20image%2020250323222539.png">$$\textbf{u}_t = [\textbf{o}_t^{(1)}\textbf{W}_o^{‘(1)},\textbf{o}_t^{(2)}\textbf{W}_o^{‘(2)},…,\textbf{o}_t^{(h)}\textbf{W}_o^{‘(h)}]$$<br>$$\textbf{W}’_o=[\textbf{W}_o^{‘(1)},\textbf{W}_o^{‘(2)},…,\textbf{W}_o^{‘(h)}],\ \ \ \ \ \textbf{W}’_o\in \mathbb{R}^{d\times hd_k}$$</p><ul><li>$\textbf{W}’_o$融合了$\textbf{W}_o$和$\textbf{W}<em>v^{(g)}$得到的，在推理阶段是固定值<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}, \textbf{v}</em>{i\leq t}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t\textbf{k}_i^T}{\sqrt{d_k+d_r}})\textbf{v}_i,\ \ \ \ \ \textbf{v}_i=\textbf{c}_i\in \mathbb{R}^{1\times d_c}$$<br>$$\textbf{c}_i=\textbf{x}_i\textbf{W}<em>c\in\mathbb{R}^{d_c},\ \ \ \ \ \textbf{W}<em>c\in\mathbb{R}^{d\times d_c}$$<br>$$\textbf{c}<em>i’=\textbf{x}<em>i\textbf{W}</em>{Dq}\in \mathbb{R}^{1\times d_c’},\ \ \ \ \ \textbf{W}</em>{Dq}\in \mathbb{R}^{d\times d_c’}$$<br>$$\textbf{q}<em>i^{(s)}=[\textbf{c}<em>i’\textbf{W}</em>{Uq}^{(s)}\textbf{W}</em>{Uk}^{(s)T}, \textbf{c}<em>i’\textbf{W}</em>{qR}^{(s)}\textbf{R}<em>i]\in \mathbb{R}^{1\times [d_c+d_r]},\ \ \ \ \  \textbf{W}</em>{Uq}^{(s)}\in \mathbb{R}^{d_c’\times d_k},\textbf{W}</em>{qR}^{(s)}\in \mathbb{R}^{d_c’\times d_k},\textbf{W}</em>{Uk}^{(s)}\in \mathbb{R}^{d_c\times d_k}$$</li><li>$\textbf{W}<em>{Uq}^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T}$作为$Q$的投影矩阵<br>$$\textbf{k}_i=[\textbf{c}_i, \textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}_i]\in \mathbb{R}^{1\times [d_c+d_r]}$$</li><li>$\textbf{k}$在存储时不需要考虑不同<code>head</code></li></ul><p>对于单个token：</p><ul><li>MLA推理时需要的缓存：<ul><li>$\textbf{v}_i=\textbf{c}_i\in \mathbb{R}^{1\times d_c}$</li><li>$\textbf{k}_=[\textbf{c}_i, \textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}_i]\in \mathbb{R}^{1\times [d_c+d_r]}$，$d_c+d_r=512+64=576$</li></ul></li><li>MHA版本的缓存：$2\times d_k\times h=2\times 128\times128=32768$</li></ul><p>👇图思想来源<a href="https://www.bilibili.com/video/BV1BYXRYWEMj?spm_id_from=333.1245.0.0">DeepSeek-v2 MLA 原理讲解</a><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/de420aa56bd3f8b22e26f54c9ee1f37.jpg" alt="MLA投影过程(粗略)"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/Pasted%20image%2020250323194944.png" alt="《缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA》一文中对MLA计算量增加和效率的讨论"></p><ul><li>在第一个token生成阶段需要并行处理输入的所有token，虽然计算量增加，但是KV Cache相应减少，无功无过。</li><li>在后续每个token生成阶段，每次只输入一个，增加的计算量不会被放大，每次需要传输的KV相比原来是减少的。</li></ul><h1 id="5-对比"><a href="#5-对比" class="headerlink" title="5 对比"></a>5 对比</h1><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/Pasted%20image%2020250323164232.png"></p><ul><li>$d_c’=1536$</li><li>$d_h=d_k=d_v=128,h=128,d=d_h\times h$</li><li>$d_c=4d_h=4\times128=512$</li><li>$d_r=\dfrac{d_h}{2}=128\div2=64$</li><li>DeepSeek-V2的KV Cache($=576$)相当于GQA的$g=2.25$时的大小(GQA一个组的大小$=256$)</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Multi-head Latent Attention模型理解</title>
      <link href="/2025/03/19/mla/"/>
      <url>/2025/03/19/mla/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2405.04434">DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model</a></p><p>相关论文：<a href="https://arxiv.org/abs/2405.04434">DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model</a></p><p>本文内容围绕多头注意力机制的演变过程，着重记录MLA的设计原理，对<a href="https://spaces.ac.cn/archives/10091">缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA</a>、<a href="https://www.bilibili.com/video/BV1BYXRYWEMj?spm_id_from=333.1245.0.0">DeepSeek-v2 MLA 原理讲解</a>的内容进行整合与分析，在我理解MLA的过程中，他们给予了很好的启迪！</p><p>假设所有输入都为行向量，输入序列为$\textbf{x}_1, \textbf{x}_2, …, \textbf{x}_l$，其中$\textbf{x}_i\in \mathbb{R}^{1\times d}$</p><ul><li>$l$：token数量</li><li>$d$：<code>embdeding dimension</code></li></ul><h1 id="1-MHA-Multi-Head-Attention"><a href="#1-MHA-Multi-Head-Attention" class="headerlink" title="1 MHA(Multi Head Attention)"></a>1 MHA(Multi Head Attention)</h1><p>$$\textbf{o}_t=[\textbf{o}_t^{(1)}, \textbf{o}_t^{(2)}, …, \textbf{o}_t^{(h)}]$$</p><ul><li>$\textbf{o}<em>t$：当前<strong>t</strong>oken的注意力输出<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}^{(s)}, \textbf{v}</em>{i\leq t}^{(s)}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}}{\sqrt{d_k}})\textbf{v}_i^{(s)}$$</li><li>$\textbf{o}_t^{(s)}$：当前token的第$s$个<code>head</code>的注意力输出，$h$ 个<code>head</code>拼接得到$O_t$，其中：<br>$$\textbf{q}_i^{(s)}=\textbf{x}_i\textbf{W}_q^{(s)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_q^{(s)}\in \mathbb{R}^{d\times d_k}$$<br>$$\textbf{k}_i^{(s)}=\textbf{x}_i\textbf{W}_k^{(s)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_k^{(s)}\in \mathbb{R}^{d\times d_k}$$<br>$$\textbf{v}_i^{(s)}=\textbf{x}_i\textbf{W}_v^{(s)}\in \mathbb{R}^{1\times d_v},\ \ \ \ \  \textbf{W}_v^{(s)}\in \mathbb{R}^{d\times d_v}$$</li><li>$\textbf{W}_q^{(s)}$、$\textbf{W}_k^{(s)}$、$\textbf{W}_v^{(s)}$：分别为第$s$个<code>head</code>的query、key、value的权重矩阵，</li><li>$d_k=d_v=d/h$</li></ul><p>MHA使每个Head都有对应的$K$和$V$，模型对token的理解效果是比较好的，而问题在于，虽然有KV Cache，但是随着句子序列变长，Key和Value的缓存的成本和推理时通信的短板会变大，下图的解释会更详细点。<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/Pasted%20image%2020250322123448.png" alt="《缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA》一文中对KV Cache的分析"></p><h1 id="2-MQA-Multi-Query-Attention"><a href="#2-MQA-Multi-Query-Attention" class="headerlink" title="2 MQA(Multi Query Attention)"></a>2 MQA(Multi Query Attention)</h1><p>$$\textbf{o}_t=[\textbf{o}_t^{(1)}, \textbf{o}_t^{(2)}, …, \textbf{o}<em>t^{(h)}]$$<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}, \textbf{v}</em>{i\leq t}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t^{(s)}\textbf{k}_i^T}{\sqrt{d_k}})\textbf{v}_i$$<br>$$\textbf{q}_i^{(s)}=\textbf{x}_i\textbf{W}_q^{(s)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_q^{(s)}\in \mathbb{R}^{d\times d_k}$$<br>$$\textbf{k}_i=\textbf{x}_i\textbf{W}_k\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_k\in \mathbb{R}^{d\times d_k}$$<br>$$\textbf{v}_i=\textbf{x}_i\textbf{W}_q\in \mathbb{R}^{1\times d_v},\ \ \ \ \  \textbf{W}_v\in \mathbb{R}^{d\times d_v}$$</p><ul><li>$\textbf{W}_k$、$\textbf{W}_v$：所有<code>head</code>共享的key、value权重矩阵</li></ul><p>与MHA相比，每个Head都共享同一组$K$和$V$，</p><ul><li>显存：其KV Cache为MHA的$\dfrac{1}{h}$，是目前很节省的方法，</li><li>效果：根据《<a href="https://spaces.ac.cn/archives/10091">缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA</a>》提到的，损失是有限的，参数量通过加大其他模块的规模来补足。</li></ul><h1 id="3-GQA-Grouped-Query-Attention"><a href="#3-GQA-Grouped-Query-Attention" class="headerlink" title="3 GQA(Grouped Query Attention)"></a>3 GQA(Grouped Query Attention)</h1><p>$$\textbf{o}_t=[\textbf{o}_t^{(1)}, \textbf{o}_t^{(2)}, …, \textbf{o}<em>t^{(h)}]$$<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}^{(\lceil sg/h \rceil)}, \textbf{v}</em>{i\leq t}^{(\lceil sg/h \rceil)}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t^{(s)}\textbf{k}_i^{(\lceil sg/h \rceil)}T}{\sqrt{d_k}})\textbf{v}_i^{(\lceil sg/h \rceil)}$$<br>$$\textbf{q}_i^{(s)}=\textbf{x}_i\textbf{W}_q^{(s)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_q^{(s)}\in \mathbb{R}^{d\times d_k}$$<br>$$\textbf{k}_i^{(\lceil sg/h \rceil)}=\textbf{x}_i\textbf{W}_k^{(\lceil sg/h \rceil)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_k^{(\lceil sg/h \rceil)}\in \mathbb{R}^{d\times d_k}$$<br>$$\textbf{v}_i^{(\lceil sg/h \rceil)}=\textbf{x}_i\textbf{W}_q^{(\lceil sg/h \rceil)}\in \mathbb{R}^{1\times d_v},\ \ \ \ \  \textbf{W}_v^{(\lceil sg/h \rceil)}\in \mathbb{R}^{d\times d_v}$$</p><ul><li>$\lceil · \rceil$是向上取整</li><li>$\textbf{W}_q^{(s)}$、$\textbf{W}_k^{(s)}$、$\textbf{W}_v^{(s)}$：分别为第$s$个<code>head</code>的query、key、value的权重矩阵，</li><li>$d_k=d_v=d/h$</li></ul><p>作为显存的压缩和效果都在MHA和MQA之间的版本，GQA将<code>head</code>分为$g$个组($g$可以整除$h$)，每组共享同一对$K$、$V$。当$g=1$时就是MQA，$g=h$时就是MHA。当$1&lt;g&lt;h$时，效果不如MHA，显存压缩没有MQA那么猛，但是KV Cache压缩到MHA的$g/h$，效果比MQA好，是一个折中的版本。</p><h1 id="4-MLA-Multi-head-Latent-Attention"><a href="#4-MLA-Multi-head-Latent-Attention" class="headerlink" title="4 MLA(Multi-head Latent Attention)"></a>4 MLA(Multi-head Latent Attention)</h1><p>对KV Cache做低秩投影，通过投影矩阵$\textbf{W}_c$将$\textbf{x}_i$投影为$\textbf{c}_i$<br><a href="https://spaces.ac.cn/archives/10091">缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA</a>文章中认为”DeepSeek-V2的技术报告里是从低秩投影的角度引入MLA的……然而，笔者认为低秩投影这个角度并不贴近本质，因为要说低秩投影的话，事实上只要我们将GQA的所有K、V叠在一起，就会发现GQA也相当于在做低秩投影：<br>$$[\textbf{k}_i^{(1)}, …,\textbf{k}_i^{(g)}, \textbf{v}_i^{(1)},…,\textbf{v}_i^{(g)}] = \textbf{x}_i[\textbf{W}_k^{(1)},…,\textbf{W}_k^{(g)},\textbf{W}_v^{(1)},…,\textbf{W}_v^{(g)}]$$</p><ul><li>$[\textbf{k}_i^{(1)}, …,\textbf{k}_i^{(g)}, \textbf{v}_i^{(1)},…,\textbf{v}_i^{(g)}] = \textbf{c}_i\in \mathbb{R}^{1\times d_c}$，将所有的$\textbf{k}_i^{(s)}$、$\textbf{v}_i^{(s)}$拼在一起记为$\textbf{c}_i$，</li><li>$[\textbf{W}_k^{(1)},…,\textbf{W}_k^{(g)},\textbf{W}_v^{(1)},…,\textbf{W}_v^{(g)}] = \textbf{W}_c\in \mathbb{R}^{d\times d_c}$，将相应的投影矩阵拼在一起记为$\textbf{W}_c$，</li><li>$d_c=g(d_k+d_v)&lt;d=h(d_k+d_v)$，所以$\textbf{x}_i$到$\textbf{c}_i$的变换就是一个低秩投影，<br><strong>所以，MLA的本质改进不是低秩投影，而是低秩投影之后的工作</strong>“</li></ul><h2 id="4-1-MLA的最初构想"><a href="#4-1-MLA的最初构想" class="headerlink" title="4.1 MLA的最初构想"></a>4.1 MLA的最初构想</h2><p>得到$\textbf{c}_i$后，GQA将其对半分为K和V，将它们分别均分为$g$份，每一份复制$h/g$次，凑够$h$份K和V，然后将其投入到计算Attention和KV Cache，MLA对$\textbf{c}_i$不是简单的分割和复制，他对$\textbf{c}_i$又进行了一次投影，“增强了模型的能力”：<br>$$\textbf{u}_t = \textbf{o}_t\textbf{W}_o,\ \ \ \ \ \textbf{W}_o\in \mathbb{R}^{d\times hd_k}$$</p><ul><li>$\textbf{W}_o$是输出投影矩阵，这里的$hd_k\neq d$<br>$$\textbf{o}_t=[\textbf{o}_t^{(1)}, \textbf{o}_t^{(2)}, …, \textbf{o}<em>t^{(h)}] \in \mathbb{R}^{1\times d}$$<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}^{(s)}, \textbf{v}</em>{i\leq t}^{(s)}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}}{\sqrt{d_k}})\textbf{v}_i^{(s)}$$<br>$$\textbf{c}_i=\textbf{x}_i\textbf{W}_c\in\mathbb{R}^{1\times d_c}$$<br>$$\textbf{q}_i^{(s)}=\textbf{x}_i\textbf{W}_q^{(s)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}_q^{(s)}\in \mathbb{R}^{d\times d_k}$$<br>$$\textbf{k}<em>i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)}\in \mathbb{R}^{1\times d_k},\ \ \ \ \  \textbf{W}</em>{Uk}^{(s)}\in \mathbb{R}^{d_c\times d_k}$$<br>$$\textbf{v}<em>i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{1\times d_v},\ \ \ \ \  \textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{d_c\times d_v}$$</li><li>$\textbf{W}<em>{Uk}^{(s)}$、$\textbf{W}</em>{Uv}^{(s)}$：分别为第$s$个<code>head</code>的key、value的再投影权重矩阵，为了“增强了模型的能力”<br>然而，原本已经低秩的$\textbf{c}<em>i$在$\textbf{W}</em>{Uk}^{(s)}$和$\textbf{W}_{Uv}^{(s)}$作用下被up-projection了，即$\textbf{k}_i^{(s)}$和$\textbf{v}_i^{(s)}$原本的<code>head</code>分组不存在了，一组<code>head</code>之间不再共享$K$、$V$，“出于节省计算和通信成本的考虑，我们一般会缓存的是投影后的$\textbf{k}_i$、$\textbf{v}_i$的而不是投影前的$\textbf{c}_i$或$\textbf{x}_i$”，所以，此做法的KV Cache与MHA无异，没有显存节省的作用。</li></ul><p>虽然在训练阶段MLA的优化空间不大，但是在推理阶段中：<br>$$\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}=(\textbf{x}_t\textbf{W}_q^{(s)})\cdot (\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)})^T=\textbf{x}_t(\textbf{W}<em>q^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T})\textbf{c}_i^T$$<br>$\textbf{W}<em>q^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T}$作为$Q$的投影矩阵，K Cache的内容可以从$\textbf{k}_i$变为$\textbf{c}_i$；根据$\textbf{v}_i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uv}^{(s)}$和$\textbf{u}_t^{(s)} = \textbf{o}_t^{(s)}\textbf{W}_o^{(s)}$，输出的计算过程包含$\textbf{c}<em>i\textbf{W}</em>{Uv}\textbf{W}<em>O$，那么$\textbf{W}</em>{Uv}\textbf{W}_O$作为$V$的投影矩阵，$\textbf{v}_i$可以用$\textbf{c}_i$代替，即V Cache的内容从$\textbf{v}_i$也变为$\textbf{c}_i$。<br>那么KV Cache的内容就是$\textbf{c}_i$，它与$(s)$无关 ，是所有<code>head</code>共享的，控制好$g/h$的值，在推理阶段达到GQA或MQA的效果。<br>实际上，因为up-projection提高了模型的效果，同时在推理阶段KV Cache效果与GQA相同($1&lt;g&lt;h$)。在效果和显存的平衡下，“如果我们只需要跟GQA相近的能力，那么是不是就可以再次减少KV Cache了？换言之，$d_c$没必要取$g(dk+dv)$，而是取更小的值，从而进一步压缩KV Cache，这就是MLA的核心思想”。</p><h2 id="4-2-RoPE的兼容"><a href="#4-2-RoPE的兼容" class="headerlink" title="4.2 RoPE的兼容"></a>4.2 RoPE的兼容</h2><p>RoPE与绝对位置相关，通过绝对位置计算两个token之间的相对位置信息：<br>$$\textbf{R}_m\textbf{R}<em>n^T=\textbf{R}</em>{m-n}$$<br>MLA加上RoPE之后：<br>$$\textbf{q}_i^{(s)}=x_iW_q^{(s)}\textbf{R}_i, \ \ \ \ \ \textbf{k}_i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)}\textbf{R}_i$$<br>$$\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}=(x_tW_q^{(s)}\textbf{R}<em>t)(\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)}\textbf{R}<em>i)^T=x_tW_q^{(s)}\textbf{R}</em>{t-i}{W}</em>{Uk}^{(s)T}\textbf{c}_i^T$$<br>不能固定$\textbf{W}<em>q^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T}$值作为$Q$的投影矩阵。<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/Pasted%20image%2020250323150831.png" alt="《缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA》一文中探讨的其他方法"><br>后来解决办法为每个<code>head</code>的$\textbf{Q}$和$\textbf{K}$新增$d_r$个维度来添加RoPE的信息，其中$\textbf{K}$新增的信息由每个<code>head</code>共享<br>$$\textbf{u}_t = \textbf{o}_t\textbf{W}_o,\ \ \ \ \ \textbf{W}_o\in \mathbb{R}^{d\times hd_k}$$<br>$$\textbf{o}_t=[\textbf{o}_t^{(1)}, \textbf{o}_t^{(2)}, …, \textbf{o}<em>t^{(h)}] \in \mathbb{R}^{1\times d}$$<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}^{(s)}, \textbf{v}</em>{i\leq t}^{(s)}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}}{\sqrt{d_k+d_r}})\textbf{v}_i^{(s)}$$</p><ul><li>dot-product的scaling变成了$\sqrt{d_k+d_r}$<br>$$RoPE(\textbf{x}<em>i\textbf{W}</em>{qR}^{(s)})=\textbf{x}<em>i\textbf{W}</em>{qR}^{(s)}\textbf{R}<em>i,\ \ \ \ \ \textbf{W}</em>{qR}^{(s)}\in \mathbb{R}^{d\times d_r}$$<br>$$RoPE(\textbf{x}<em>i\textbf{W}</em>{kR})=\textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}<em>i,\ \ \ \ \ \textbf{W}</em>{kR}\in \mathbb{R}^{d\times d_r}$$<br>$$\textbf{c}_i=\textbf{x}_i\textbf{W}_c\in\mathbb{R}^{1\times d_c}$$<br>$$\textbf{q}_i^{(s)}=[\textbf{x}_i\textbf{W}_q^{(s)}, \textbf{x}<em>i\textbf{W}</em>{qR}^{(s)}\textbf{R}_i]\in \mathbb{R}^{1\times [d_k+d_r]},\ \ \ \ \  \textbf{W}_q^{(s)}\in \mathbb{R}^{d\times d_r}$$<br>$$\textbf{k}<em>i^{(s)}=[\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)}, \textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}<em>i]\in \mathbb{R}^{1\times [d_k+d_r]},\ \ \ \ \  \textbf{W}</em>{Uk}^{(s)}\in \mathbb{R}^{d\times d_r}$$<br>$$\textbf{v}<em>i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{1\times d_v},\ \ \ \ \  \textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{d_c\times d_v}$$<br>👇可以看到保留了$Q$的固定投影$\textbf{W}<em>q^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T}$和相对位置信息$\textbf{R}</em>{t-i}$<br>$$\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}=(\textbf{x}_t\textbf{W}_q^{(s)})(\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)})^T+(\textbf{x}<em>t\textbf{W}</em>{qR}^{(s)}\textbf{R}_t)(\textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}_i)^T$$<br>$$=\textbf{x}<em>t(\textbf{W}<em>q^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T})\textbf{c}<em>i^T+\textbf{x}<em>t\textbf{W}</em>{qR}^{(s)}(\textbf{R}</em>{t-i})\textbf{W}</em>{kR}^T\textbf{x}_i^T$$</li></ul><h2 id="4-3-MLA最终版本"><a href="#4-3-MLA最终版本" class="headerlink" title="4.3 MLA最终版本"></a>4.3 MLA最终版本</h2><p>“in order to reduce the activation memory during training”，最后MLA在训练阶段对$Q$的输入$\textbf{x}_i$也做了低秩投影，即$$\textbf{c}<em>i’=\textbf{x}<em>i\textbf{W}</em>{Dq}\in \mathbb{R}^{1\times d_c’},\ \ \ \ \ \textbf{W}</em>{Dq}\in \mathbb{R}^{d\times d_c’}$$$$\textbf{q}<em>i^{(s)}=[\textbf{c}<em>i’\textbf{W}</em>{Uq}^{(s)}, \textbf{c}<em>i’\textbf{W}</em>{qR}^{(s)}\textbf{R}<em>i]\in \mathbb{R}^{1\times [d_k+d_r]},\ \ \ \ \  \textbf{W}</em>{Uq}^{(s)}\in \mathbb{R}^{d_c’\times d_k},\textbf{W}</em>{qR}^{(s)}\in \mathbb{R}^{d_c’\times d_k}$$最终版本的训练阶段：<br>$$\textbf{u}_t = \textbf{o}_t\textbf{W}_o,\ \ \ \ \ \textbf{W}_o\in \mathbb{R}^{d\times hd_k}$$<br>$$\textbf{o}_t=[\textbf{o}_t^{(1)}, \textbf{o}_t^{(2)}, …, \textbf{o}<em>t^{(h)}] \in \mathbb{R}^{1\times d}$$<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}^{(s)}, \textbf{v}</em>{i\leq t}^{(s)}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}}{\sqrt{d_k+d_r}})\textbf{v}_i^{(s)}$$<br>$$\textbf{c}_i=\textbf{x}_i\textbf{W}_c\in\mathbb{R}^{d_c},\ \ \ \ \ \textbf{W}_c\in\mathbb{R}^{d\times d_c}$$<br>$$\textbf{c}<em>i’=\textbf{x}<em>i\textbf{W}</em>{Dq}\in \mathbb{R}^{1\times d_c’},\ \ \ \ \ \textbf{W}</em>{Dq}\in \mathbb{R}^{d\times d_c’}$$<br>$$\textbf{q}<em>i^{(s)}=[\textbf{c}<em>i’\textbf{W}</em>{Uq}^{(s)}, \textbf{c}<em>i’\textbf{W}</em>{qR}^{(s)}\textbf{R}<em>i]\in \mathbb{R}^{1\times [d_k+d_r]},\ \ \ \ \  \textbf{W}</em>{Uq}^{(s)}\in \mathbb{R}^{d_c’\times d_k},\textbf{W}</em>{qR}^{(s)}\in \mathbb{R}^{d_c’\times d_k}$$<br>$$\textbf{k}_i^{(s)}=[\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)}, \textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}<em>i]\in \mathbb{R}^{1\times [d_k+d_r]},\ \ \ \ \  \textbf{W}</em>{Uk}^{(s)}\in \mathbb{R}^{d_c\times d_k}$$<br>$$\textbf{v}<em>i^{(s)}=\textbf{c}<em>i\textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{1\times d_v},\ \ \ \ \  \textbf{W}</em>{Uv}^{(s)}\in \mathbb{R}^{d_c\times d_v}$$<br>$$\textbf{q}_t^{(s)}\textbf{k}_i^{(s)T}=(\textbf{c}’<em>t\textbf{W}</em>{Uq}^{(s)})(\textbf{c}<em>i\textbf{W}</em>{Uk}^{(s)})^T+(\textbf{c}<em>t\textbf{W}</em>{qR}^{(s)}\textbf{R}<em>t)(\textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}<em>i)^T$$<br>$$=\textbf{c}’<em>t(\textbf{W}</em>{Uq}^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T})\textbf{c}<em>i^T+\textbf{c}’<em>t\textbf{W}</em>{qR}^{(s)}(\textbf{R}</em>{t-i})\textbf{W}</em>{kR}^T\textbf{x}_i^T$$</p><p>最终版本的推理阶段：<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/Pasted%20image%2020250323222539.png">$$\textbf{u}_t = [\textbf{o}_t^{(1)}\textbf{W}_o^{‘(1)},\textbf{o}_t^{(2)}\textbf{W}_o^{‘(2)},…,\textbf{o}_t^{(h)}\textbf{W}_o^{‘(h)}]$$<br>$$\textbf{W}’_o=[\textbf{W}_o^{‘(1)},\textbf{W}_o^{‘(2)},…,\textbf{W}_o^{‘(h)}],\ \ \ \ \ \textbf{W}’_o\in \mathbb{R}^{d\times hd_k}$$</p><ul><li>$\textbf{W}’_o$融合了$\textbf{W}_o$和$\textbf{W}<em>v^{(g)}$得到的，在推理阶段是固定值<br>$$\textbf{o}<em>t^{(s)} = Attention(\textbf{q}<em>t^{(s)}, \textbf{k}</em>{i\leq t}, \textbf{v}</em>{i\leq t}) = \sum^t</em>{i=1}softmax(\dfrac{\textbf{q}_t\textbf{k}_i^T}{\sqrt{d_k+d_r}})\textbf{v}_i,\ \ \ \ \ \textbf{v}_i=\textbf{c}_i\in \mathbb{R}^{1\times d_c}$$<br>$$\textbf{c}_i=\textbf{x}_i\textbf{W}<em>c\in\mathbb{R}^{d_c},\ \ \ \ \ \textbf{W}<em>c\in\mathbb{R}^{d\times d_c}$$<br>$$\textbf{c}<em>i’=\textbf{x}<em>i\textbf{W}</em>{Dq}\in \mathbb{R}^{1\times d_c’},\ \ \ \ \ \textbf{W}</em>{Dq}\in \mathbb{R}^{d\times d_c’}$$<br>$$\textbf{q}<em>i^{(s)}=[\textbf{c}<em>i’\textbf{W}</em>{Uq}^{(s)}\textbf{W}</em>{Uk}^{(s)T}, \textbf{c}<em>i’\textbf{W}</em>{qR}^{(s)}\textbf{R}<em>i]\in \mathbb{R}^{1\times [d_c+d_r]},\ \ \ \ \  \textbf{W}</em>{Uq}^{(s)}\in \mathbb{R}^{d_c’\times d_k},\textbf{W}</em>{qR}^{(s)}\in \mathbb{R}^{d_c’\times d_k},\textbf{W}</em>{Uk}^{(s)}\in \mathbb{R}^{d_c\times d_k}$$</li><li>$\textbf{W}<em>{Uq}^{(s)}\cdot\textbf{W}</em>{Uk}^{(s)T}$作为$Q$的投影矩阵<br>$$\textbf{k}_i=[\textbf{c}_i, \textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}_i]\in \mathbb{R}^{1\times [d_c+d_r]}$$</li><li>$\textbf{k}$在存储时不需要考虑不同<code>head</code></li></ul><p>对于单个token：</p><ul><li>MLA推理时需要的缓存：<ul><li>$\textbf{v}_i=\textbf{c}_i\in \mathbb{R}^{1\times d_c}$</li><li>$\textbf{k}_=[\textbf{c}_i, \textbf{x}<em>i\textbf{W}</em>{kR}\textbf{R}_i]\in \mathbb{R}^{1\times [d_c+d_r]}$，$d_c+d_r=512+64=576$</li></ul></li><li>MHA版本的缓存：$2\times d_k\times h=2\times 128\times128=32768$</li></ul><p>👇图思想来源<a href="https://www.bilibili.com/video/BV1BYXRYWEMj?spm_id_from=333.1245.0.0">DeepSeek-v2 MLA 原理讲解</a><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/de420aa56bd3f8b22e26f54c9ee1f37.jpg" alt="MLA投影过程(粗略)"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/Pasted%20image%2020250323194944.png" alt="《缓存与效果的极限拉扯：从MHA、MQA、GQA到MLA》一文中对MLA计算量增加和效率的讨论"></p><ul><li>在第一个token生成阶段需要并行处理输入的所有token，虽然计算量增加，但是KV Cache相应减少，无功无过。</li><li>在后续每个token生成阶段，每次只输入一个，增加的计算量不会被放大，每次需要传输的KV相比原来是减少的。</li></ul><h1 id="5-对比"><a href="#5-对比" class="headerlink" title="5 对比"></a>5 对比</h1><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/MLA/Pasted%20image%2020250323164232.png"></p><ul><li>$d_c’=1536$</li><li>$d_h=d_k=d_v=128,h=128,d=d_h\times h$</li><li>$d_c=4d_h=4\times128=512$</li><li>$d_r=\dfrac{d_h}{2}=128\div2=64$</li><li>DeepSeek-V2的KV Cache($=576$)相当于GQA的$g=2.25$时的大小(GQA一个组的大小$=256$)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepSeek </tag>
            
            <tag> GPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLM2框架搭建过程</title>
      <link href="/2024/10/08/llm2-tui-li-yin-qing/"/>
      <url>/2024/10/08/llm2-tui-li-yin-qing/</url>
      
        <content type="html"><![CDATA[<h1 id="Lesson1-整体架构"><a href="#Lesson1-整体架构" class="headerlink" title="Lesson1 整体架构"></a>Lesson1 整体架构</h1><p>Llama2：生成式模型以decoder-only为架构<br>由两个Decoder组成：<br>①Context Decoder，位于prompt阶段，用来生成一个token；全量推理：输入是一个句子，只需要生成第一个token；具有并行计算的特点</p><p>②Mask self Decoder，位于generate阶段，用来生成第二个token；增量推理：输入是一个token，在gpt上的表现为每次吐出为一个token；每次输入的都是上一个输出的token<br><a href="https://www.jianshu.com/p/c7b40d8526dd">Transformer系列：注意力机制的优化，MQA和GQA原理简述 - 简书</a></p><h1 id="Lesson2-项目搭建-embedding-kernel"><a href="#Lesson2-项目搭建-embedding-kernel" class="headerlink" title="Lesson2 项目搭建&amp;embedding kernel"></a>Lesson2 项目搭建&amp;embedding kernel</h1><p>讲解了：<br><code>src/utils/tensor.h</code><br><code>src/kernels/input_embedding.cu</code><br><code>src/kernels/input_embedding.h</code><br><code>tests/unittests/test_input_embedding.cu</code></p><pre class="line-numbers language-none"><code class="language-none">-src|-kernels|-|-input_embeding.cu|-utils|-|-tensor.h|-weights<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LLMengine/src/utils/tensor.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Struct Tensor{Device location,DataType dtype,std::vector&lt;int&gt; shape;...virtual int size() const {&nbsp; &nbsp; &nbsp; &nbsp; if (shape.size() == 0) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // TODO: add an reminder info&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0;&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; return std::accumulate(shape.begin(), shape.end(), (int)1, std::multiplies&lt;int&gt;());&nbsp; &nbsp; }&nbsp; &nbsp; ...&nbsp; &nbsp; template&lt;typename T&gt;&nbsp; &nbsp; TensorWrapper&lt;T&gt;* as(){&nbsp; &nbsp; &nbsp; &nbsp; return static_cast&lt;TensorWrapper&lt;T&gt;*&gt;(this); // 下行转换(显式)，将this(Tensor类型的当前对象)转换为TensorWrapper&lt;T&gt;类型的指针&nbsp; &nbsp; }}Class TensorWrap: public Tensor {T * data;...}Struct TensorMap{std::unordered_map(std::string, Tensor*&gt; tensor_map);...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>std::unorder_map</code>：是一个关联容器，用于存储键值对，键是该Tensor的名字，值是指向Tensor类型变量的指针</li><li>关于为什么要在<code>TensorWrap</code>中先继承父类<code>Tensor</code>再实现模板化<code>T* data</code>：<code>Tensor</code>要放到<code>TensorMap</code>中，而C++作为强类型语言，不支持字典存放不同类型的tensor(因为类型定义为<code>Tensor</code>的指针，如果在<code>Tensor</code>中加入了<code>T*</code>作为成员，可能会乱套了)</li><li><code>std::accumulate(shape.begin(), shape.end(), (int)1, std::multiplies&lt;int&gt;());</code>：做乘积，初始乘的值为1</li></ul><p>如果<code>.cpp</code>文件调用带有cuda语法的函数，则其定义不能存在<code>.h</code>文件里，例如含有<code>&lt;&lt;&lt; &gt;&gt;&gt;</code><br>    例子：在<code>src/kernel/input_embedding.cu</code>中</p><ul><li>定义了<code>launchInputEmbedding</code>👇<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;void launchInputEmbedding(TensorWrapper&lt;int&gt;* input_ids, &nbsp; &nbsp;// INT [token num]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TensorWrapper&lt;T&gt;* output, &nbsp; &nbsp; &nbsp; // FP32 [token num, hidden_size] = [token num, 4096]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EmbeddingWeight&lt;T&gt;* embed_table// FP32 [vocal_size, hidden_size]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ) {&nbsp; &nbsp; // 分配线程块，核函数需要的维度信息&nbsp; &nbsp; const int blockSize = 256;&nbsp; &nbsp; const int max_context_token_num = output-&gt;shape[0]; // token num&nbsp; &nbsp; const int hidden_size = output-&gt;shape[1];&nbsp; &nbsp; const int gridSize = 2048;&nbsp; &nbsp; LLM_CHECK_WITH_INFO(max_context_token_num == input_ids-&gt;shape[0], "input ids 1st shape should equal to 1st shape of output");&nbsp; &nbsp; embeddingFunctor&lt;T&gt;&lt;&lt;&lt;gridSize, blockSize&gt;&gt;&gt;(input_ids-&gt;data,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;output-&gt;data,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;embed_table-&gt;data,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;max_context_token_num,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hidden_size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>实例化<ul><li>显式实例化是告诉编译器生成一个模板函数的特定实例。在模板函数定义中，只是定义了一个通用的逻辑，但没有真正生成代码。<strong>只有在模板实例化的时候，编译器才会根据具体的数据类型来生成相应的函数代码。</strong></li><li>原因：<ul><li>避免代码膨胀：如果不显式实例化，那么每次使用不同类型调用模板函数时，编译器都会生成新的代码</li><li>CUDA编译限制</li></ul></li><li>分别生成了👇两种类型的具体实例<code>T=float</code>、<code>T=half</code><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 显式实例化模版函数，由于cuda的语法规则，不能存在.cpp文件里，因此只能在此实例化template void launchInputEmbedding(TensorWrapper&lt;int&gt;* input_ids, &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TensorWrapper&lt;float&gt;* output, &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EmbeddingWeight&lt;float&gt;* embed_table);template void launchInputEmbedding(TensorWrapper&lt;int&gt;* input_ids, &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TensorWrapper&lt;half&gt;* output, &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EmbeddingWeight&lt;half&gt;* embed_table);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p><code>src/kernels/input_embedding.cu</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__global__ void embeddingFunctor(const int* input_ids,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T* output,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const T* embed_table,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const int max_context_token_num,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const int hidden_size){&nbsp; &nbsp; int index = blockIdx.x * blockDim.x + threadIdx.x;&nbsp; &nbsp; while (index &lt; max_context_token_num * hidden_size) {&nbsp; &nbsp; &nbsp; &nbsp; int id = input_ids[index / hidden_size];&nbsp; &nbsp; &nbsp; &nbsp; output[index] = embed_table[id * hidden_size + index % hidden_size];&nbsp; &nbsp; &nbsp; &nbsp; index += blockDim.x * gridDim.x;&nbsp; &nbsp; }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/6382f7e2cd4bf0b302b43f58c93ea08.jpg">index的索引对应的是output的输出的每个位置？</p><p>这个kernel的用处：将原本输入格式的[batch size, sequence length]变成[batch size, sequence length, hidden size]</p><p>有<code>.cpp</code>文件、<code>.cc</code>文件、<code>.cu</code>文件的目录下需要放<code>CMakeLists.txt</code>文件</p><h1 id="Lesson3-Calculate-padding-offset-kernel"><a href="#Lesson3-Calculate-padding-offset-kernel" class="headerlink" title="Lesson3 Calculate padding offset kernel"></a>Lesson3 Calculate padding offset kernel</h1><p>讲解了：<br><code>src/kernels/cal_paddingoffset.cu</code><br><code>src/kernels/cal_paddingoffset.h</code><br><code>tests/unittests/test_cal_paddingoffset.cu</code></p><p><a href="https://github.com/bytedance/effective_transformer">Padding Offset思想来源</a><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/Pasted%20image%2020241011153928.png" alt="|425"></p><p><code>src/lkernels/cal_paddingoffset.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void launchCalPaddingoffset(TensorWrapper&lt;int&gt;* padding_offset,TensorWrapper&lt;int&gt;* cum_seqlens,TensorWrapper&lt;int&gt;* input_lengths);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>参数：<br>  <code>padding_offset</code>：<code>[batch size, max q_seq length]</code>记录每个token在其之前的padding个数<br>  <code>cum_seqlens</code>：<code>[batch size + 1]</code>第一个句子累积长度是它本身，第二个句子累积长度是第一句+第二句长度<br>  <code>input_lengths</code>：<code>[batch size]</code>每个句子的输入长度，本身的<br>  <code>launchCalPaddingoffset</code>函数的目的是输出padding个数和累积长度</li><li>例子：<br>  11100<br>  11000<br>  11111<br>  batch size = 3<br>  seqlen = [3, 2, 5]<br>  max_q_len = 5<br>  padding_offset = [0, 0, 0, 0, 0<br>              2, 2, 2, 2, 2<br>              5, 5, 5, 5, 5]<br>  cum_seqlens = [0, 3, 5, 10]</li></ul><p>相比于<code>Lesson2</code>中的模板化，这里不需要模板化的原因是，该函数的参数都是<code>int</code>类型，而<code>Lesson2</code>中的是<code>T</code>类型，需要对其做<code>FP16</code>和<code>FP32</code>的模板化</p><p><code>src/kernels/cal_paddingoffset.cu</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__global__ void CalPaddingoffset(int* &nbsp; &nbsp; &nbsp; &nbsp; padding_offset,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int* &nbsp; &nbsp; &nbsp; &nbsp; cum_seqlens,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const int* &nbsp; input_lengths, //actual input lens&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const int &nbsp; &nbsp;batch_size,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const int &nbsp; &nbsp;max_q_len) {&nbsp; &nbsp; // 自己打的24-10-11&nbsp; &nbsp; int cum_offset = 0;&nbsp; &nbsp; int ind = 0;&nbsp; &nbsp; int total_seqlen = 0;&nbsp; &nbsp; for(int b = 0; b &lt; batch_size; b++) { // b对应每个batch中的第b+1个seq&nbsp; &nbsp; &nbsp; &nbsp; int seqlen = input_lengths[b]; &nbsp; &nbsp;// 获取每个句子长度&nbsp; &nbsp; &nbsp; &nbsp; cum_seqlens[b] = total_seqlen; &nbsp; &nbsp;// (1)将累积的seqlen存入到每个句子中，cum_seqlens[0] = 0, ..., cum_seqlens[0] = 最后一个句子的句子累积长度&nbsp; &nbsp; &nbsp; &nbsp; for( int i =0; i &lt; seqlen; i++) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; padding_offset[ind] = cum_offset; // (2)将累积的offset存入到每个token中，padding_offset的下标应该是一个累积的值，所以应该在for的外部定义ind然后取其为下标&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ind++;&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; cum_offset += max_q_len - seqlen; &nbsp; &nbsp; // 获取每个句子累积的offset&nbsp; &nbsp; &nbsp; &nbsp; total_seqlen += seqlen; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 获取每个句子累积的句子长度&nbsp; &nbsp; }&nbsp; &nbsp; cum_seqlens[batch_size] = total_seqlen;&nbsp; &nbsp; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>kernel</code>写完之后还需要写<code>CMake</code>文件<br><code>test/unittest/CMakelist.txt</code>：将test编译为可执行文件</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">add_executable(cal_paddingoffset // ※test_input_embedding.cu)target_link_libraries(cal_paddingoffset PUBLIC    //这要和※处的名称对应-lcudart-lcudadevrtpaddingoffset               // 这里可以自己起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>src/kernels/CMakelist.txt</code>(注意和上面的名称的对应)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">add_library(paddingoffset STATIC cal_paddingoffset.cu)set_property(TARGET paddingoffset PROPERTY CUDA_SEPARABLE_COMPILATION   ON)set_property(TARGET paddingoffset PROPERTY POSITION_INDEPENDENT_CODE ON)set_property(TARGET paddingoffset PROPERTY CUDA_RESOLVE_DEVICE_SYMBOLE ON)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Lesson4-RMS-norm"><a href="#Lesson4-RMS-norm" class="headerlink" title="Lesson4 RMS norm"></a>Lesson4 RMS norm</h1><p>讲解了：<br><code>src/kernels/rmsnorm_kernel.cu</code><br><code>src/kernels/rmsnorm_kernel.h</code><br><code>tests/unittests/test_rmsnorm.cu</code><br><code>src/utils/vectorize_utils.h</code><br><code>src/weights/llama/norm_weights.h</code></p><p><code>src/utils/vectorize_utils.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;struct Vec{&nbsp; &nbsp; using Type = T;&nbsp; &nbsp; static constexpr int size = 0;};// 除此之外还定义了float4(size=4)，half2(size=2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>static</code>：表示该成员<code>size</code>属于类而不是某个实例(对象)<br><code>constexpr</code>：定义一个静态的类成员，并且该成员是一个编译时常量，在编译时就确定<br><code>float4</code>和<code>half2</code>分别是包含4个<code>float</code>分量的向量和包含2个<code>half</code>分量的向量<br>作用是存储通用的向量化数据结构</p><p><code>src/weights/llama/norm_weights.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  struct LayerNormWeight {      T* gamma; };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-1src-kernel-rmsnorm-kernel-cu"><a href="#4-1src-kernel-rmsnorm-kernel-cu" class="headerlink" title="4.1src/kernel/rmsnorm_kernel.cu"></a>4.1<code>src/kernel/rmsnorm_kernel.cu</code></h2><p>(1)<code>warpReduceSum</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  __device__ T warpReduceSum(T val){      for(int i = 32 / 2; i &gt; 0; i &gt;&gt;= 1){          val += __shfl_xor_sync(0xffffffff, val, i);      }        return val; // 最后这个warp的结果保存在第一个第一个线程(threadIdx.x=0)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将一个warp中的数据加起来</p><p>(2)<code>blockReduceSum</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  __device__ T blockReduceSum(T val){      int tid = threadIdx.x;      it wid = tid / 32;      int laneid = tid % 32;      int warpnum = (blockDim.x + 32 - 1) / 32;      val = warpReduceSum&lt;T&gt;(val);     // val是每个warp的总和的值    static __shared__ T warpsum[64]; // 不能写warpnum，因为申请的是静态的，需要传入编译期常量64    if(landid == 0) // 如果是wrap的第一个线程(存有该wrap的结果)    {     warpsum[wid] = val; // 将每个warp的求和放入warpsum中    }        __syncthreads(); // 处理完共享内存的读写后要加上`__syncthreads();!!!    T sum = tid &lt; warpnum ? warpsum[wid] : (T)0;     // 处理前warpnum个warpsum[wid]，并且确保使用线程id为0~warpnum-1来处理    sum = warpReduceSum&lt;T&gt;(sum);      return sum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将一个block的数据加起来<br>参数：<br>    <code>tid</code>：全局的thread idx (0<del>?)<br>    <code>wid</code>：wrap idx，每32个threads为一个wrap (0</del>?)<br>    <code>laneid</code>：wrap中的thread的编号(0~31)<br>    <code>warpnum</code>：用到的warp的个数，最小为1，所以这里需要向上取整<br>    <code>warpsum</code>：大小为64的类型为T的数组，存放每个warp的总和</p><p>(3)<code>RMSNorm</code><br>计算公式：$\dfrac{x_i×g_i}{\sqrt{\sum^iE(x_i^2)+eps}}$</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;  __global__ void RMSNorm(T* decoder_in,                        T* decoder_residual,                          T* scale, //[q_hidden_units], RMSNorm weights                          float eps, //RMSNorm eps                          int num_tokens,                          int hidden_units) {  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数：<br>    <code>decoder_in</code>：是输入同时也是输出位置，<code>[num tokens, q_hidden_units]</code><br>    <code>decoder_residual</code>：暂时不知道这个的用处<br>    <code>scale</code>：可学习的参数(权重)，<code>[q_hidden_units]</code><br>    <code>eps</code>：很小的正数<br>    <code>num_tokens</code>：token的个数<br>    <code>hidden_units</code>：隐藏层的单元的数量</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int vec_size = Vec&lt;T&gt;::size;using Vec_t = typename Vec&lt;T&gt;::Type;  Vec_t *dout = reinterpret_cast&lt;Vec_t*&gt;(decoder_in + blockIdx.x * hidden_units); // 每个线程需要读的数据的偏移; block的数量是token的数量  Vec_t *rsd = reinterpret_cast&lt;Vec_t*&gt;(decoder_residual * blockIdx.x * hidden_units);  float thread_sum = 0.0f;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数：<br>    <code>vec_size</code>：读取vector的大小，比如<code>float4</code>的向量个数为4，<code>half2</code>的向量个数为2<br>    <code>Vec_t</code>：读取类型并存到<code>Vec_t</code>中<br>        ！前一句没有用<code>typename</code>而后一句用了的原因是：<br>        ①前者属于非依赖型，<code>size</code>的值在编译时可以确定，与<code>T</code>d的具体类型无关；<br>        ②后者时依赖类型，<code>Type</code>是一个类型别名，取决于<code>T</code>，因此需要<code>typename</code>关键字来告诉编译器他是一个类型<br>    <code>dout</code>：根据线程指向每一个以输入向量为起始的<code>block</code>的开头，每一个<code>block</code>对应一个<code>token</code>，每个<code>block</code>之间相差大小为<code>hidden units</code>的间隔<br>    <code>rsd</code>：同<code>dout</code><br>    <code>thread_sum</code>：用于求和</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int idx = threadIdx.x; idx &lt; hidden_units / vec_size; idx += blockDim.x) {          Vec_t vec = dout[idx];        rsd[idx] = vec;          thread_sum += vec.x * vec.x;          thread_sum += vec.y * vec.y;          thread_sum += vec.z * vec.z;          thread_sum += vec.w * vec.w;      }    thread_sum = blockReduceSum&lt;float&gt;(thread_sum);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用于求$\sum^iE(x_i)$，每个block得到一个总和<br>参数：<br>    <code>vec</code>：将<code>dout[idx]</code>的数据存到vec中<br>    <img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/492e42f3b277fbb6c44c818fa908be8.jpg" alt="|225"><br>    <code>thread_sum</code>：每个线程都有一个私有的副本<br>注意：<br>    <code>idx</code>的范围是从<code>threadIdx.x</code>开始的，范围是0~`blockDim.x-1<code>     因此每个for循环实际只处理了一个block的求和，</code>idx+=blockDimx.x`使得可以对下一个block进行求和<br>    所以说这里的求和是block层面的，也是每个token层面的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__shared__ float inv_mean;  if (threadIdx.x == 0) {      inv_mean = rdqrtf(thread_sum / hidden_units + eps);  }    __syncthreads(); // share memory inv_mean写入完成后要加上这句话  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用于计算平均值$inv_mean\dfrac{1}{\sqrt{\sum^iE(x_i^2)+eps}}$<br>    <code>inv_mean</code>：因为均值是<code>block</code>层面的，所以最好把它设为share memory<br>    share memory写入完成后要加上<code>__syncthreads();</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Vec_t *s = reinterpret_cast&lt;Vec_t *&gt;(scale);      for (int idx = threadIdx.x; idx &lt; hidden_units / vec_size; idx += blockDim.x) {          Vec_t vec = dout[idx];          dout[idx].x = vec.x * inv_mean * s[idx].x; // 因为输入输出都是decoder_in，所以需要实实在在地进dout[idx]这个指针指向的buffer，等号左边不能用vec          dout[idx].y = vec.y * inv_mean * s[idx].y; // 因为vec size是4，所以累加4次          dout[idx].z = vec.z * inv_mean * s[idx].z;          dout[idx].w = vec.w * inv_mean * s[idx].w;      }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用于计算$inv_mean × x_i ×g_i$<br>注意：需要把结果写回<code>dout</code>中</p><p>(4)<code>launchRMSNorm</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  void launchRMSNorm( TensorWrapper&lt;T&gt;* decoder_out,                    TensorWrapper&lt;T&gt;* decoder_residual,                    LayerNormWeight&lt;T&gt;&amp; attn_norm_weight,                    bool is_last                     ){      int num_tokens = decoder_out-&gt;shape[0];      int hidden_units = decoder_out-&gt;shape[1];      int vec_size = Vec&lt;T&gt;::size;      int num_threads = hidden_units / 4;    T* rsd = decoder_residual-&gt;data;      dim3 grid(num_tokens);   // num_tokens个block    dim3 block(num_threads); // hidden_units / 4个block    RMSNorm&lt;T&gt;&lt;&lt;&lt;grid, block&gt;&gt;&gt;(decoder_out-&gt;data,                              rsd,                              attn_norm_weight.gamma, // scale                            eps,                              num_tokens,                              hidden_units);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Lesson5-Casual-Mask"><a href="#Lesson5-Casual-Mask" class="headerlink" title="Lesson5 Casual Mask"></a>Lesson5 Casual Mask</h1><p>讲解了：<br><code>src/kernels/build_casual_mask.cu</code><br><code>src/kernels/build_casual_mask.h</code><br><code>tests/unittests/test_casual_mask.cu</code></p><p><code>src/kernel/build_casual_mask.cu</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  __global__ void BuildCausalMasksConsideringContextPastKV(T* mask,                                                const int* q_lens,                                                const int* k_lens,                                                int max_q_len,                                                 int max_k_len){    int tid = threadIdx.x;      int qlen = q_lens[blockIdx.x];    int klen = k_lens[blockIdx.x];    mask += blockIdx.x * max_k_len * max_q_len; // 每个block只有256个线程，相应的，mask也需要有偏移量移动到下一个mask上，与block的移动同步      while(tid &lt; max_k_len * max_q_len){          int q = tid / max_k_len; // 目前处于哪一行          int k = tid % max_k_len; // 目前处于哪一列          bool is_one = q &lt; qlen &amp;&amp; k &lt; klen &amp;&amp; k &lt;= q + (klen - qlen);          mask[tid] =  static_cast&lt;T&gt;(is_one);          tid += blockDim.x;     }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数：<br>    <code>mask</code>：<code>[batch_size, max_q_len, max_k_len]</code>每个<code>mask</code>是一个矩阵，用于表示哪些token对于目前对话是可见的(置1)和不可见的(置0)<br>    <code>q_lens</code>：<code>[batch_size]</code>，作为input lens，我的理解是当前对话的输入<br>    <code>k_lens</code>：<code>[batch_size]</code>，作为context lens，我的理解是结合一定程度的上下文的输入<br>    <code>max_q_len</code>&amp;<code>max_k_len</code>：分别是<code>q_lens</code>和<code>k_lens</code>中最大的<br>理解：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int qlen = q_lens[blockIdx.x];int klen = k_lens[blockIdx.x];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>👆每个<code>block</code>对应一个对话，<code>batch_size</code> = 对话个数。这里是分别取每个对话的<code>qlen</code>和<code>klen</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">mask += blockIdx.x * max_k_len * max_q_len;   while(tid &lt; max_k_len * max_q_len){         int q = tid / max_k_len; // 目前处于哪一行         int k = tid % max_k_len; // 目前处于哪一列         bool is_one = q &lt; qlen &amp;&amp; k &lt; klen &amp;&amp; k &lt;= q + (klen - qlen);         mask[tid] = static_cast&lt;T&gt;(is_one);         tid += blockDim.x;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>为了确保<code>mask</code>里的每个数都能被处理到（第三句很重要）<ul><li><code>mask[tid] = static_cast&lt;T&gt;(is_one); </code>：<code>block</code>中的一个线程对应<code>mask</code>里的一个数，但是<code>blockDim.x=256</code>，所以需要加上第三句话</li><li>循环条件<code>tid &lt; max_k_len * max_q_len</code>：确保每个数都有对应线程处理</li><li><code>mask += blockIdx.x * max_k_len * max_q_len;</code>：</li><li><code>mask</code>的大小＞<code>block</code>的线程数的情况👇</li></ul></li></ul><p>那么就是一个<code>block</code>处理一个<code>mask</code>，如果<code>block</code>大小小于<code>mask</code>的话，就继续用该<code>block</code>的线程处理<code>mask</code>剩余的数</p><h1 id="Lesson6-Linear"><a href="#Lesson6-Linear" class="headerlink" title="Lesson6 Linear"></a>Lesson6 Linear</h1><p>讲解了：<br><code>src/kernels/cublas_utils.h</code>：定义cublas类<br><code>src/kernels/cublas_utils.cc</code>：实现cublas类<br><code>src/kernels/linear.cu</code><br><code>src/kernels/linear.h</code><br><code>tests/unittests/test_linear.cu</code></p><h2 id="6-1-cublas类的声明与定义"><a href="#6-1-cublas类的声明与定义" class="headerlink" title="6.1 cublas类的声明与定义"></a>6.1 cublas类的声明与定义</h2><p><code>src/kernels/cublas_utils.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class cublasWrapper {  private:      cublasHandle_t cublas_handle;    cudaDataType_t Atype;    cudaDataType_t Btype;    cudaDataType_t Ctype;    cublasComputeType_t computeType;public:      cublasWrapper(cublasHandle_t cublas_handle);      ~cublasWrapper();    void setFP32GemmConfig();    void setFP16GemmConfig();    void Gemm(cublasOperation_t transa,                cublasOperation_t transb,                const int         m,                const int         n,                const int         k,                const void*       A,                const int         lda,                const void*       B,                const int         ldb,                void*             C,                const int         ldc,                float             alpha,                float             beta);          // for qk*v and q*k        void stridedBatchedGemm(cublasOperation_t transa,                          cublasOperation_t transb,  const int         m,  const int         n,  const int         k,  const void*       A,  const int         lda,  const int64_t     strideA,  const void*       B,  const int         ldb,  const int64_t     strideB,  void*             C,  const int         ldc,  const int64_t     strideC,  const int         batchCount,  float             f_alpha,  float             f_beta);  };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>👆声明<code>cublasWrapper</code>类，<code>batchedGemm</code>相对于<code>Gemm</code>多了步长<code>stride</code>和<code>batchCount</code></p><p>定义部分：<br>①构造函数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cublasWrapper::cublasWrapper(cublasHandle_t cublas_handle,                               cublasLtHandle_t cublaslt_handle):      cublas_handle(cublas_handle),      cublaslt_handle(cublaslt_handle){  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>cublasHandle_t</code>是cublas库中的一个类型，与句柄有关</li><li>传入<code>cublas_handle</code>返回到类中的<code>cublas_handle_</code></li><li><code>cublasHandle_t</code>和<code>cublasLtHandle_t</code><ul><li><code>cublasHanle_t</code>：用于一般的线性代数运算（如向量和矩阵操作）</li><li><code>cublasLtHandle_t</code>：用于更高级的矩阵运算，特别是自定义和优化矩阵乘法（GEMM），在需要复杂配置或多种数据类型时有用处</li></ul></li></ul><p>②单精度与半精度的配置</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void cublasWrapper::setFP32GemmConfig()  {      Atype       = CUDA_R_32F;      Btype       = CUDA_R_32F;      Ctype       = CUDA_R_32F;      computeType = CUBLAS_COMPUTE_32F; // }    void cublasWrapper::setFP16GemmConfig()  {      Atype       = CUDA_R_16F;      Btype       = CUDA_R_16F;      Ctype       = CUDA_R_16F;      computeType = CUBLAS_COMPUTE_16F;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对于<code>computeType</code>，当cuda version&lt;11.0时用CUDA_R_32F，cuda version&gt;11.0时使用CUBLAS_COMPUTE_32F，半精度的同理</li></ul><p>③为<code>alpha</code>和<code>beta</code>赋值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const void* alpha = is_fp16_computeType ? reinterpret_cast&lt;void*&gt;(&amp;(h_alpha)) : reinterpret_cast&lt;void*&gt;(&amp;f_alpha);  const void* beta  = is_fp16_computeType ? reinterpret_cast&lt;void*&gt;(&amp;(h_beta)) : reinterpret_cast&lt;void*&gt;(&amp;f_beta);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>如果<code>is_fp16_computeTyp</code>为1，则传入半精度的<code>alpha</code>给<code>alpha</code>，<code>beta</code>同理</li></ul><p>④关于batchedGemm与Gemm同理</p><h2 id="6-2-Gemm"><a href="#6-2-Gemm" class="headerlink" title="6.2 Gemm"></a>6.2 Gemm</h2><p><code>src/kernels/linear.cu</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  void launchLinearGemm(TensorWrapper&lt;T&gt;* input,                        BaseWeight&lt;T&gt;&amp; weight,     TensorWrapper&lt;T&gt;* output,                        cublasWrapper* cublas_wrapper,                        bool trans_a = false,                        bool trans_b = false){                      {  Bk = input-&gt;shape.size() == 3 ? input-&gt;shape[1] * input-&gt;shape[2] : input-&gt;shpe[1];  Cm = output-&gt;shape.size() == 3 ? output-&gt;shape[1] * output-&gt;shape[2] : output-&gt;shpe[1];    int lda = Am;  int ldb = Bk;  int ldc = Cm;  cublasOperation_t transA = trans_b ? CUBLAS_OP_T : CUBLAS_OP_N; cublasOperation_t transB = trans_a ? CUBLAS_OP_T : CUBLAS_OP_N;// 可能会出现输入为[bs, 1, hiddenunits] * [hiddenunits, hiddenunits]，所以需要检查输入的维度if(!trans_b &amp;&amp; !trans_a){       LLM_CHECK_WITH_INFO(Ak == Bk, "2nd dim of input MUST = 1st dim of weight!");  }    cublas_wrapper-&gt;Gemm(transA,                       transB,                       trans_b ? Ak : Am,           // m                     Cn,                          // n                     Bk,                          // k                     weight.data,                       lda,                       input-&gt;data,                       ldb,                       output-&gt;data,                       ldc,                       1.0f,                       0.0f);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>① 关于A、B、C<br>(1)一般的gemm<br>A：<code>input shape = [seqlen, hidden_units]</code><br>B：<code>weight shape = [hidden_units, hidden_units]</code><br><code>A * B = C with trans_b = false</code></p><p>对于qkvlinear，是指将三次矩阵乘法融合到一次<br><code>input=[seqlen, hidden_units]</code><br><code>weight shape = [hidden_units, 3×hidden_units]</code></p><p>(2)出现在sampling的<code>LMHead</code><br>A：<code>input shape = [batch_size, hidden_units]</code><br>B：<code>weight_shape = [vocabulary_size, hidden_units]</code><br><code>A * B = C with transb = true</code></p><p>②重点与难点：</p><ul><li><code>torch.nn.linear</code>的计算公式是$y=x×w^T$，修改之前是$y=x×w$，因此<code>trans_b=True</code></li><li>cublas API接受的输入以及输出的内存排布全部都默认为<strong>列主序(column-major)</strong><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/Pasted%20image%2020241019161646.png"></li><li>因此，我们的思路是<ul><li>从原本的$y=x×w$，因为<code>nn</code>的计算方式</li><li>加上<code>trans_b=True</code>后可以实现$y=x×w^T$，因为列主序(从行主序到列主序需要将两边同时转置)<ul><li>这里的<code>trans_b</code>对应的是原本我们理解的$y=x×w$公式，<code>trans_b</code>对应$w$</li><li>变成column major之后<code>A</code>对应$w^T$，所以是用<code>trans_b</code>决定<code>trans_A</code></li></ul></li><li>将$y=x×w^T$变成$y^T=w×x^T$后可以实现列序列的要求，那么对应$y=x×w$就应该变成$y^T=w^T×x^T$</li><li>即从原始的$y=x×w$变成我们需要的公式，只需要<ul><li>添加<code>trans_b=True</code></li><li>公式$y^T=w^T×x^T$</li></ul></li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Am = weight.shape[1];int Ak = weight.shape[0];  int Bk = input-&gt;shape[1];  int Bn = input-&gt;shape[0];  int Cm = output-&gt;shape[1];  int Cn = output-&gt;shape[0];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-3-StrideBatchGemm"><a href="#6-3-StrideBatchGemm" class="headerlink" title="6.3 StrideBatchGemm"></a>6.3 StrideBatchGemm</h2><p>①关于input1和input2<br>$q×k$<br>input1：<code>q shape = [batch_size, head_nums, seqlen(=len_q), hidden_units]</code><br>input2：<code>k shape = [batch_size, head_nums, seqlen(=len_k), hidden_units]</code><br><code>A * B = C with trans_b = true</code><br>$qk×v$<br>input1：<code>qk shape = [batch_size, head_nums, seqlen(=len_q), seqlen(=len_k)]</code><br>input2：<code>v shape = [batch_size, head_nums, seqlen(=len_k), hidden_units]</code><br><code>A * B = C with transb = false</code><br>实际上在<code>src/kernels/linear.cu</code>中处理过程与Gemm差不多</p><p>②StrideBatchGemm和BatchGemm相比<br>假如<code>A=[1,2,3,4]</code></p><ul><li>StrideBatch多一个<code>Stride</code>变量，用于作地址偏移取出要相乘的值，偏移量等于<code>A[i]</code>和<code>A[i+1]</code>之间的距离<ul><li>=3*4</li></ul></li><li>两个都有<code>batchCount</code>变量<ul><li>对于StrideBatch是每个批次中需要相乘的矩阵个数 = 1*2</li><li>BatchGemm是A、B、C中指针个数，及矩阵个数</li></ul></li></ul><h2 id="6-4-其他"><a href="#6-4-其他" class="headerlink" title="6.4 其他"></a>6.4 其他</h2><p><code>cublasHanle_t</code>用于定义一个句柄，用于管理和配置 <code>cuBLAS</code> 库中的所有函数调用，类似一个控制器(开/关)</p><p>初始化列表例子 ：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person {public:////传统方式初始化//Person(int a, int b, int c) {//m_A = a;//m_B = b;//m_C = c;//}//初始化列表方式初始化Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}void PrintPerson() {cout &lt;&lt; "mA:" &lt;&lt; m_A &lt;&lt; endl;cout &lt;&lt; "mB:" &lt;&lt; m_B &lt;&lt; endl;cout &lt;&lt; "mC:" &lt;&lt; m_C &lt;&lt; endl;...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RAII</code>机制可以自动析构掉一些类成员变量</p><p>huggingface的7b chat中linear的weight全是转置后的，比如<code>gate</code>的权重应该是<code>[q_hidden_units, inter_size]</code>，但是在huggingface里是<code>[inter_size, q_hidden_units]</code>，所以<code>launchLinearGemm</code>的<code>trans_b</code>对于所有linear weights来说都是<code>true</code></p><h1 id="Lesson7-Debug-一"><a href="#Lesson7-Debug-一" class="headerlink" title="Lesson7 Debug(一)"></a>Lesson7 Debug(一)</h1><p><code>src/kernels/rmsnorm_kernel.cu</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">dout[idx].x = __float2half(vec.x * inv_mean) * s[idx].x;dout[idx].y = __float2half(vec.y * inv_mean) * s[idx].y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>出现如下报错： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">error: <span class="token function">more</span> than one operator <span class="token string">"*"</span> matches these operands:built-in operator <span class="token string">"arithmetic * arithmetic"</span><span class="token keyword">function</span> <span class="token string">"operator*(const __half &amp;, const __half &amp;)"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在编译器执行乘法运算时，发现有多个符合条件的*操作符但是不确定应该使用哪一个</p><ul><li><code>built-in operator "arithmetic * arithmetic"</code>：这是CUDA支持的基本算术类型之间的乘法操作（如整数或浮点数）。</li><li><code>function "operator*(const __half &amp;, const __half &amp;)"</code>：这是CUDA中针对<code>__half</code>类型（即半精度浮点数）提供的乘法操作符。<br>解决方法：<br>将代码改为<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">dout[idx].x = s[idx].x * __float2half(__half2float(vec.x) * inv_mean);dout[idx].y = s[idx].y * __float2half(__half2float(vec.y) * inv_mean);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>编译顺序从<code>kernels</code>到<code>tests</code>原因：</p><ul><li>编译<code>tests</code>时需要调用到<code>src/kernels</code>的cuda函数或者launch函数，所以需要先编译<code>kernels</code>文件下的</li><li>在根目录下的<code>CMakeList.txt</code>中有先后顺序<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">add_subdirectory(src)add_subdirectory(tests)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h1 id="Lesson8-RoPE"><a href="#Lesson8-RoPE" class="headerlink" title="Lesson8 RoPE"></a>Lesson8 RoPE</h1><p><a href="https://www.53ai.com/news/qianyanjishu/1291.html">一文看懂 LLaMA 中的旋转式位置编码（Rotary Position Embedding）</a><br>讲解了：<br><code>src/kernels/qkv_bias_and_RoPE.cu</code><br><code>src/kernels/qkv_bias_and_RoPE.h</code><br><code>src/models/llama/llama_params.h</code><br><code>tests/unittests/test_bias_and_rope.cu</code><br><code>src/utils/vectorize_utils.h</code></p><p>本节融合算子的作用</p><ul><li>将<code>qkv bias</code>加到<code>QKV</code>上，<code>QKV = [num tokens, qkv head num, head size]</code><ul><li><code>qkv head num</code> = <code>q head num</code> + <code>k head num</code> + <code>v head num</code></li><li><code>k head num</code> = <code>v head num</code></li></ul></li><li>padding后，<code>QKV</code>会被分割成三个矩阵<code>q</code>、<code>k</code>、<code>v</code>，<ul><li>shape(q)=<code>[bs, q head num, max q len, head size]</code></li><li>shape(k/v)=<code>[bs, kv head num, max q len, head size]</code></li></ul></li><li>rope &amp; attention</li><li>写回显存(gmem)</li></ul><p>输入：<br>    <code>QKV</code> shape=<code>[num tokens, qkv head num, head size]</code><br>    <code>qkv bias</code> shape = <code>[qkv head num, head size]</code><br>输出：<br>    <code>q</code>：<code>[bs, q head num, max q len, head size]</code><br>    <code>k</code>：<code>[bs, kv head num ,max q len, head size]</code><br>    <code>v</code>：<code>[bs, kv head num, max q len, head size]</code><br>    这里的<code>max q len</code>就是<code>seqlen</code><br>下一节会讲到<code>repeat kv</code></p><h2 id="8-1-src-kernels-qkv-bias-and-RoPE-cu"><a href="#8-1-src-kernels-qkv-bias-and-RoPE-cu" class="headerlink" title="8.1 src/kernels/qkv_bias_and_RoPE.cu"></a>8.1 <code>src/kernels/qkv_bias_and_RoPE.cu</code></h2><p>llama使用的是QGA(Grouped-Query Attention)，采用的是一组Q(N个)共享同一个KV</p><p><code>QKV</code>第一个维度是<code>token_num</code>，因此网格的第一个维度x也是<code>token_num</code>，网格的第二个维度y是<code>head_num</code>(<code>q head num</code>)</p><p><code>qkv</code>类型是<code>BaseWeight&lt;T&gt;</code>，在<code>src/weights/base_weights.h</code>中</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;struct BaseWeight{std::vector&lt;int&gt; shape;T* data;WeightType type;T* bias; // qkv需要这一项}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①<code>GetRoPRfreq()</code>是用来求$θ$和$m$的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline __device__ float2 GetRoPEfreq(int zid, int rot_embed_dim, float base, float t_step) {      float inv_freq = t_step / powf(base, zid / (float)rot_embed_dim); // 求mθ      return{cos(inv_freq), sin(inv_freq)};  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>公式：$Θ={θ_i=10000^{-2(i-1)/d},i\in[1,2,…,d/2]}$<br>入参：</p><ul><li><code>zid</code>：<code>2(i-1)</code></li><li><code>rot_embed_dim</code>：<code>d</code>，词嵌入向量的维度</li><li><code>base</code>：公式中的10000</li><li><code>t_step</code>：time step，是要求的<code>m</code>，<code>m</code>表示第<code>m</code>个token<br>变量：</li><li><code>inv_freq</code>：就是$mθ_i$<ul><li>$mθ_i=m\ ÷\ 10000^{2(i-1)/d}$</li><li>$10000^{2(i-1)/d}$ = <code>powf(base,zid / (float)d)</code><ul><li><code>base=10000</code></li><li><code>zid=2(i-1)</code></li><li>因为传进来的<code>rot_embed_dim</code>是<code>int</code>型的，所以加了个<code>float</code></li></ul></li></ul></li><li>返回的是$cos(mθ_i)$和$sin(mθ_i)$</li></ul><p>②<code>GetRoPEres()</code>是用来得到RoPE后的结果的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline __device__ float2 GetRoPEres(float data, float data_rotate, const float2 coef){      float2 rot_v;    rot_v.x = coef.x * data - coef.y * data_rotate;    rot_v.y = coef.x * data_rotate + coef.y * data;    retern rot_v;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>入参：</p><ul><li><code>data</code>：<code>head_size</code>中的前半的数据</li><li><code>data_rotate</code>：<code>head_size</code>中后半的数据</li><li><code>coef</code>：通过<code>GetRoPRfreq()</code>得到的$cos(mθ_i)$和$sin(mθ_i)$<br>变量：</li><li>(举例)<code>rot_v.x</code>=$cos(mθ_0)\ <em>\ x_0\ -\ sin(mθ_0)\ </em>\ x_{64}$</li><li>(举例)<code>rot_v.y</code>=$cos(mθ_0)\ <em>\ x_{64}\ +\ sin(mθ_0)\ </em>\ x_0$</li><li>上面两个为一组<code>rot_v</code>，一组指的是他们共享$cos(mθ_0)$和$sin(mθ_0)$<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/d224a5131c3f2a304c66f0ccf912e90.jpg"></li></ul><p>③<code>add_fusedQKV_bias_transpose_kernel()</code><br>实际上并没有加上bias偏置项</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;  __global__ void add_fusedQKV_bias_transpose_kernel(T *q_buf,  T *k_buf,  T *v_buf,  T *QKV,  const int *padding_offset, // created before qkv linear  const int *history_length,  const int *input_length, // actual length of each seq  const int batch_size,  const int seq_len, // max_seq_len to pad to    const int head_num,  const int kv_head_num,  const int head_size,  const int rotary_embedding_dim,  float rotary_embedding_base // default 10000 in llama  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1)配置block、thread和padding</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int token_id = blockIdx.x;int head_id = blockIdx.y; int tid = threadIdx.x;int token_padding_offset = padding_offset[token_id];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>token_id</code>和<code>head_id</code>用于获得数据偏移量<br><code>token_padding_offset</code>是该<code>token</code>之前的padding个数</p><p>2)为写到显存里面做准备</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int dst_token_id = token_id + token_padding_offset;int batch_id = dst_token_id / seq_len;int local_token_id = dst_token_id % seq_len;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>dst_token_id</code>：可以理解为当前<code>token_id</code>在全部<code>token</code>中的位置<br>    <code>token_id</code>是当前token在不考虑padding时的token位置<br>    <code>token_padding_offset</code>是当前token之前的padding个数<br><code>batch_id</code>：当前token所在位置的对应的句子id<br><code>local_token_id</code>：当前token在当前句子的位置(0~seq_len-1)<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/8b1b3ff66b49b6249741cc3c0f00791.jpg" alt="|275"><br>为了写到显存里才做的padding</p><p>3)基于(作为输入)QKV buffer的三个维度(<code>num tokens, qkv head num, head size</code>)获取q、k、v</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int qkv_head_num = head_num + 2 * kv_head_num; int q_id = token_id * qkv_head_num * head_size + head_id * head_size + tid;  int k_id = token_id * qkv_head_num * head_size + head_id * head_size + tid + head_num * head_size;int v_id = token_id * qkv_head_num * head_size + head_id * head_size + tid + head_num * head_size + kv_head_num * head_size;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>qkv_head_num</code>：其中<code>head_num</code>是<code>q_head_num</code><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/8d4904053dda536ed4635322867c4fa.jpg" alt="|425"></p><p>4)计算RoPE</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int cur_seq_history_len = history_length[batch_id];const int context_length = cur_seq_history_len + input_length[batch_id]  const int timestep = cur_seq_history_len + local_token_id; if(tid &gt;= rotary_embedding_dim / 2){     return;  }  float2 cos_sin = GetRoPEfreq(tid * 2, rotary_embedding_dim, rotary_embedding_base, timestep);  float2 q_rotate = GetRoPEres(QKV[q_id], QKV[q_id + head_size / 2], cos_sin);  float2 k_rotate = GetRoPEres(QKV[k_id], QKV[k_id + head_size / 2], cos_sin);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的长度都以token为单位<br><code>cur_seq_history_len</code>：当前序列的历史的序列长度总和<br><code>context_length</code>：当前序列长度+历史的序列长度<br><code>timestep</code>：历史序列长度+当前seq中的token，得到当前token在整个序列中的位置</p><p>llama的旋转编码是将head size切分成两半，左一半与右一半对应做RoPE，所以当<code>tid &gt;= rotary_embedding_dim/2</code>时就可以停止做RoPE计算，<code>rotary_embedding_dim</code>是词嵌入向量的维度，这里指的应该是token的维度</p><p>在<code>q_rotate</code>和<code>k_rotate</code>的计算过程中也能证实<code>data</code>和<code>data_rotate</code>对应的是线程，所以在上面的if语句中只需要一半的线程即可</p><p>5)写回gmem</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int dst_q_id = batch_id * seq_len * head_num * head_size +                 head_id * seq_len * head_size +                 local_token_id * head_size + tid;  int dst_kv_id = batch_id * seq_len * kv_head_num * head_size +                 head_id * seq_len * head_size +                 local_token_id * head_size + tid;  q_buf[dst_q_id] = q_rotate.x;  q_buf[dst_q_id + head_size / 2] = q_rotate.y;  if(head_id &lt; kv_head_num){      // 对于MQA和GQA      k_buf[dst_kv_id] = k_rotate.x;      k_buf[dst_kv_id + head_size / 2] = k_rotate.y;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面给出了<code>dst_q_id</code>的例子<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/f602724b51ab74e9a401426a567845f.jpg" alt="|675"></p><p>④<code>rope_kernel_for_self_decoder()</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  __global__ void rope_kernel_for_self_decoder(T* q,                      T* k,                      const int batch_size,                      const int head_num,                      const int kv_head_num,                      const int head_size,                      const int step,                      int   rotary_embedding_dim,                      float rotary_embedding_base)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里主要针对self decoder</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int tid = threadIdx.x;  int q_head_id = blockIdx.x;  int q_batch_id = blockIdx.y;  int kv_head_id = q_head_id / (head_num / kv_head_num); // 将kv_head_id的数量膨胀到q_head_id的数量  int kv_batch_id = q_batch_id;    int batch_stride = head_num * head_size; // seq len=1  int kv_batch_stride = kv_head_num * head_size;int head_stride = head_size;  int q_offset = q_batch_id * batch_stride + q_head_id * head_stride + tid;  int k_offset = kv_batch_id * kv_batch_stride + kv_head_id * head_stride + tid;  if(tid &gt;= rotary_embedding_dim / 2){      return;  }  float2 cos_sin = GetRoPEfreq(tid * 2, rotary_embedding_dim, rotary_embedding_base, step - 1); // 这里通过与hf相比发现要-1float2 q_rotate = GetRoPEres(q[q_offset], q[q_offset + head_size / 2], cos_sin);  float2 k_rotate = GetRoPEres(k[k_offset], k[k_offset + head_size / 2], cos_sin);    q[q_offset] = q_rotate.x;  q[q_offset + head_size / 2] = q_rotate.y;  k[k_offset] = k_rotate.x;  k[k_offset + head_size / 2] = k_rotate.y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后<code>k[k_offset]</code>不需要判断<code>head_idx&lt;kv_head_num</code>是因为<code>int kv_head_id = q_head_id / (head_num / kv_head_num); </code>这里的对应关系不会令k head越出边界<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/7b5bd7706fad306560cabfdbc75cb21.jpg" alt="|475"></p><h2 id="8-2-其他"><a href="#8-2-其他" class="headerlink" title="8.2 其他"></a>8.2 其他</h2><p><code>using Vec_t = Vec&lt;t&gt;::type;</code>和<code>using Vec_t = typename Vec&lt;t&gt;::type;</code>的区别</p><ul><li>使用<code>typename</code>关键字用来明确告诉编译器<code>Vec&lt;t&gt;::type</code>是一个类型而不是一个(静态)成员</li><li>不使用<code>typename</code>的前提是编译器已经确定了<code>Vec&lt;t&gt;::type</code>是一个类型，不需要<code>typename</code>做提示<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 需要typename做提示template&lt;typename T&gt;struct Vec{using Type = T;}// 不需要typename做提示struct Vec{using Type = int;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><code>const_cast</code>主要用于移除(或添加)对象的<code>const</code>限定符，可以修改那些被声明为<code>const</code>的变量</p><h1 id="Lesson9-concat-past-kv-cache"><a href="#Lesson9-concat-past-kv-cache" class="headerlink" title="Lesson9 concat past kv cache"></a>Lesson9 concat past kv cache</h1><p>讲解了：<br><code>src/kernels/concat_past_kv.cu</code><br><code>src/kernels/concat_past_kv.h</code><br><code>tests/unittests/test_concat_kv.cu</code></p><p>llama中<code>max_q_len</code>(即<code>seq_len</code>)是8192，是关注对象；k和v写到<code>max_q_len</code>需要根据<code>history_len</code>找到相应的位置<br><code>kv cache shape = [num layers, bs, kv_head_num, max_seq_len, head_size]</code><br>↓其中，max_seq_len的位置是写到<br><code>[seqlen[history_len:history_len + max_q_len]]</code></p><p>这一节内容不多，但是折磨了我挺长时间的T.T<br>    主要是<code>max_q_len</code>、<code>max_seq_len</code>、<code>history_len</code>、<code>cur_query_len</code>这几个变量没弄明白(可能是视频默认我会吧哈哈)</p><ul><li><code>max_q_len</code>：做完旋转之后的k、v的对应的每个batch的长度，即token的个数</li><li><code>max_seq_len</code>：考虑上下文的每个batch的长度，即token的长度，什么叫考虑上下文呢，就是入参的时候会输入<code>history_len</code>的就是上文长度，<code>max_seq_len</code>作为该batch的最长的长度</li><li><code>history_len</code>：这个batch中的上文长度，即token的长度</li><li><code>cur_query_len</code>：需要进行查询的长度(新生成的token的长度)<br><code>history_len + cur_query_len &lt;= max_seq_len</code></li></ul><p>难点就是写入的位置的偏移<code>dst_offset</code>，实际上这一节也是要解决的问题就是kv cache的写入位置，结合代码看下图就好了<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/11adf571dc54da75266cc135ab66c1f.jpg"><br>👆当layer=1的情况<br>👇这里只放key的，value的和他差不多</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;  __global__ void append_key_cache(T *k_dst, // [num layers, bs, kv head num, max_q_len, head size]                                   const size_t layer_offset,                                   const T *k_src, // [bs, kv_head num, max_q_len, head size]                                   const int kv_head_num,                                   const int head_size,                                   const int *cur_query_length,                                   const int *history_length,// [batch_size]                                   const int max_q_len,                                   const int max_seq_len){      // 根据这里的dim3 grid(max_q_len, batch_size, kv_head_num);来写下面的三行      int batch_id = blockIdx.y;      int head_id = blockIdx.z;      int token_id = blockIdx.x;      int tid = threadIdx.x;      T* k_cache_dst = k_dst + layer_offset; // 将k写到当前的layer位置，算是一个定位；k_dst是所有k的起始位置      int cumsum_seq_len = history_length[batch_id]; // 当前batch在当前layer中累积的句子长度      int cur_seq_len = cur_query_length[batch_id];      if(token_id &lt; cur_seq_len){          // [bs, kv_head_num, max_q_len, head size] =&gt; [bs, kv_head_num, max_seq_len[cumsum_seq_len:cumsum_seq_len + max_q_len], head_size]          // 在k_src上的偏移          int src_offset = batch_id * kv_head_num * max_q_len * head_size        + head_id * max_q_len * head_size                         + token_id * head_size + tid;          // 需要写入的位置的偏移          int dst_offset = batch_id * kv_head_num * max_seq_len*head_size        + head_id * max_seq_len * head_size        + (cumsum_seq_len + token_id) * head_size + tid;          k_cache_dst[dst_offset] = k_src[src_offset]; // k_src是当前layer的，dst_offset需要加上      }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Lesson10-RepeatKV-for-MQA-GQA-kernel"><a href="#Lesson10-RepeatKV-for-MQA-GQA-kernel" class="headerlink" title="Lesson10 RepeatKV for MQA&amp;GQA kernel"></a>Lesson10 RepeatKV for MQA&amp;GQA kernel</h1><p>讲解了：<br><code>src/kernels/repeat_kv.cu</code><br><code>src/kernels/repeat_kv.h</code><br><code>test/unittests/test_repeat_kv.cu</code></p><p>写这个kernel的动机：将MHA转换为MQA，目的是平衡推理速度和MHA所能达到的精度；因为k和v的数量与头数量成正比，所以要减小头的数量和size以减小带宽压力，同时因为后面要做QKgemm，因此要矩阵对齐</p><p>尺寸变化：<br><code>[batch size, kv head num, max seq len, head size]=&gt;</code><br><code>[batch size, q head num, max k len, head size]</code></p><p><code>q_head_per_kv = head_num / kv_head_num</code>，即每一组k head或v head对应多少组q head共用</p><p><code>dim3 grid((max_k_len * head_size + blockSize - 1) / blockSize, batch_size, head_num);</code><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/6a7c0ad2ea6497df0a680878fb4c32d.jpg"></p><p><code>src/kernels/repeat_kv.cu</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;  __global__ void repeat_value_cache(T *v_dst,                                     const T *v_src,                                     const size_t layer_offset,                                     const int head_num,                                     const int q_head_per_kv,                                     const int head_size,                                     const int *context_length,                                     const int max_k_len,                                     const int max_seq_len){      const int batch_id = blockIdx.y;      const int head_id = blockIdx.z;      const int gtid = blockIdx.x * blockDim.x + threadId.x;      const auto val_src = v_src + layer_offset;      const T* val_dst = v_dst;      const int seq_len = context_length[batch_id];      const int v_head_size_id = gtid % head_size;     const int v_seq_len_id = gtid / head_size;      if(v_seq_len_id &lt; seq_len){          const int src_id = batch_id * (head_num / q_head_per_kv）*       head_size * max_seq_len +                             head_id / q_head_per_kv * head_size *                            max_seq_len +                             v_seq_len_id * head_size +                             v_head_size_id;            const int dst_id = batch_id * head_num * head_size * max_k_len +                            head_id * head_size * max_seq_len +                             v_seq_len_id * head_size +                             v_head_size_id;          val_dst[dst_id] = val_src[src_id];      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/ef1ab04ddb1556e1cd39bef5cf2ac47.jpg"><br>实际上就是按照<code>q head</code>的大小重新排布了<code>k head</code>或<code>v head</code>，使他们一一对应。(图中绿色部分为对应关系，每<code>q_head_num/kv_head_num</code>组<code>q hea</code>d共用一组<code>k head</code>或<code>v head</code>)</p><p>总觉得这里的<code>max_k_len</code>有点误导人…应该不是<code>kv head num * max seq len = q head num * max k len</code>，只是单纯的扩展了</p><h1 id="Lesson11-Fused-mask-softmax"><a href="#Lesson11-Fused-mask-softmax" class="headerlink" title="Lesson11  Fused mask&amp;softmax"></a>Lesson11  Fused mask&amp;softmax</h1><p>讲解了：<br><code>src/kernels/attn_softmax_kernel.cu</code><br><code>src/kernels/attn_softmax_kernel.h</code></p><p><code>SumOp</code>和<code>MaxOp</code>的定义</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;  struct SumOp  {      __device__ __forceinline__ T operator()(const T &amp;a, const T &amp;b) const { return a + b; }  };    template &lt;typename T&gt;  struct MaxOp  {      __device__ __forceinline__ T operator()(const T &amp;a, const T &amp;b) const { return max(a, b); }  };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>👆这样写的目的是模板化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;template &lt;typename&gt; class ReductionOp, typename T&gt;  __inline__ __device__ T warpReduce(T val)  {      for (int mask = 32 / 2; mask &gt; 0; mask /= 2)      {            val = ReductionOp&lt;T&gt;()(val, __shfl_xor_sync(0xffffffff, val, mask));      }        return val;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>👆使用模板模板参数<code>ReductionOp</code>，在调用<code>warpReduce</code>时传入不同的操作类型<code>SumOp</code>和<code>MaxOp</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LLM-CHECK_WITH_INFO(k_length % 2 == 0, "K_len should be divided by 2 under half type!");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>fp32类型下以float4力度读写（还未实现），fp16类型下以half2读写，这里是只对fp16做向量化使其<code>vec_size=2</code>，而fp32向量化后<code>vec_size=1</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define LAUNCH_SOFTMAX(dtype, vec_size)                                \     if (block.x &gt; 2048 &amp;&amp; block.x &lt;= 4096)                             \     {                                                                  \         constexpr int NUMS_PER_THREAD_PER_ROW = 4;                     \         block.x /= 4 * vec_size;                                       \         block.x = (block.x + 32 - 1) / 32 * 32;                        \         assert(block.x &lt; 1024);                                        \         ScaleMaskAndSoftmax_##dtype&lt;dtype, NUMS_PER_THREAD_PER_ROW&gt;    \&lt;&lt;&lt;grid, block&gt;&gt;&gt;((dtype *)attn_score-&gt;data, \                                             (dtype *)qk-&gt;data,         \                (dtype *)mask-&gt;data,       \                                             batch_size,                \                                             head_nums,                 \                                             q_length,                  \                                             k_length,                  \                             scale);                    \      }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>NUMS_PER_THREAD_PER_ROW</code>作为编译器常量</li><li>如果当前输入的shape比较大，每个线程只访问4个vec，即<code>.x</code>、<code>.y</code>、<code>.z</code>、<code>.w</code>这种，所以<code>block.x</code>被分为<code>4*vec_size</code>份<ul><li>其中，<code>vec_size</code>对于<code>half</code>来说取2，对于<code>float</code>来说取1</li></ul></li><li>同时block个数仍需对齐32，向上取整</li><li>整体看来就是用较少的线程处理数据，如果输入shape太大就采用输入向量化（目前只实现了fp16）并且减少线程使用</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T, int NUMS_PER_THREAD_PER_ROW&gt;  __global__ void ScaleMaskAndSoftmax_float(T *attn_score,                                            T *qk,                                            T *mask,                                            int batch_size,                                            int head_nums,                                            int q_len,                                            int k_len,                                            float scale){      int batch_id = blockIdx.y;    int head_id = blockIdx.z;     if(threadIdx.x &gt;= k_len){          return;      }        __shared__ float s_max, inv_sum;      for(int row_start = 0; row_start &lt; q_len; row_start++){          int qk_offset = 0;          T qk_data = static_cast&lt;T&gt;(0);          T mask_data = static_cast&lt;T&gt;(0);          T data[NUMS_PER_THREAD_PER_ROW];          T thread_max = FIL_MIN;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在launch中<ul><li>grid=<code>[q_length, batch_size, head_nums]</code></li><li>block=<code>[k_length(以32的倍数向上取整)]</code></li></ul></li><li>开始处理所有行</li></ul><p>以下全都在上一层的<code>for</code>的内部，为便于看代码因此忽略部分缩进</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int col_start = 0; col_start &lt; NUMS_PER_THREAD_PER_ROW; col_start++){ // 每个线程只需要处理NUMS_PER_THREAD_PER_ROW个数据  qk_offset = batch_id * head_nums * q_len * k_len +     head_id * q_len * k_len + row_start * k_len +     col_start * blockDim.x + threadIdx.x;  qk_data = qk[qk_offset];  mask_offset = batch_id * q_len * k_len + head_id * q_len * k_len   + row_start * k_len + col_start * blockDim.x   + threadIdx.x;      mask_data = mask[mask_offset];        data[col_start] = scale * qk_data + (1 - mask_data) * -1e4f;      thread_max = fmax(data[col_start], thread_max); // 一个线程对多个元素做处理之后，多个元素的最大值  }  T max_val = blockReduce&lt;MaxOp, T&gt;(thread_max); // 一行的最大值  // block的最大值存在id为0的线程中  if(threadIdx.x == 0){      s_max = max_val;  }        __syncthreads();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>列被分为<code>NUMS_PER_THREAD_PER_ROW</code>个数据由同一个线程处理</li><li>每遍历一次<code>col_start</code>就会有相应的线程并行，之后再用<code>blockReduce</code>进行最后的规约</li><li><code>mask_data</code>和<code>qk_data</code>不同的地方是没有<code>head_nums</code>，其他都一致<ul><li>如果<code>mask_data=1</code>，说明不需要被mask，反之需要被mask(加上$-10^4$，这使得在softmax时得到的值非常的小)<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/8616eaf5c62443e35305f7cfd27a345.jpg"><br>考虑到数值范围的溢出问题，一般会在指数部分减去<code>D=max(zi)</code><br>softmax的公式为：$D=max(z_i),softmax(z_i)=\dfrac{e^{z_i-D}}{\sum^C_{c=1}e^{z_c-D}}$<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">T thread_sum = 0.0f;  for(int col_start = 0; col_start &lt; NUMS_PER_THREAD_PER_ROW; col_start++){      data[col_start] = expf(data[col_start] - s_max);      thread_sum += data[col_start];  }        T sum_val = blockReduce&lt;SumOp, T&gt;(thread_sum);  if(threadIdx.x == 0){      inv_sum = 1 / (sum_val + 1e-6);  }       __syncthreads();  for(int col_start = 0; col_start &lt; NUMS_PER_THREAD_PER_ROWl;col_start++) {  qk_offset = batch_id * head_nums * q_len * k_len + head_id * q_len * k_len + row_start * k_len + col_start * blockDim.x + threadIdx.x;  attn_score[qk_offset] = (data[col_start] * inv_sum);  }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p>对于fp16，不同的地方在于向量化处理</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//scalar_cast_vec: 将常量转换为2个或4个向量  Vec_t ONE = scalar_cast_vec&lt;Vec_t&gt;(__float2half(1.0f));  Vec_t NEG_INF = scalar_cast_vec&lt;Vec_t&gt;(__float2half(-10000.0f));  Vec_t scale_vec = scalar_cast_vec&lt;Vec_t&gt;(__float2half(scale));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>根据<code>src/utils/vectorze_utils.h</code>：half-&gt;half2 ，float-&gt;float4</p><p>在<code>src/utils/vectorize_utils.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T_OUT, typename T_IN&gt;  inline __decvice__ T_OUT scalar_cast_vec(T_IN val){      return val;  }  // half转为half2  template&lt;&gt;  inline __device__ half2 scaler_cast_vec&lt;half2, half&gt;(half val){      return __half2half2(val);  }  // float转为float2  template&lt;&gt;  inline __device__ float2 scaler_cast_vec&lt;float2, float&gt;(float val){  return __make_float2(val, val);  }  // float转为float4  template&lt;&gt;  inline __device__ float4 scaler_cast_vec&lt;float4, float&gt;(float val){      return __make_float4(val, val, val, val);  }  // float转为half2  template&lt;&gt;  inline __device__ float2 scaler_cast_vec&lt;half2, float&gt;(float val){      return __float2half2_rn(val);  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一部分直接用库中half2函数进行计算处理</p><h1 id="Lesson12-Fused-transpose-remove-padding"><a href="#Lesson12-Fused-transpose-remove-padding" class="headerlink" title="Lesson12 Fused transpose&amp;remove padding"></a>Lesson12 Fused transpose&amp;remove padding</h1><p>讲解了：<br><code>src/kernels/fused_transpose_and_remv_pad.cu</code><br><code>src/kernels/fused_transpose_and_remv_pad.h</code></p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/1ebaf4bf0c8c8e05cdc563c83f71a77.jpg"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;  __global__ void fused_transpose_reshape_remv_pad(T *src,                                                   T *dst,                                                   const int num_tokens,                                                   const int batch_size,                                                   const int seq_len,                                                   const int head_num,                                                   const int head_size,                                                   const int *padding_offset /*for remove padding*/)  {      int token_id = blockIdx.x; // 这里的token_id是指padding之前的每个token的id      int batch_id = token_id + padding_offset[token_id] / seq_len; // 这里的batch_id是指padding之后每个token对应的batch的id      int seq_id = token_id + padding_offset[token_id] % seq_len;   // 每个token在句子中的编号，范围是0~seq_len-1      // transpose前后的offset      int src_offset = batch_id * head_num * seq_len * head_size + seq_id * head_size; // transpose前的偏移位置，具体到head_size的偏移，这里把head_id * seq_len * head_size去掉了，会在for循环补上      int dst_offset = token_id * head_num * head_size; // 这里的偏移只具体到token        for(int i = threadIdx.x; i &lt; head_num * head_size; i+=blockDim.x){ // 因为每个block处理一个token，所以i+=blockDim.x          int head_id = i / head_size;          int head_size_id = i % head_size;          dst[dst_offset + i] = src[src_offset + i * seq_len * head_size + head_size_id];      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码比较容易理解，不懂的看注释即可</p><h1 id="Lesson13-Fused-addResidualNorm"><a href="#Lesson13-Fused-addResidualNorm" class="headerlink" title="Lesson13 Fused addResidualNorm"></a>Lesson13 Fused addResidualNorm</h1><p>讲解了：<br><code>src/fused_addresidual_norm.cu</code><br><code>src/fused_addresidual_norm.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  __global__ void FusedAddBiasResidualRMSNorm( // residual.shape = [num tokens, hidden_units]                      T* residual,    // [num tokens, hidden_units]                      T* decoder_in,  // [num tokens, hidden_units]                      /*optional*/const T* bias,  // [hidden_units]                      const T* scale, // [hidden_units], RMSNorm weights                      float eps,      // RMSNorm eps                      int num_tokens,                       int hidden_units){  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>rmsnorm(decoder_in + residual + bias)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// grid:[num_tokens] block:[num_threads]    int vec_size = Vec&lt;T&gt;::size;      using Vec_t = typename Vec&lt;T&gt;::Type;      int batch_id = blockIdx.x; // 一个block表示一个batch      int tid = threadIdx.x;      Vec_t *de_out = reinterpret_cast&lt;Vec_t*&gt;(decoder_in + batch_id * hidden_units);     Vec_t *rsd = reinterpret_cast&lt;Vec_t*&gt;(residual + batch_id * hidden_units);      Vec_t *bia;      if(bias != nullptr){          bia = reinterpret_cast&lt;Vec_t*&gt;(bias);      }    Vec_t tmp;      T thread_sum = static_cast&lt;T&gt;(0.0f);      for (int i = threadIdx.x; i &lt; hidden_units / vec_size; i += blockDim.x) {          if(residual != nullptr){              // 下面对应HF中的hidden_states = residual + hidden_states              de_out[i].x += rsd[i].x;              de_out[i].y += rsd[i].y;              de_out[i].z += rsd[i].z;              de_out[i].w += rsd[i].w;              // 下面对应residul = hidden_states                        rsd[i].x = de_out[i].x;              rsd[i].y = de_out[i].y;              rsd[i].z = de_out[i].z;              rsd[i].w = de_out[i].w;          }                if(bias != nullptr){              de_out[i].x += bia[i].x;              de_out[i].y += bia[i].y;              de_out[i].z += bia[i].z;              de_out[i].w += bia[i].w;          }          thread_sum += de_out[i].x * de_out[i].x;          thread_sum += de_out[i].y * de_out[i].y;          thread_sum += de_out[i].z * de_out[i].z;          thread_sum += de_out[i].w * de_out[i].w;      }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Vec_t *de_out = reinterpret_cast&lt;Vec_t*&gt;(decoder_in + batch_id * hidden_units)</code>：每个block表示一个token，每个token的大小为hidden_units，这里表示了当前token的偏移量 </li><li>在HF中的顺序<br><code>hidden_states = residual + hidden_states</code>对应<code>de_out[i].x += rsd[i].x;</code><br><code>residul = hidden_states</code>对应<code>rsd[i].x = de_out[i].x;</code><br><code>hidden_states = self.post_attention_layernorm(hidden_states)</code>对应<code>de_out[idx].x = de_out[idx].x * inv_mean * s[idx].x;</code></li><li>根据公式$\dfrac{x_i×g_i}{\sqrt{\sum^iE(x_i^2)+eps}}$<ul><li>$x_i$对应加了<code>residual</code>的<code>de_out[i]</code></li><li>$g_i$对应<code>s[idx]</code></li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">    // 求分母，以1/xxx表示    T block_sum = blockReduceSum&lt;float&gt;(thread_sum);      __shared__ float inv_mean;      if (threadIdx.x == 0) {          inv_mean = rsqrtf(block_sum / hidden_units + eps);      }    __syncthreads();       // rmsnorm      Vec_t *s;      if(scale != nullptr) {          s = reinterpret_cast&lt;Vec_t *&gt;(scale);      }        for (int idx = threadIdx.x; idx &lt; hidden_units / vec_size; idx += blockDim.x) {          de_out[idx].x = de_out[idx].x * inv_mean * s[idx].x;         de_out[idx].y = de_out[idx].y * inv_mean * s[idx].y;         de_out[idx].z = de_out[idx].z * inv_mean * s[idx].z;          de_out[idx].w = de_out[idx].w * inv_mean * s[idx].w;      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Lesson-14-Gate-Linear-Up-Linear"><a href="#Lesson-14-Gate-Linear-Up-Linear" class="headerlink" title="Lesson 14 Gate Linear&amp;Up Linear"></a>Lesson 14 Gate Linear&amp;Up Linear</h1><p>讲解了：<br><code>src/kernels/linear</code></p><p>输入：<br>    为context decoder时，<code>[batch_size, q hidden units]</code>；<br>    为self decoder时，<code>[token nums, q hidden units]</code><br>Gate&amp;Up权重：<code>[q hidden units, 2 * inter size]</code><br>输出：<code>[batch_size(或token nums), 2 * inter size] = [bs/tn, 2, inter size]</code>，实际上输出是三维</p><h1 id="Lesson-15-SwiGLU"><a href="#Lesson-15-SwiGLU" class="headerlink" title="Lesson 15 SwiGLU"></a>Lesson 15 SwiGLU</h1><p>讲解了：<br><code>src/kernels/act_kernel.h</code><br><code>src/kernels/act_kernel.cu</code></p><p><code>SiLU(Sigmoid Linear Unit)</code>，相对于ReLU，SiLU在函数接近0时具有更平滑的曲线<br>$y=x*sigmoid(\beta x)=\dfrac{1}{1+e^{-\beta x}}$，当$\beta=1$时就是SiLU<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/Pasted%20image%2020241105112111.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;__device__ __forceinline__ T silu(const T&amp; in){return in / (1.0f * expf(-in));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>grid:[batch_size=input-&gt;shape[0]]</code><br><code>block:[256]</code></p><p><code>Gate Linear</code>和<code>Up Linear</code>的输出(对于context decoder而言)<code>[bs, 2, inter size]</code>可以视为两个大小为<code>[bs, inter size]</code>的部分，第一部分做<code>SiLU</code>，得到的结果与第二部分做<code>mul</code>最终得到最后的结果</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  __global__ void silu_and_mul_kernel(T* out, // shape: [bs, intermedia size]  const T* input,  // shape: [bs, 2, intermedia size]                  const int intermedia_size) {      const int batch_idx = blockIdx.x;      for(int idx = threadIdx.x; idx &lt; intermedia_size; idx +=blockDim.x){         const T x = input[batch_idx * 2 * intermedia_size + idx];// 第一个         const T y = input[batch_idx * 2 * intermedia_size + intermedia_size + idx]; // 第二个          out[batch_idx * intermedia_size + idx] = silu&lt;T&gt;(x) * y;      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Lesson16-Fused-SelfDecoderAttention-kernel"><a href="#Lesson16-Fused-SelfDecoderAttention-kernel" class="headerlink" title="Lesson16 Fused SelfDecoderAttention kernel"></a>Lesson16 Fused SelfDecoderAttention kernel</h1><p>讲解了：<br><code>src/fused_decoder_self_attention.cu</code></p><p>融合部分：<code>concat kv</code>+<code>repeat kv</code>+<code>qk gemv</code>+<code>softmax</code>+<code>qk*v gemv</code></p><ul><li>如何fuse：数据在寄存器(如<code>q</code>、<code>k</code>和<code>v</code>)和显存(如<code>q_buf</code>、<code>k_buf</code>和<code>v_buf</code>)都出现，因此需要复用在寄存器和共享内存中的数据，因为访问显存会耗时，并且带宽很低</li><li>使用动态共享内存</li><li><code>Q*k Gemv</code>：<ul><li><code>q.shape=[batch size, head num, 1, head size]</code><ul><li>这里的<code>1</code>表示每次针对一个特定位置(当前token)计算attention</li></ul></li><li><code>k.shape=[batch size, head num, step, head size]</code>，<ul><li>这里不是<code>kv head num</code>，是因为在<code>repeat kv</code>这一步中已经把q和k的头对齐了</li><li>这里的<code>step</code>表示每个句子包含<code>step</code>个<code>token</code>，每个<code>token</code>的key都与当前查询向量<code>q</code>做点积</li></ul></li></ul></li></ul><p>重温：</p><ul><li>qkv矩阵的shape<ul><li>q<code>[batch size, q head num, 1, head size]</code></li><li>k<code>[batch size, kv head num, step(/seqlen), head size]</code></li><li>v<code>[batch size, kv head num, step(/seqlen), head size]</code></li></ul></li></ul><p><code>launchDecoderMaskedMHA()</code></p><ul><li><code>qkv_buf</code>：<code>[batch size, qkv head num, head size]</code>，默认<code>head_num</code>是q的head，qkv、kv的head会加上相应的前缀</li><li>用<code>getVal</code>的前提是数据必须在CPU上(<code>LLM_CHECK(location == CPU)</code>)</li><li>grid：<code>[head_num, batch_size]</code></li><li>block：<code>[head_size]</code></li></ul><p>入参：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  void launchDecoderMaskedMHA(TensorWrapper&lt;T&gt;* qkv_buf,                            BaseWeight&lt;T&gt;&amp; qkv,                             TensorWrapper&lt;int&gt;* layer_id,                              TensorWrapper&lt;T&gt;* k_cache,                              TensorWrapper&lt;T&gt;* v_cache,                              TensorWrapper&lt;bool&gt;* finished,                             TensorWrapper&lt;int&gt;* step,                             TensorWrapper&lt;T&gt;* mha_output,                              LLaMAAttentionStaticParams&amp; static_params){ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>qkv_buf=qkv_linear=[bs, q_hidden_units] * [qhiddenunits, hiddenunits] = [bs, qkv_head_num, head_size]</code><ul><li><code>qhiddenunits</code>：将输入的嵌入向量(embedding vector)的向量长度，</li><li><code>hiddenunits</code>：<code>=[qkv_head_num,qiddenunist]=[qkv_head_num,head_size]</code><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/22bbf7d7781de208731d147b46c3b5e%201.jpg" alt="|550"></li></ul></li><li>kv的cache<ul><li>k_cache<code>[num layers, bs, kv head num, max seq len or step, head size]</code></li><li>v_cache<code>[num layers, bs, kv head num, max seq len or step, head size]</code><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">    const int qkv_head_num = qkv_buf-&gt;shape[1];      const int kv_head_num = k_cache-&gt;shape[2];      const int max_seq_len = k_cache-&gt;shape[3];   int head_num = qkv_head_num - 2 * kv_head_num;      const int head_size = qkv_buf-&gt;shape[2];      const int cur_step = step-&gt;getVal();    const int layer = layer_id-&gt;getVal();      const int layer_offset = layer * max_seq_len * batch_size * kv_head_num * head_size;      size_t smem_size_bytes = head_size * sizeof(T) + cur_step * sizeof(float);      T* qkv_data = qkv_buf-&gt;data;      T* q = qkv_data;    T* k = qkv_data + head_num * head_size;      T* v = qkv_data + (head_num + kv_head_num) * head_size;        int   rotary_embedding_dim = static_params.rotary_embedding_dim;      float rotary_embedding_base = static_params.rotary_embedding_base;      int   max_position_embeddings = static_params.max_position_embeddings;      bool  use_dynamic_ntk = static_params.use_dynamic_ntk;      dim3 grid(head_num, batch_size);      dim3 block(head_size); //vec size = 4 for fp32      masked_MHA_kernel&lt;T&gt;&lt;&lt;&lt;grid, block, smem_size_bytes&gt;&gt;&gt;(  q,  k,  v,  // /*(T*)*/qkv.bias,  k_cache-&gt;data + layer_offset,  v_cache-&gt;data + layer_offset,  mha_output-&gt;data,  batch_size,  head_num,  kv_head_num,  max_seq_len,  head_size,  cur_step,  rotary_embedding_dim,  rotary_embedding_base);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><code>q、k、v</code>：<code>qkv_buf=[bs, qkv_head_num, head_size]</code>，<code>q、k、v</code>分别加上相应偏移量</li><li><code>k_cache、v_cache</code>：定位到某一个<code>layer</code>上，不考虑<code>layer</code>时的<code>shape</code>为<code>[bs, kv head num, max seq len or step, head size]</code></li><li><code>mha_output-&gt;data</code>：作为输出地址</li><li><code>cur_step</code>：当前时间步，当前生成到第几个token</li><li><code>rotary_embedding_dim、rotary_embedding_base</code>：RoPE用</li></ul><p><code>masked_MHA_kernel()</code><br>入参：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">template<span class="token operator">&lt;</span>typename T<span class="token operator">&gt;</span>  __global__ <span class="token keyword">void</span> <span class="token function">masked_MHA_kernel</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> q<span class="token punctuation">,</span>                      <span class="token keyword">const</span> T<span class="token operator">*</span> k<span class="token punctuation">,</span>                      <span class="token keyword">const</span> T<span class="token operator">*</span> v<span class="token punctuation">,</span>                      T<span class="token operator">*</span> qkv_bias<span class="token punctuation">,</span>                      T<span class="token operator">*</span> k_cache<span class="token punctuation">,</span>                      T<span class="token operator">*</span> v_cache<span class="token punctuation">,</span>                      T<span class="token operator">*</span> mha_output<span class="token punctuation">,</span>                      <span class="token keyword">const</span> <span class="token keyword">int</span> batch_size<span class="token punctuation">,</span>                      <span class="token keyword">const</span> <span class="token keyword">int</span> head_num<span class="token punctuation">,</span>                      <span class="token keyword">const</span> <span class="token keyword">int</span> kv_head_num<span class="token punctuation">,</span>                      <span class="token keyword">const</span> <span class="token keyword">int</span> max_seq_len<span class="token punctuation">,</span>                      <span class="token keyword">const</span> <span class="token keyword">int</span> head_size<span class="token punctuation">,</span>                      <span class="token keyword">const</span> <span class="token keyword">int</span> step<span class="token punctuation">,</span>                      <span class="token keyword">int</span>   rotary_embedding_dim<span class="token punctuation">,</span>                      <span class="token keyword">float</span> rotary_embedding_base<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// rsqrt(dh)  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>k_offset</code>和<code>cache_offset</code>区别：<ul><li><code>k_offset</code>是qkv linear提供给k的，(因为是self_attention所以)一个batch只有一个token</li><li><code>cache_offset</code>是kv cache提供给k的，有<code>max seq len</code>，一个batch最多有max seq len个token(有这么多是因为新生成的token的k、v也加上去了)</li></ul></li><li>以<code>tid * vec_size &lt; head_size</code>作为是否超出边界的判断<ul><li><code>head_size</code>一般是4、8、16的倍数，所以当<code>vec_size</code>为2或4时也能正常判断</li><li>(抛开倍数问题会觉得不能正常判断的原因是：<code>head_size=7</code>，当<code>tid(=1)*vec_size(=4)</code>时，<code>4&lt;7</code>此时判断未超出边界，但是一共有<code>2×4=8</code>已经超出边界了)</li></ul></li><li>输出：`mha_output.shape=[batch_size, q_head_num, 1, head_size]</li></ul><p>①ConcatPastKVCache<br><code>input=[bs, kv head num, seqlen, head size]</code><br><code>output=[bs, kv head num, max_seq_len, head size]</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int tid = threadIdx.x;     int q_head_id = blockIdx.x;     int q_batch_id = blockIdx.y;     int kv_head_id = q_head_id / (head_num / kv_head_num);     int kv_batch_id = q_batch_id;        int batch_stride = head_num * head_size;     int kv_batch_stride = kv_head_num * head_size;     int head_stride = head_size;      int q_offset = q_batch_id * batch_size + q_head_id * head_stride + tid;     // k_offset是qkv linear提供给k的     int k_offset = kv_batch_id * kv_batch_stride + kv_head_id * head_stride + tid;   // cache_offset是kv cache提供给k的     int cache_offset = kv_batch_id*kv_head_num*max_seq_len*head_size  + kv_head_id * max_seq_len * head_size  + tid * vec_size;//没有seq len的维度是因为seq len始终为1     int step_stride = head_size;      float scale = rsqrt((float)head_size);      int vec_size = Vec&lt;T&gt;::size;     int q_offset_vec = q_batch_id * batch_size + q_head_id * head_stride + tid * vec_size;     int k_offset_vec = kv_batch_id * kv_batch_stride + kv_head_id * head_stride + tid * vec_size;     using Vec_t = typename Vec&lt;T&gt;::Type; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②声明动态共享内存变量</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const T* q_mem = q;  const T* k_mem = k;  const T* v_mem = v;  if(tid * vec_size &lt; head_size){      qvec = *reinterpret_cast&lt;Vec_t*&gt;(const_cast&lt;T*&gt;(&amp;q_mem[q_offset_vec]));      kvec = *reinterpret_cast&lt;Vec_t*&gt;(const_cast&lt;T*&gt;(&amp;k_mem[k_offset_vec]));      vvec = *reinterpret_cast&lt;Vec_t*&gt;(const_cast&lt;T*&gt;(&amp;v_mem[v_offset_vec]));  }  extern __shared__ char sqk[]; // 声明动态共享内存变量  // shared memory的分配  // 存到shared memory中的数据的特点是低延迟、高复用  // 在这里对q用shared memory进行存储是因为之后有个优化，使用一个block取多行k进行qk gemm，此时q的复用频率变高，不需要重复加载q  T* sq_scalar = reinterpret_cast&lt;T*&gt;(sqk);  float* logits = reinterpret_cast&lt;float*&gt;(sq_scalar + head_size);  Vec_t *sq = reinterpret_cast&lt;Vec_t*&gt;(sq_scalar);    if(tid * vec_size &lt; head_size){      sq[tid] = qvec;  }    __syncthreads();  float zero = 0.0f;  Vec_t zero_f4 = scalar_cast_vec&lt;Vec_t, T&gt;(zero); // 将float转为float4  float4 scale_f4 = scalar_cast_vec&lt;float4, float&gt;(scale);    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// q*k gemv  for(int iter = 0; iter &lt; step; iter++){ //一个block循环计算step行      Vec_t kvec_qk = tid * vec_size &lt; head_size ? *reinterpret_cast&lt;Vec_t*&gt;(&amp;k_cache[iter * step_stride + cache_offset]) : zero_f4; // 这里乘iter相当于乘max seq len。我的理解是cache_offset是对于token而言的，iter*cache_offset的偏移使定位到当前step(当前token)        if(iter == step - 1 &amp;&amp; tid * vec_size &lt; head_size){ // step的最后一个位置存储RoPE输出的k          *reinterpret_cast&lt;Vec_t*&gt;(&amp;k_cache[iter * step_stride + cache_offset]) = kvec;          kvec_qk = kvec; // 这里的kvec_qk是用来做计算的，下面的vvec_qkc同理      }        Vec_t qk = zero_f4;      qk.x = tid * vec_size &lt; head_size ? sq[tid].x * kvec_qk.x * scale_f4.x : zero;      qk.y = tid * vec_size &lt; head_size ? sq[tid].y * kvec_qk.y * scale_f4.y : zero;      qk.z = tid * vec_size &lt; head_size ? sq[tid].z * kvec_qk.z * scale_f4.z : zero;      qk.w = tid * vec_size &lt; head_size ? sq[tid].w * kvec_qk.w * scale_f4.w : zero;        T qk_acc = qk.x + qk.y + qk.z + qk.w; // 一个线程有4个值，先在线程局部把这四个值加起来，再用blockReduceSum      T attn_score = blockReduceSum&lt;T&gt;(qk_acc);      if(tid == 0){          logits[iter] = attn_score; // logits是step×1大小的数组      }      __syncthreads();  }  // softmax    T local_logits = tid &lt; step ? (T)logits[tid] : 0;  __shared__ float row_max, fenmu;  T block_max = blockReduceMax&lt;T&gt;(local_logits);  if(tid == 0){      row_max = block_max;  }    __syncthreads();  T fenzi = tid &lt; step ? expf(logits[tid] - row_max) : 0; // e(x_i - x-max) / sigma(e(x_i, x_max));  T block_fenmu = blockReduceSum&lt;T&gt;(fenzi);  if(tid == 0){      fenmu = block_fenmu + 1e-6;  }    __syncthreads();  if(tid &lt; step){      logits[tid] = (T)(fenzi / fenmu);  }    __syncthreads();    // 隐式的repeat kv，都是向量化类型  if(tid * vec_size &lt; head_size){      Vec_t O = scalar_cast_vec&lt;Vec_t, T&gt;(0.0f); // 中间寄存器      for(int iter = 0; iter &lt; step; iter++){          Vec_t vvec_qkv = *reinterpret_cast&lt;Vec_t*&gt;(&amp;v_cache[iter * step_stride + cache_offset]);            if(iter == step - 1){ // step的最后一个位置存储RoPE输出的k              *reinterpret_cast&lt;Vec_t*&gt;(&amp;v_cache[iter * step_stride + cache_offset]) = vvec;              vvec_qkv = vvec;          }            __syncthreads();          O.x += vvec_qkv.x * logits[iter]; // v的一整行×qk的一个          O.y += vvec_qkv.y * logits[iter]; // v的一整行×qk的一个          O.z += vvec_qkv.z * logits[iter]; // v的一整行×qk的一个          O.w += vvec_qkv.w * logits[iter]; // v的一整行×qk的一个      }      *reinterpret_cast&lt;Vec_t*&gt;(&amp;mha_output[q_offset]) = O; // [batch size, q head num, 1, head size]  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Lesson17-topK"><a href="#Lesson17-topK" class="headerlink" title="Lesson17 topK"></a>Lesson17 topK</h1><p>讲解了：<br><code>src/kernels/topK.cu</code><br><code>src/kernels/topK.h</code></p><p>输入：<code>[bs, beam_width, vocab size]</code><br>输出：<code>[bs, beam_width, K]</code></p><p>topK中的K是从一组候选中选取得分最高的前K个值<br>beam_width是指保留的候选路径数<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/Pasted%20image%2020241117225342.png" alt="|450"></p><p>目的：每个vocab需要选择K个值作为topK<br>做法：由于<code>vocab_size</code>比较大，因此分成两次topK</p><ul><li>第一次：<code>[bs, beamwidth, vocab size] =&gt; [bs, beamwidth, BlockPerBeam, K]</code><ul><li>将vocab分为<code>BlockPerBeam</code>段，每段做topK选出前<code>K</code>个最大的值</li><li>第一次topK后每个vocab还有<code>BlockPerBeam * K</code>个值</li><li>grid：<code>[min(batch_size * BlockPerBeam, maxBlockNums)]</code></li><li>block：<code>[256]</code></li></ul></li><li>第二次：<code>[bs, beamwidth, BlockPerBeam, K] =&gt; [bs, beamwidth, K]</code><ul><li>将vocab剩下的<code>BlockPerBeam * K</code>个值直接做topK得到K个值</li><li>grid：<code>[min(batch_size, maxBlockNums)]</code></li><li>block：<code>[256]</code></li></ul></li></ul><p>①topK的做法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T, int K&gt;  struct topK{      // 下面这两行的访问权限是public，因为默认就是public所以不用显式地写出来      T val[K];      int id[L];  // 初始化topK中id全为-1，val全为最小值    __device__ void init(){          for(int i = 0; i &lt; K; i++){              id[i] = -1;             val[i] = FLT_MIN;          }        }        // 如果当前输入的数字比最后一个数字大，则摒弃最后一个数字，将输入的数字排进来    void insertHeap(T data, int data_id){  if(id[K-1] == -1 || val[K-1] &lt; data){  id[K-1] = data_id;  val[K-1] = data;  }                // 只需要对当前输入进来的做冒泡排序，因为每进来一个都做一次冒泡排序        for(int i = K-2; i &gt;= 0; i--){              if(val[i + 1] &gt; val[i]){                  T tmp = val[i];                  val[i] = val[i + 1];                  val[i + 1] = tmp;                  int tmp_id = id[i];                  id[i] = id[i + 1];                  id[i + 1] = tmp_id;              }                }        }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②将两个topK做一次reduce输出为一个topK</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T, int K&gt;  __device__ topK&lt;T, K&gt; reduce_functor(const topK&lt;T, K&gt;&amp; a, const topK&lt;T, K&gt;&amp; b) {      topK&lt;T, K&gt; res = a;      for(int i = 0; i &lt; K; i++){          res.insertHeap(b.val[i], b.id[i]);      }        return res;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>③第一次topK</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T, int K, int blockSize, int BlockPerBeam&gt;  __global__ void topK_kernel_round1(const T* probs,    const int vocab_size,      int* topK_ids,    T* topK_vals){      int tid = threadIdx.x;      int bid = blockIdx.x;      int row_id = bid / BlockPerBeam;     // 哪一批vocab/哪一个batch中      int block_lane = bid % BlockPerBeam; // 同一批vocab中的哪一个段      topK&lt;T, K&gt; thread_topK; // 为每一个线程分配一个topK寄存器      thread_topK.init();      // 下面做thread层次的reduce      for(int data_id = tid + block_lane * blockSize; data_id &lt; vocab_size; data_id += BlockPerBeam * blockSize){          int data_offset = data_id + row_id * vocab_size;          T data = probs[data_offset];          thread_topK.insertHeap(data, data_offset);      }            typedef cub::BlockReduce&lt;topK&lt;T, K&gt;, blockSize&gt; blockreduce;     __shared__ typename blockreduce::TempStorage tmp_storage;        topK&lt;T, K&gt; block_topk = blockreduce(tmp_storage).Reduce(thread_topK, reduce_functor&lt;T, K&gt;);        if(tid == 0){          for(int k_offset = 0; k_offset &lt; K; k_offset++){              int dst_offset = row_id * BlockPerBeam * K +              block_lane * K +              k_offset;              topK_vals[dst_offset] = block_topk.val[k_offset];              topK_ids[dst_offset] = block_topk.id;          }        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>入参：</p><ul><li><code>probs</code>：输入的概率值<code>[bs, beamwidth, vocab size]</code></li><li><code>topK_ids</code>和<code>topK_vals</code>：作为输出</li></ul><p>在未需要<code>data+=BlockPerBeam*blockSize</code>时，</p><ul><li>每个batch中，<code>block_lane=0~7</code>，<code>tid=0~255</code></li><li>在不同batch中，<code>row_id</code>不同</li><li><code>data_id+=BlockPerBeam*blockSize</code>可以理解为当<code>data_id</code>是0~2047并且<code>data_id</code>仍未超出<code>vocab_size</code>时，在不变动<code>tid</code>和<code>bid</code>前提下，线程并行执行<code>data+_id</code>加上步长为<code>BlockPerBeam*blockSize</code>得到的新的<code>data_id</code>的行为。直到<code>data_id</code>超过<code>vocab_size</code>为止</li><li><code>data_id</code>可以理解为在某一vocab中的偏移量，加上<code>row_id</code>关于batch的偏移得到最终的偏移量<code>data_offset</code></li><li><code>thread_topK</code>：是每个线程都有自己的topK<ul><li><code>bid=0, tid=0</code>：负责<code>data_id</code>为0、2048、4096的topK</li><li><code>bid=7, tid=1</code>：负责<code>data_ia</code>为1793、2561、4609的topK</li></ul></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef cub::BlockReduce&lt;topK&lt;T, K&gt;, blockSize&gt; blockreduce;    __shared__ typename blockreduce::TempStorage tmp_storage;       topK&lt;T, K&gt; block_topk = blockreduce(tmp_storage).Reduce(thread_topK, reduce_functor&lt;T, K&gt;);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>cub::BlockReduce</code>是NVIDIA提供的CUB(CUDA UnBound)库中的一个模板类，目的是将线程块中的数据(由每个线程负责一部分)规约为单一结果<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T, int BLOCK_DIM&gt; class cub::BlockReduce { public: using TempStorage = typename ImplementationDefined; BlockReduce(TempStorage&amp; temp_storage); T Reduce(T input, ReduceOp reduce_op);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><code>tmp_storage</code>：供线程块中的线程通信和归约使用</li><li><code>block_topk</code>：合并每个线程块中的线程的topK，得到每个线程块的topK</li></ul><p>最后每个block只使用第一个线程做转移，将block_topk个数据转移到topK_vals和topK_ids中。<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/7745326675b006f165b0b23a6397ba1.jpg"><br>④第二次topK</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T, int beam_width, int K, int blockSize, int BlockPerBeam&gt;  __global__ void topK_kernel_round2(const int* topK_ids,    const T* topK_vals,     int* final_topK_ids,    T* final_topK_vals){      int tid = threadIdx.x;      int bid = blockIdx.x;      int row_id = bid; // 改动1：每个batch只用一个block表示，同时没有block_lane    topK&lt;T, K&gt; thread_topK;      thread_topK.init();      // 下面做thread层次的reduce      for(int data_id = tid; data_id &lt; beam_width * BlockPerBeam * K; data_id += blockSize){ // 改动2：data_id的初始不用考虑该batch的第几个block，步长为blockSize        int data_offset = data_id + bid * beam_width * BlockPerBeam * K; // 改动3：batch内的偏移确定后，data_offset在每个batch之间的偏移就是beam_width*BlockPerBeam*K thread_topK.insertHeap(topK_vals[data_offset],    topK_ids[data_offset]);      }            typedef cub::BlockReduce&lt;topK&lt;T, K&gt;, blockSize&gt; blockreduce;      __shared__ typename blockreduce::TempStorage tmp_storage;      topK&lt;T, K&gt; block_topk = blockreduce(tmp_storage).Reduce(thread_topK, reduce_functor&lt;T, K&gt;);        if(tid == 0){          int beam_id = (blockDim.x * blockIdx.x + tid) / BlockPerBeam/ K; // 改动4：写入时需要考虑beam_id，感觉这条公式有点奇怪？        for(int k_offset = 0; k_offset &lt; K; k_offset++){              int dst_offset = bid * beam_width * K +              beam_id * K +              k_offset; // 改动5            final_topK_vals[dst_offset] = block_topk.val[k_offset];              final_topK_ids[dst_offset] = block_topk.id[k_offset];          }        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/b25acc5c3bf310a0925e8b3119ca82d.jpg"></p><h1 id="Lesson18-FusedSoftmax-and-Sampling"><a href="#Lesson18-FusedSoftmax-and-Sampling" class="headerlink" title="Lesson18 FusedSoftmax and Sampling"></a>Lesson18 FusedSoftmax and Sampling</h1><p>讲解了：<br><code>src/kernels/sampling.cu</code><br><code>src/kernels/sampling.h</code><br><code>src/utils/params.h</code><br><code>tests/unittests/test_sampling.cu</code></p><p>在GPU上生成随机数，<strong>主机仅传给设备一个信号，是的多个随机数在device端被生成</strong>：<code>curand_kernel</code></p><p><code>params.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">using IntDict = std::unordered_map&lt;std::string, int&gt;;using floatDict = std::unordered_map&lt;std::string, float&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>键为字符串，值为int或float</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__device__ void curand_init(unsigned long long seed, unsigned long long subsequence, unsigned long long offset, curandState_t* state)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>seed</code>：时间种子。<br><code>subsequence</code>：序列号，区分不同线程块的随机数生成器，确保每个块有自己的随机数生成器。<br><code>offset</code>：在指定序列中的偏移量，用于跳过序列的前几个值以获得不同的随机数，这里表示从序列的起点开始生成随机数。<br><code>state</code>：指向<code>curandState_t</code>的指针，保存生成器的内部状态。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__device__ float curand_uniform(curandState_t* state)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回在<code>0.0f</code>和<code>1.0f</code>之间均匀分布的浮动值</p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/eeb944a0bce156627540b5e069888b6.jpg" alt="|425"><br>在上图的例子中，<code>thredhold-topk_val[0]&gt;0，thredhold-topk_val[0]-topk_val[1]&lt;0</code>，因此采样值落在<code>topk_val[1]</code>上</p><ul><li>grid：<code>[batch_size]</code></li><li>block：<code>[K]</code></li></ul><h1 id="Lesson19-allocator"><a href="#Lesson19-allocator" class="headerlink" title="Lesson19 allocator"></a>Lesson19 allocator</h1><p>讲解了：<br><code>src/memory/allocator/base_allocator.h</code><br><code>src/memory/allocator/cuda_allocator.h</code><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/2f3403abcd9639c30a2c174db5c3798.jpg"><br><code>base_allocator.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class BaseAllocator // 公共的父类  {  public:      virtual ~BaseAllocator(){};      template&lt;class T&gt;      T* Malloc(T* ptr, size_t size, bool is_host){          return(T*)UnifyMalloc((void*)ptr, size, is_host);     }        virtual void* UnifyMalloc(void* ptr, size_t size, bool is_host = false) = 0;       template&lt;typename T&gt;      void Free(T* ptr, bool is_host = false){          UnifyFree((void*)ptr, is_host);      }        virtual void UnifyFree(void* ptr, bool is_host = false) = 0;  };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>父类的析构函数要声明为虚函数：确保当使用基类指针指向派生类对象时，销毁对象时会<strong>正确调用派生类的析构函数</strong>。</li><li><code>(void*)ptr</code>：CPU的分配函数malloc返回的是一个void类型的，所以把传进去的指针强转为void</li><li>定义<code>UnifyMalloc</code>和<code>UnifyFree</code>为虚函数，在子类里一定要实现这个函数</li></ul><p><code>cuda_allocator.h</code><br>①定义两种块</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct CudaBigBlock {      void *data;      size_t size;      bool is_allocated;      CudaBigBlock() = default; // 构造函数      CudaBigBlock(void* data_, size_t size_, bool is_allocated_): // 构造函数          data(data_), size(size_), is_allocated(is_allocated_){}  };    struct CudaSmallBlock {      void* data;      size_t size;      bool is_allocated;      CudaSmallBlock() = default; // 构造函数      CudaSmallBlock(void* data_, size_t size_, bool is_allocated_): // 构造函数              data(data_), size(size_), is_allocated(is_allocated_){}  };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大小块的定义相同</p><ul><li>大内存块：不易造成内存碎片</li><li>小内存块：碎片化较严重，构建小块的内存池主要为了收集碎片大小归还OS(有时不是内存不够，而是碎片太多可能会报out of memory的错</li></ul><p>②定义分配器</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class CudaAllocator: public BaseAllocator {  private:      //{device id: block}    // 每个设备都有内存池      std::map&lt;int, std::vector&lt;CudaSmallBlock&gt; &gt; cudaSmallBlockMap;      std::map&lt;int, std::vector&lt;CudaBigBlock&gt; &gt; cudaBigBlockMap;      std::map&lt;int, size_t&gt; FreeSize;      int dev_id;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义了</p><ul><li>设备ID与以<code>CudaSmallBlock</code>为对象的数组的映射(每个设备都有一个大、小内存池)</li><li>设备ID与以<code>CudaBigBlock</code>为对象的数组的映射</li><li>设备ID与该设备空闲内存大小的映射</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">public:      CudaAllocator() {          cudaGetDevice(&amp;dev_id);      }        ~CudaAllocator() {      }    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为<code>CudaAllocator</code>实现<code>UnifyMalloc</code></p><p>0）对齐32bytes以实现<code>float4</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void* UnifyMalloc(void* ptr, size_t size, bool is_host) { size = ((size + 31) / 32 ) * 32;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>1）如果是主机上申请buffer，用<code>malloc</code>申请</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(is_host){      ptr = malloc(size);     memset(ptr, 0, size);    return ptr;  }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>memset</code>：初始化从<code>ptr</code>指向开始的size个值，初始化的数值为0<br>2）在bigblocks中找空闲的块，即被free出来但是还未归还到OS的<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(size &gt; 1024 * 1024){    auto BigBlocks = cudaBigBlockMap[dev_id];      int blockID = -1;      for(int i = 0; i &lt; BigBlocks.size(); i++){         if(BigBlocks[i].size &gt;= size&amp;&amp;!BigBlocks[i].is_allocated &amp;&amp; BigBlocks[i].size - size &lt; 1024 * 1024){              if(blockID == -1 || BigBlocks[blockID].size &gt; BigBlocks[i].size){                 blockID = i;              }                }        }        if(blockID != -1){          BigBlocks[blockID].is_allocated = true;          return BigBlocks[blockID].data;      }        void* new_buffer;      cudaMalloc(&amp;new_buffer, size);      BigBlocks.push_back(CudaBigBlock(new_buffer, size, false));      return new_buffer;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>如果<code>size</code>大于1024k就用bigblock</li><li><code>if(BigBlocks[i].size &gt;= size &amp;&amp; !BigBlocks[i].is_allocated &amp;&amp; BigBlocks[i].size - size &lt; 1024 * 1024)</code> <ul><li><code>BigBlocks[i].size &gt;= size</code>：该内存块的大小要大于申请的内存</li><li><code>!BigBlocks[i].is_allocated</code>：该内存块没有被分配出去</li><li><code>BigBlocks[i].size - size &lt; 1024 * 1024</code>：该内存块分配之后剩余的内存不会超过1024k(碎片化？)</li></ul></li><li><code>if(blockID == -1 || BigBlocks[blockID].size &gt; BigBlocks[i].size)</code><ul><li><code>blockID == -1</code>：如果当前还没分配内存块</li><li>或者<code>BigBlocks[blockID].size &gt; BigBlocks[i].size</code>：已经分配给该内存的内存块比当前的内存块要大，则替换当前内存块来存储</li></ul></li><li>分配内存块之后，返回一个void类型的指针</li><li>如果未能找到合适的，直接<code>cudaMalloc</code><br>3）在smallblocks中找空闲的块，即被free出来但是还未归还到OS的<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto SmallBlocks = cudaSmallBlocksMap[dev_id];  for(int i = 0; i &lt; SmallBlocks.size(); i++){      if(SmallBlocks[i].size &gt;= size&amp;&amp;!SmallBlocks[i].is_allocated &amp;&amp;SmallBlocks[i].size - size &lt; 1024 * 1024){          SmallBlocks[i].is_allocated = true;          FreeSize[dev_id] += SmallBlocks[i].size; // 这里去掉        return SmallBlocks[i].data;      }        }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>匹配策略：简单首次匹配，使用第一个符合要求的内存块而不再比较</li><li><code>FreeSize[dev_id] += SmallBlocks[i].size;</code>：将分配出来的内存块大小加到对应设备的<code>FreeSize</code>中，以便之后释放内存<br>4）没有找到合适内存的<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">    void* newBuffer = (void*)ptr;      CHECK(cudaMalloc(&amp;newBuffer, size));      CHECK(cudaMemset(newBuffer, 0, size)); // size是初始化的字节数      SmallBlocks.push_back(CudaSmallBlock(newBuffer, size, false));      return new_buffer;  }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><code>__host__ cudaError_t cudaMemset(void* devPtr, int value, size_t count)</code><ul><li>Initializes or sets device memory to a value.</li><li>devPtr：Pointer to device memory</li><li>value：Value to set for each byte of specified memory</li><li>count： Size in bytes to set<br>0）如果指针指向主机端的内存，直接释放<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void UnifyFree(void* ptr, bool is_host) {  if (ptr == nullptr) {  return;  }      if(is_host){             cudaFree(ptr);         } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>1）当累积的小内存块超过1G时，清理未分配出去的smallblocks，已分配的保留在smallmap中<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(auto&amp; it : cudaSmallBlocksMap){      if(FreeSize[it.first]) &gt; 1024 * 1024 * 1024{          auto&amp; cudaBlocks = it.second;          std::vector&lt;CudaSmallBlock&gt; tmp;          for(int i = 0; i &lt; cudaBlocks.size(); ++i){              if(!cudaBlocks[i].is_allocated){                  cudaSetDevice(it.first);                  cudaFree(cudaBlocks[i].data); // 未分配，归还OS            } else{                  tmp.push_back(cudaBlocks[i]); // 已分配，存回map中            }          }                        cudaBlocks.clear();         it.second = tmp;          FreeSize[it.first] = 0;     }        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><code>for(auto&amp; it : cudaSmallBlocksMap)</code>：<ul><li><code>&amp;it</code>：对容器元素的引用，<code>&amp;</code>表示对<code>it</code>的修改会直接作用于容器中的元素而不会创建副本</li><li><code>it.first</code>和<code>it.second</code>：分别是设备ID和内存块向量</li></ul></li><li><code>__host__ cudaError_t cudaSetDevice(int device)</code>：Set device to be used for GPU executions.</li><li><code>cudaBlocks.clear()</code>：在更新cudaBlocks之前先清空</li><li><code>FreeSize[it.first] = 0</code>：对当前设备的FreeSize归零<br>3）找到待free的内存块的位置，设<code>is_allocated = false</code>，大小block都不归还到OS，除非没有在大小block里面找到待free的指针<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">        for(auto&amp; it : cudaSmallBlocksMap){              auto&amp; cudaBlocks = it.second;              for(int i = 0; i &lt; cudaBlocks.size(); i++){                  if(cudaBlocks[i].data == ptr){                      cudaBlocks[i].is_allocated = false;                      FreeSize[it.first] += cudaBlocks[i].size;                    return;                  }                        }                        auto&amp; bigBlocks = cudaBigBlocksMap[it.first];              for(int i = 0; i &lt; bigBlocks.size(); i++){                  if(bigBlocks[i].data == ptr){                      bigBlocks[i].is_allocated = false;                      return;                  }                        }                }            cudaFree(ptr);      }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><code>a.size</code>和<code>a.size()</code></p><ul><li>当<code>a</code>是标准容器(<code>std::vecotr</code>，<code>std::map</code>等等)时，<code>size</code>是一个成员函数，用于获取容器的大小，写法为<code>a.size()</code>，调用成员函数</li><li>当<code>a</code>是用户自定义的类，<code>public: size_t size;</code>时，<code>size</code>是一个成员变量，写法为<code>a.size</code>；<code>public: size(){};</code>时，<code>size</code>是成员函数，写法为<code>a.size()</code></li></ul><h1 id="Lesson-20-Context-attention"><a href="#Lesson-20-Context-attention" class="headerlink" title="Lesson 20 Context attention"></a>Lesson 20 Context attention</h1><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/5731d9562b034964b53c0e7d24bd858.jpg"></p><h2 id="20-1src-layers-attention-context-attention-cpp"><a href="#20-1src-layers-attention-context-attention-cpp" class="headerlink" title="20.1src/layers/attention/context_attention.cpp"></a>20.1<code>src/layers/attention/context_attention.cpp</code></h2><h3 id="20-1-1-构造函数"><a href="#20-1-1-构造函数" class="headerlink" title="20.1.1 构造函数"></a>20.1.1 构造函数</h3><p><code>LLaMAContextAttentionLayer&lt;T&gt;::LLaMAContextAttentionLayer</code>：构造函数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">head_num(head_num),  kv_head_num(kv_head_num),  head_size(head_size),  stream(stream),  cublas_wrapper(cublas_wrapper),  allocator(allocator), hidden_units(head_num * head_size),  attn_static_params(attn_params),   q_head_per_kv(head_num / kv_head_num),  scale(float(1 / sqrt(head_size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="20-1-2-分配内存"><a href="#20-1-2-分配内存" class="headerlink" title="20.1.2 分配内存"></a>20.1.2 分配内存</h3><p><code>LLaMAContextAttentionLayer&lt;T&gt;::allocForForward(LLaMAAttentionDynParams&amp; params)</code>：分配forward所需要的buffer</p><ul><li><p><code>LLaMAAttentionDynParams</code>定义来源：<code>src/models/llama_llama_params.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct LLaMAAttentionDynParams {      int batch_size;      int num_tokens;      int max_q_len;      int max_k_len;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>先定义指针</p><ul><li><code>new</code>：它从堆上分配指定类型的内存，并返回一个指向该内存块的指针。使用 <code>new</code> 分配的内存不会像栈上分配的变量那样在函数结束时自动释放，需要手动释放。</li><li>和<code>malloc</code>区别：<ul><li><code>new</code>：不仅分配内存，还会调用对象的构造函数（如果是类对象的话）</li><li><code>malloc</code>：只负责分配内存，不会调用构造函数</li></ul></li></ul></li><li><p>再分配内存</p><ul><li><code>allocator-&gt;Malloc</code></li><li>对<code>k_cache_buf</code>和<code>v_cache_buf</code>分配内存时，在<code>k_cache_buf</code>分配两倍的内存，再令<code>v_cache_buf</code>的数据指针指向<code>k_cache_buf</code>偏移<code>batch_size * head_num * max_k_len * head_size</code>的地方。这样可以减少一次内存分配<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">k_cache_buf-&gt;data = allocator-&gt;Malloc(k_cache_buf-&gt;data, 2 * sizeof(T) * batch_size * head_num * max_k_len * head_size);v_cache_buf-&gt;data = (T*)k_cache_buf-&gt;data + batch_size * head_num * max_k_len * head_size;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>①<code>fusedQkvGemm</code><br><code>input</code></li></ul></li><li><p><code>input tensor</code><br><code>output</code></p></li><li><p><code>qkv_buf_wo_pad</code>: <code>[num_tokens, qkv_head_num, head_size]</code><br>作用：做linear将输入的tensor乘上qkv权重，得到qkv<br>②<code>AddbiasAndPaddingAndRope</code><br><code>output</code></p></li><li><p><code>q_buf_w_pad</code>: <code>[bs, head_num, max_q_len, head_size]</code></p></li><li><p><code>k_buf_w_pad</code>: <code>[bs, kv_head_num, max_q_len, head_size]</code></p></li><li><p><code>v_buf_w_pad</code>: <code>[bs, kv_head_num, max_q_len, head_size]</code><br>作用：添加偏置，进行padding使同一批次的句子长度相同，进行位置旋转编码<br>③<code>ConcatPastKVcache</code><br><code>output</code></p></li><li><p><code>k_cache_buf</code>: <code>[bs, head_num, max_q_len, head_size]</code></p></li><li><p><code>v_cache_buf</code>: <code>[bs, head_num, max_q_len, head_size]</code><br>作用：将新得到的KV存储到cache中<br>④<code>qk gemm</code><br><code>output</code></p></li><li><p><code>qk_buf</code>: <code>[bs, head_num, max_q_len, max_k_len]</code><br>作用：进行qk相乘，得到$QK^T$<br>⑤<code>FusedMaskAndScaleSoftmax</code><br><code>output</code></p></li><li><p><code>qk buf</code><br>作用：加上mask并进行scale和softmax，得到$Softmax(\dfrac{QK^T}{\sqrt{d_k}})$<br>⑥<code>qk*v gemm</code><br><code>output</code></p></li><li><p><code>qkv_buf_w_pad</code>: <code>[bs, head_num, max_q_len, head_size]</code><br>作用：得到$Softmax(\dfrac{QK^T}{\sqrt{d_k}})V$<br>⑦<code>RemovingPadding</code><br><code>output</code></p></li><li><p><code>qkv_buf_wo_pad_1</code>: <code>[num_tokens, head_num, head_size]</code><br>作用：将padding去掉</p></li></ul><h3 id="20-1-3-释放内存"><a href="#20-1-3-释放内存" class="headerlink" title="20.1.3 释放内存"></a>20.1.3 释放内存</h3><p><code>src/utils/macro.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline void syncAndCheck(const char* const file, int const line){      cudaDeviceSynchronize();      cudaError_t result = cudaGetLastError();      if (result) {          throw std::runtime_error(std::string("[TM][ERROR] CUDA runtime error: ") + (_cudaGetErrorEnum(result)) + " " + file + ":" + std::to_string(line) + " \n");      }}    #define DeviceSyncAndCheckCudaError() syncAndCheck(__FILE__, __LINE__)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>syncAndCheck</code><ul><li><code>cudaDeviceSynchronize()</code>：确保当前所有 CUDA 操作完成</li><li><code>cudaGetLastError()</code>：检查CUDA运行时的最后一个错误</li><li>参数：<ul><li><code>file</code>：记录发生错误的源文件名称</li><li><code>line</code>：记录发生错误的行号</li></ul></li></ul></li><li><code>#define DeviceSyncAndCheckCudaError() syncAndCheck(__FILE__, __LINE__) </code><ul><li>调用<code>syncAndCheck</code>函数，并自动捕获当前的文件名和行号，在调用时不需要显式传递 <code>__FILE__</code> 和 <code>__LINE__</code></li></ul></li></ul><p>释放<code>qkv_buf_wo_pad</code>、<code>q_buf_w_pad</code>、<code>k_cache_buf</code>、<code>qk_buf</code>、<code>qkv_buf_w_pad</code>、<code>qkv_buf_wo_pad_1</code>，在每个<code>Free</code>的后面加上<code>DeviceSyncAndCheckCudaError()</code>，检查是否发生错误</p><h3 id="20-1-4-前向传播"><a href="#20-1-4-前向传播" class="headerlink" title="20.1.4 前向传播"></a>20.1.4 前向传播</h3><p><code>src/utils/tensor.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TensorMap{      std::unordered_map&lt;std::string, Tensor*&gt; tensor_map_;        TensorMap() = default;          TensorMap(std::initializer_list&lt;std::pair&lt;std::string, Tensor*&gt;&gt; tensor_map){          for (auto&amp; pair : tensor_map){              if (isValid(pair.second)){                  tensor_map_.insert(pair.first, pair.second);             }              else{                  LLM_CHECK_WITH_INFO(isValid(pair.second),fmtstr("%s is not a valid tensor, skipping insert into TensorMap", pair.first.c_str()));              }                }        }          TensorMap(const std::unordered_map&lt;std::string, Tensor*&gt;&amp; tensor_map) {  for(auto it = tensor_map.begin(); it != tensor_map.end(); it++){            if (isValid(it-&gt;second)) {                  tensor_map_.insert(it-&gt;first, it-&gt;second);              }                        else {                  // TODO: add a reminder info              }          }        };    // ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>TensorMap(std::initializer_list&lt;std::pair&lt;std::string, Tensor*&gt;&gt; tensor_map)</code><ul><li>接受一个 <code>std::initializer_list</code> 类型的参数，其元素是键值对 <code>std::pair&lt;std::string, Tensor*&gt;</code>，适用于初始化容器</li><li>例子👇<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Tensor* tensor1 = new Tensor(); Tensor* tensor2 = nullptr; // 无效指针TensorMap tmap = {{"key1", tensor1},  {"key2", tensor2}} // 无效，会被跳过<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><code>TensorMap(const std::unordered_map&lt;std::string, Tensor*&gt;&amp; tensor_map)</code><ul><li>接受一个 <code>std::unordered_map&lt;std::string, Tensor*&gt;</code> 类型的参数，使用现有哈希表初始化</li><li>例子👇<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::unordered_map&lt;std::string, Tensor*&gt; umap = {{"key1", tensor1}, {"key2", tensor2}}; TensorMap tmap(umap);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p>①入参</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  void LLaMAContextAttentionLayer&lt;T&gt;::forward(TensorMap&amp; inputs, TensorMap&amp; outputs, LLaMAattentionWeights&lt;T&gt;&amp; weights,LLaMAAttentionDynParams&amp; params, LLaMAAttentionStaticParams&amp; static_params)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>inputs</code>：元素大概是<code>{"attention_input",tensor1},{"padding_offset",tensor2}</code><ul><li>因为很多函数需要TensorWrapper，而传进去的是Tensor，对于需要Tensor强转为TensorWrapper的情况，用到👇(<code>src/utils/tensor.h</code>)<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;  TensorWrapper&lt;T&gt;* as(){      return static_cast&lt;TensorWrapper&lt;T&gt;*&gt;(this); // Tensor转子类TensorWrapper的下行转换  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><code>outputs</code>：同上</li><li><code>weights</code>：<code>src/weights/llama/attention_weights.h</code>中，内置属性有<code>BaseWeight&lt;T&gt; qkv;  BaseWeight&lt;T&gt; output;</code></li><li><code>params</code>：<code>src/models/llama/llama_params.h</code>，内置属性有<code>int batch_size; int num_tokens; int max_q_len; int max_k_len;</code></li><li><code>static_params</code>：<code>src/models/llama/llama_params.h</code>，是关于旋转编码的属性<code>int rotary_embedding_dim; float rotary_embedding_base;  int max_position_embeddings; bool use_dynamic_ntk;</code></li></ul><p>②准备内存<br>使用20.1.2中的分配内存</p><p>③qkv linear<br><code>src/kernels/linear.h</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchLinearGemm(attention_input-&gt;as&lt;T&gt;(), weights.qkv, qkv_buf_wo_pad, cublas_wrapper)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对应<code>input</code>、<code>weight</code>、<code>output</code>、<code>cublas_wrapper</code>、<code>trans_a</code>、<code>trans_b</code><br>完成<code>fusedQkvGemm</code></p><p>④qkv bias and rope and padding</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchAddFusedQKVBiasTransposeAndRoPE(qkv_buf_w_pad,   k_buf_w_pad,   v_buf_w_pad,   qkv_buf_wo_pad,  weights.qkv,   padding_offset-&gt;as&lt;int&gt;(),   history_length-&gt;as&lt;int&gt;(),   input_length-&gt;as&lt;int&gt;(),  static_params);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后在<code>k_buf_w_pad</code>和<code>v_buf_w_pad</code>得到rope和padding的版本</p><p>⑤concat past kv cache</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchConcatKVCache(k_buf_w_pad, v_buf_w_pad, layer_id-&gt;as&lt;int&gt;(), input_length-&gt;as&lt;int&gt;(), history_length-&gt;as&lt;T&gt;(),                      all_k_cache-&gt;as&lt;T&gt;(),                     all_v_cache-&gt;as&lt;T&gt;());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后在<code>all_k_cache</code>和<code>all_v_cache</code>得到kvcache<br>因为<code>layer_id</code>是在CPU上分配的<code>int layer = layer_id-&gt;getVal();</code>因此需要转为TensorWrapper</p><p>⑥repeat kv</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchRepeatKVCache(all_k_cache-&gt;as&lt;T&gt;(), all_v_cache-&gt;as&lt;T&gt;(), context_length-&gt;as&lt;int&gt;(),                      layer_id-&gt;as&lt;int&gt;(),                    k_cache_buf,                     v_cache_buf);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>input</code>:<br>    <code>all_k_cache</code>&amp;<code>all_v_cache</code>: <code>[num_layers, batch_size, kv_head_num, max_seq_len, head_size]</code><br><code>output</code>:<br>    <code>k_cache_buf</code>&amp;<code>v_cache_buf</code>: <code>[bs, head_num, max_k_len, head_size]</code><br>作用是将kvcache的<code>kv_head_num</code>补成<code>head_num</code></p><p>⑦qk</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchLinearStridedBatchGemm(q_buf_w_pad, k_cache_buf, qk_buf, cublas_wrapper, false, true);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>input</code>:<br>    <code>q_buf_w_pad</code>: <code>[bs, head_num, max_q_len, head_size]</code><br>    <code>k_cache_buf</code>: <code>[bs, head_num, max_k_len, head_size]</code>(trans_b = true)<br><code>output</code>:<br>    <code>qk_buf</code>: <code>[bs, head_num, max_q_len, max_k_len]</code></p><p>⑧scale + mask + softmax</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchScaleMaskAndSoftmax(qk_buf, attention_mask-&gt;as&lt;T&gt;(), qk_buf, scale);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>给<code>qk_buf</code>加scale、mask、softmax</p><p>⑨qk*v</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchLinearStridedBatchGemm(qk_buf, v_cache_buf, qkv_buf_w_pad, cublas_wrapper, false, false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>input</code>:<br>    <code>qk_buf</code>: <code>[bs, head_num, max_q_len, max_k_len]</code><br>    <code>v_cache_buf</code>: <code>[bs, head_num, max_k_len, head_size]</code><br><code>output</code>:<br>    <code>qkv_buf_w_pad</code>: <code>[bs, head_num, max_q_len, head_size]</code></p><p>⑩transpose + removepadding</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchTransposeOutRemovePadding(qkv_buf_w_pad, padding_offset-&gt;as&lt;T&gt;(), qkv_buf_wo_pad_1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>input</code>:<br>    <code>qkv_buf_w_pad</code>: <code>[bs, head_num, max_q_len, head_size]</code><br>    先transpose变成<code>[bs, max_q_len, head_num, head_size]</code><br><code>output</code>:<br>    <code>qkv_buf_wo_pad_1</code>: <code>[numtokens, hiddenunits]</code></p><p>①output linear</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchLinearGemm(qkv_buf_wo_pad_1, weights.output, attention_output, cublas_wrapper, false, true);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>乘上输出的权重</p><p>②freebuf<br>释放所有的缓存</p><h2 id="20-2examples-cpp-attention-context-attn-example-cpp"><a href="#20-2examples-cpp-attention-context-attn-example-cpp" class="headerlink" title="20.2examples/cpp/attention/context_attn_example.cpp"></a>20.2examples/cpp/attention/context_attn_example.cpp</h2><p>变量：</p><ul><li>基本参数：<ul><li><code>head_num</code>&amp;<code>kv_head_num</code>：前者是q的，后者是k和v的</li><li><code>head_size</code></li><li><code>num_layers</code></li><li><code>max_seq_len</code>：kv cache最大的上下文长度</li><li><code>hidden_units</code>&amp;<code>q_hidden_units</code>：前者是qkv总和的，后者是q的</li><li>作为初始化每个kernel里大小的参数</li></ul></li><li>静态参数：(多数是位置编码的)<ul><li><code>rotary_embedding_dim</code></li><li><code>rotary_embedding_base</code></li><li><code>max_position_embeddings</code></li><li><code>use_dynamic_ntk</code></li></ul></li><li>动态参数：<ul><li><code>batch_size</code></li><li><code>num_tokens</code></li><li><code>max_q_len</code>&amp;<code>max_k_len</code><ul><li><code>max_q_len</code>：padding之前同一batch下的最长的句子长度</li><li><code>max_k_len</code>：同一个batch中上下文的最大值</li></ul></li></ul></li><li>输入输出值(从主机上获取数据，复制到设备上)<ul><li><code>attention_input</code>：<code>[num_tokens，q_hidden_units]</code>，是最初的输入</li><li><code>qkv_weights</code>：<code>[q_hidden_units, hidden_units]</code>，做<code>qkvgemm</code>时用到</li><li><code>mask</code>：<code>[batch_size, max_q_len, max_k_len]</code>，当前的toekn不能访问到其后面的token</li><li><code>qkv_bias</code>：<code>[hidden_units]</code>，qkv的偏置</li><li><code>all_k_cache</code>：<code>[num_layers, batch_size, kv_head_num, max_seq_len, head_size]</code></li><li><code>all_v_cache</code>：<code>[num_layers, batch_size, kv_head_num, max_seq_len, head_size]</code></li><li><code>padding_offset</code>：<code>[num_tokens]</code>，每个token都有一个”在该token之前的padding个数的数值“</li><li><code>history_length</code>：<code>[batch_size]</code></li><li><code>layer_id</code>：</li><li><code>ctx_len</code>：<code>[batch_size]</code>，每句话的上下文长度？</li><li><code>attention_output</code>：<code>[num_tokens, q_hidden_units]</code></li><li><code>output_weights</code>：<code>[q_hidden_units, q_hidden_units]</code></li></ul></li></ul><h1 id="Lesson21-mask-self-attention-layer"><a href="#Lesson21-mask-self-attention-layer" class="headerlink" title="Lesson21 mask self attention layer"></a>Lesson21 mask self attention layer</h1><p>说是写的GQA部分<br>区别与context decoder: </p><ul><li>自回归生成模式，因此不需要mask和padding(和remove padding)</li></ul><p>layer搭建顺序和context attention类似</p><h2 id="21-1src-layers-attention-masked-self-attentioon-cpp"><a href="#21-1src-layers-attention-masked-self-attentioon-cpp" class="headerlink" title="21.1src/layers/attention/masked_self_attentioon.cpp"></a>21.1src/layers/attention/masked_self_attentioon.cpp</h2><p>①分配内存</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">allocForForward(params);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>②qkv linear</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchLinearGemm(attention_input-&gt;as&lt;T&gt;(), weights.qkv, qkv_buf, cublas_wrapper);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时，这里不需要在后面加上<code>DeviceSyncAndCheckCudaError();</code>因为<code>cublasWrapper</code>自带了<code>CHECK_CUBLAS</code>(因此涉及到cublas的都不需要再进行检查)<br>③fused decoder self attention</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchDecoderMaskedMHA(qkv_buf, weights.qkv,    layer_id-&gt;as&lt;int&gt;(),                         k_cache-&gt;as&lt;T&gt;(),                        v_cache-&gt;as&lt;T&gt;(),                        finished-&gt;as&lt;bool&gt;(),                         step-&gt;as&lt;int&gt;(),                        mha_output-&gt;as&lt;T&gt;(),                        static_params);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一个入参是<code>LLaMAAttentionStaticParams&amp; static_param</code>，是一个含有位置编码属性的结构体</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct LLaMAAttentionStaticParams {      int   rotary_embedding_dim;      float rotary_embedding_base;      int   max_position_embeddings;      bool  use_dynamic_ntk; // for dyn scaling rope  };template&lt;typename T&gt;  class LLaMASelfAttentionLayer {private:LLaMAAttentionStaticParams attn_static_params;public:LLaMAAttentionStaticParams&amp; GetAttnStaticParams(){      return attn_static_params;  // 这里的返回值是引用，函数的调用不会复制attn_static_params，而是直接返回它的内存地址}template&lt;typename T&gt;  void LLaMASelfAttentionLayer&lt;T&gt;::forward(TensorMap&amp; inputs, TensorMap&amp; outputs, LLaMAattentionWeights&lt;T&gt;&amp; weights, LLaMAAttentionDynParams&amp; params){LLaMAAttentionStaticParams static_params = GetAttnStaticParams();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>为什么可以直接使用<code>LLaMAAttentionStaticParams static_params = GetAttnStaticParams();</code>：<ul><li>编译器对<strong>引用</strong>指向的<code>attn_static_params</code>执行拷贝构造，生成一个新的<code>LLaMAAttentionStaticParams</code>实例<ul><li>局部变量<code>static_params</code>是一个<strong>值类型</strong></li><li><code>GetAttnStaticParams()</code>返回一个指向类中成员变量<code>attn_static_params</code>的<strong>引用</strong></li></ul></li><li>如果修改<code>static_params</code>，不会影响<code>attn_static_params</code></li></ul></li><li>如果是另一种情况<code>LLaMAAttentionStaticParams&amp; static_params = GetAttnStaticParams();</code><ul><li><code>static_params</code>只是<code>attn_static_params</code>的一个别名，编译器不会为<code>static_params</code>分配新的内存空间，他和<code>attn_static_params</code>共用一块内存<ul><li>局部变量<code>static_params</code>是一个<strong>引用类型</strong></li><li><code>GetAttnStaticParams()</code>返回一个指向类中成员变量<code>attn_static_params</code>的<strong>引用</strong></li></ul></li></ul></li><li>引用与指针的区别<ul><li>引用：一旦绑定到某个变量就不能再绑定到其他变量；本质上是变量的别名，不需要占用额外的内存</li><li>指针：可以重新指向其他变量；是一个独立的变量，需要占用内存来存储地址</li></ul></li></ul><p>④output</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchLinearGemm(mha_output, weights.output, attention_output-&gt;as&lt;T&gt;, cublas_wrapper);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="21-2src-examples-cpp-attention-self-attention-example-cpp"><a href="#21-2src-examples-cpp-attention-self-attention-example-cpp" class="headerlink" title="21.2src/examples/cpp/attention/self_attention_example.cpp"></a>21.2src/examples/cpp/attention/self_attention_example.cpp</h2><p>变量：</p><ul><li>基本参数：<ul><li><code>head_num</code>&amp;<code>kv_head_num</code>：前者是q的，后者是k和v的</li><li><code>head_size</code></li><li><code>num_layers</code></li><li><code>max_seq_len</code>：kv cache最大的上下文长度</li><li><code>hidden_units</code>&amp;<code>q_hidden_units</code>：前者是qkv总和的，后者是q的</li><li>作为初始化每个kernel里大小的参数</li></ul></li><li>静态参数：(多数是位置编码的)<ul><li><code>rotary_embedding_dim</code></li><li><code>rotary_embedding_base</code></li><li><code>max_position_embeddings</code></li><li><code>use_dynamic_ntk</code></li></ul></li><li>动态参数：<ul><li><code>batch_size</code></li></ul></li><li>输入输出值(从主机上获取数据，复制到设备上)<ul><li><code>attention_input</code>：<code>[num_tokens，q_hidden_units]</code>，是最初的输入</li><li><code>all_k_cache</code>：<code>[num_layers, batch_size, kv_head_num, max_seq_len, head_size]</code></li><li><code>all_v_cache</code>：`[num_layers, batch_size, kv_head_num, max_seq_len, </li><li><code>layer_id</code></li><li><code>finished</code>：<code>[batch_size]</code></li><li><code>qkv_weights</code>：<code>[q_hidden_units, hidden_units]</code>，做<code>qkvgemm</code>时用到</li><li><code>output_weights</code>：<code>[q_hidden_units, q_hidden_units]</code></li><li><code>qkv_bias</code>：<code>[hidden_units]</code>，qkv的偏置</li><li><code>attention_output</code>：<code>[num_tokens, q_hidden_units]</code></li></ul></li></ul><h1 id="Lesson22-FFN"><a href="#Lesson22-FFN" class="headerlink" title="Lesson22 FFN"></a>Lesson22 FFN</h1><p><a href="https://www.cnblogs.com/peixu/p/16842247.html" title="发布于 2022-10-30 21:04">关于Transformer中feed forward layer理解</a><br><a href="https://juejin.cn/post/7389923941492375579">Transformer 论文通俗解读：FFN 的作用</a></p><h2 id="22-1-src-layers-ffn-ffn-h"><a href="#22-1-src-layers-ffn-ffn-h" class="headerlink" title="22.1 src/layers/ffn/ffn.h"></a>22.1 <code>src/layers/ffn/ffn.h</code></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void allocForForward(LLaMAAttentionDynParams&amp; params);  void allocForForward(int batch_size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重载函数</p><ul><li>context attention中在remove padding后数据的第一维是<code>num_tokens</code>(传入的是<code>params.num_tokens</code>)</li><li>self attention中数据的第一维一直是<code>batch_size</code>(<code>[batch_size, 1, ...]</code>)</li></ul><h2 id="22-2-src-layers-ffn-ffn-cpp"><a href="#22-2-src-layers-ffn-ffn-cpp" class="headerlink" title="22.2 src/layers/ffn/ffn.cpp"></a>22.2 <code>src/layers/ffn/ffn.cpp</code></h2><p><code>forward()</code><br>①确定使用哪种forward的内存分配</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (params.num_tokens &gt; 0) {      allocForForward(params);  } else {                      allocForForward(params.batch_size);  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果存在num_tokens则为context attention，对应<code>params</code>；<br>如果不存在则为self attention，对应<code>batch_size</code></p><p>②fusedGateUp projs</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchLinearGemm(ffn_input-&gt;as&lt;T&gt;(), weights.gateAndup, SwiGLU_input, cublas_wrapper, false, true);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>输入<code>ffn_input</code>：<code>[bs(/num_tokens), q_hidden_units]</code></li><li>权重<code>weights.gateAndup</code>：<code>[q_hidden_units, 2 * inter_size]</code></li><li>输出<code>SwiGLU_input</code>：<code>[bs(/num_tokens), 2 * inter_size]</code></li><li>经过Gate Linear和Up Linear的输入都是<code>[bs(/num_tokens), q_hidden_units]</code>，因此将他们像fusedQKVGemm一样进行fusedGateUpGemm，输出使用同一块buf</li><li>为啥这里trans_b=true？</li></ul><p>③swiGLU</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchAct(SwiGLU_input, down_proj_input);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>输入<code>SwiGLU_input</code>：<code>[bs(/num_tokens), 2 * inter_size]</code><ul><li>两个大小为<code>[bs(/num_tokens), inter_size]</code>的Gate数组和Up数组的相同偏移量的数据一起计算，因此最后的输出的第二维大小为原来的一半</li></ul></li><li>输出<code>down_proj_input</code>：<code>[bs(/num_tokens), inter_size]</code></li></ul><p>④down proj</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">launchLinearGemm(down_proj_input, weights.down, ffn_output-&gt;as&lt;T&gt;(), cublas_wrapper, false, true);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>输入<code>down_proj_input</code>：<code>[bs(/num_tokens), inter_size]</code></li><li>权重<code>weights.gateAndup</code>：<code>[q_hidden_units, inter_size]</code> trans_b=true</li><li>输出<code>SwiGLU_input</code>：<code>[bs(/num_tokens), q_hidden_units]</code></li></ul><h2 id="22-3examples-cpp-ffn-ffn-example-cpp"><a href="#22-3examples-cpp-ffn-ffn-example-cpp" class="headerlink" title="22.3examples/cpp/ffn/ffn_example.cpp"></a>22.3<code>examples/cpp/ffn/ffn_example.cpp</code></h2><p>变量：</p><ul><li>基本参数：<ul><li>`head_num</li><li><code>head_size</code></li><li><code>inter_size</code></li><li>`hidden_units</li><li>作为初始化每个kernel里大小的参数</li></ul></li><li>动态参数：<ul><li><code>num_tokens</code></li></ul></li><li>输入输出值(从主机上获取数据，复制到设备上)<ul><li><code>ffn_input</code>：<code>[hidden_units, num_tokens]</code></li><li><code>gate_up</code>：<code>[hidden_units, 2 * inter_size]</code></li><li><code>down</code>：<code>[hidden_units, inter_size]</code></li></ul></li><li>设置为设备参数<ul><li><code>ffn_output</code></li></ul></li></ul><h2 id="22-4-关于CMakeList-txt"><a href="#22-4-关于CMakeList-txt" class="headerlink" title="22.4 关于CMakeList.txt"></a>22.4 关于CMakeList.txt</h2><p><code>src/layers/ffn/CMakList.txt</code></p><ul><li>将<code>ffn.cpp</code>编译到静态库中并命名为<code>Llamaffn</code><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">add_library(Llamaffn STATIC ffn.cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>链接<code>Llamaffn</code>所用到的函数(<code>launchLinearGemm</code>,<code>launchAct</code>)对应的静态库(<code>linear</code>,<code>act</code>)<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">target_link_libraries(Llamaffn PUBLIC                               -lcudart                               -lcudadevrt                               act                               linear)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><code>examples/cpp/ffn/CMakeList.txt</code></li><li>将<code>ffn_example.cpp</code>编译到可执行目标文件中并命名为<code>ffnExample</code> <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">add_executable(ffnExample ffn_example.cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>链接<code>ffnExample</code>所用到的函数(<code>ffn.cpp</code>)对应的静态库(<code>Llamaffn</code>)</li></ul><h1 id="Lesson23-llama-layer-weight"><a href="#Lesson23-llama-layer-weight" class="headerlink" title="Lesson23 llama layer weight"></a>Lesson23 llama layer weight</h1><p>讲解了：<br><code>src/weights/llama/layer_weights.h</code><br><code>src/weights/llama/layer_weights.cc</code><br><code>src/weights/llama/CMakelists.txt</code><br><code>src/utils/weights_utils.h</code><br><code>src/utils/weights_utils.cu</code><br><code>src/utils/CMakelists.txt</code></p><p>有weight的地方</p><ul><li>llama weights<ul><li>Embedding</li><li>LMhead(本质上也是一个linear)</li></ul></li><li>layer weights<ul><li>特点是有很多transformer堆叠起来</li><li><code>LayerNormWeight&lt;T&gt; attn_norm_weight;</code><ul><li>RMSNorm</li></ul></li><li><code>LLaMAattentionWeights&lt;T&gt; self_attn_weight;</code><ul><li>QKVgemm</li><li>output linear</li></ul></li><li><code>LayerNormWeight&lt;T&gt; ffn_norm_weight;</code><ul><li>FusedAddbiasResidualAndRMSNorm</li></ul></li><li><code>LLaMAFFNWeights&lt;T&gt; ffn_weight;</code><ul><li>Gate</li><li>Up</li><li>down</li></ul></li></ul></li></ul><p><code>src/utils/weights_utils.cu</code><br>在源文件中的模板不是一个函数，只有在实例化后才是一个函数并且可以进行链接<br>实现了<code>GPUMalloc</code>和<code>GPUFree</code>，目的：在分配内存和释放内存时进行检查</p><p><code>src/weights/llama/layer_weights.h</code><br>定义了四个函数</p><p><code>src/weights/llama/layer_weights.cc</code><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/57edc5cf50e98d36315d8564f2c5111.png"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/39931b88ed57cae22fab8e5d4700e67.jpg"><br>①<code>attn_norm_weight.gamma</code>：context decoder和self decoder共用</p><ul><li>类型为：<code>LayerNormWeight&lt;T&gt;</code></li><li>成员有：<code>T* gamma</code><br>④<code>ffn_norm_weight.gamma</code>：context decoder和self decoder共用<br>同上</li></ul><p>②<code>self_attn_weight.qkv</code>：context decoder和self decoder共用</p><ul><li>类型为：<code>BaseWeight&lt;T&gt;</code></li><li>成员有：<ul><li><code>std::vector&lt;int&gt; shape;</code></li><li><code>T* data;</code></li><li><code>WeightType type;</code></li><li><code>T* bias;</code>不一定每个weight都有<br>③⑤⑥⑦同上<br>③<code>self_attn_weight.output</code><br>⑤<code>ffn_weight.gate</code>：context decoder和self decoder共用<br>⑥<code>ffn_weight.up</code>：context decoder和self decoder共用<br>⑦<code>ffn_weight.down</code>：context decoder和self decoder共用</li></ul></li></ul><p>在<code>loadWeights</code>这一步中，可以加入假的数据，省去加载模型这一步，主要用于测试性能，不关注精度</p><ul><li>流程：<code>cudaMalloc</code>各种d_weights变量 -&gt; <code>malloc</code>各种h_weights变量 -&gt; h_weights载入假数据 -&gt; 通过<code>cudaMemcpy</code>将h_weights复制到d_weights -&gt; 再将d_weights赋值给</li></ul><p><code>freeWights(BaseWeight&lt;T&gt;&amp; weights)</code>：将<code>bias</code>也给释放<br>最后析构函数中释放所有的缓存</p><h1 id="Lesson24-AddBiasResidual"><a href="#Lesson24-AddBiasResidual" class="headerlink" title="Lesson24 AddBiasResidual"></a>Lesson24 AddBiasResidual</h1><p>讲解了：<br><code>src/kernels/add_residual.h</code><br><code>src/kernels/add_residual.cu</code><br><code>tests/unittest/test_residual.cu</code></p><p><code>residual</code>来源<code>FusedAddbiasResidualAndRMSNorm</code>中<code>FusedAddbiasResidual</code>的输出(同时是<code>RMSNorm</code>的输入)<br><code>decoder_out</code>来源<code>Down Linear</code></p><p><code>decoder_out</code> += <code>residual</code></p><ul><li><code>decoder_out</code>：<code>[num_tokens, hidden_units]</code></li><li><code>redisual</code>：<code>[num_tokens, hidden_units]</code>←在context decoder中，在self decoder中第一维是batch_size</li><li>作用：代表了初步融合后的特征，是一种包含原始信息与新特征的信息流，随后会传递到归一化操作（如 RMSNorm）中，以便为下游模块提供稳定的分布。</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Vec_t* dout = reinterpret_cast&lt;Vec_t*&gt;(decoder_out + batch_id * hidden_units);Vec_t* rsd = reinterpret_cast&lt;Vec_t*&gt;(residual + batch_id * hidden_units);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将<code>decoder_out</code>和<code>residual</code>转化为向量化类型，并且每个<code>dout</code>/<code>rsd</code>表示每一个token或batch每一行的数据都能被转换为Vec_t类型的指针</p><p>一般实现(fp32)和特化实现(专给fp16使用)的区别</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i = tid; i &lt; hidden_units/vec_size; i+=blockDim.x){    dout[i].x += rsd[i].x; // dout既是输入也是输出      dout[i].y += rsd[i].y;      dout[i].z += rsd[i].z;      dout[i].w += rsd[i].w;  }for(int i = tid; i &lt; hidden_units/vec_size; i+=blockDim.x){    dout[i] = __hadd2(dout[i], rsd[i]); // 两个half2做加法  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>for</code>循环保证一个block的线程能够遍历完<code>hidden_units</code>的元素</p><p><code>tests/uinttests/test_residual.cu</code><br>在<code>CPUresidual</code>中，可以通过AVX-512 kernel + openMP进行性能改善</p><ul><li><code>AVX-512</code>(Advanced Vector Extensions 512)<ul><li>SIMD</li><li>支持512位宽的寄存器和矢量操作<ul><li>每次处理可以加载16个浮点数</li></ul></li></ul></li><li><code>OpenMP</code>(Open Multi-Processing)<ul><li>多线程并行编程接口，用于在共享内存环境中通过任务划分和线程控制实现并行加速</li></ul></li></ul><h1 id="Lesson25-Context-Decoder"><a href="#Lesson25-Context-Decoder" class="headerlink" title="Lesson25 Context Decoder"></a>Lesson25 Context Decoder</h1><p><code>src/layers/decoder</code></p><p><code>Input embedding</code> -&gt; <code>RMSNorm</code> -&gt; <code>Context Attention</code> -&gt; <code>FusedAddbiasResidualAndRMSNorm</code>(凡是残差加，残差来自上一个<code>RMSNorm</code>的输入) -&gt; <code>FFN</code> -&gt; <code>AddbiasResidual</code></p><p>四个中间buffer：</p><ul><li><code>decoder_residual</code>：(不同时)存储(两个地方的)残差</li><li><code>attention_mask</code>：保存生成的<code>CausalMask</code></li><li><code>padding_offset</code></li><li><code>cum_seqlens</code>：累积句子长度，和<code>padding_offset</code>的生命周期一样</li></ul><p><code>src/layers/decoder/context_decoder.cpp</code><br><code>LlamaContextDecoder&lt;T&gt;::forward</code></p><ul><li>入参：<ul><li><code>TensorMap&amp; input_tensors</code></li><li>`const std::vector&lt;LlamaLayerWeight<t>*&gt;&amp; layerWeights</t></li><li><code>TensorMap&amp; output_tensors</code></li><li><code>LLaMAAttentionDynParams&amp; dyn_params</code><br>①内存分配：导入动态变量并分配四个中间buffer的内存<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">allocForForward(dyn_params);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>②获得偏移<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Tensor* seq_lens = input_tensors["input_length"];  launchCalPaddingoffset(padding_offset, cum_seqlens, seq_lens-&gt;as&lt;int&gt;());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li>入参：<ul><li><code>TensorWrapper&lt;int&gt;* padding_offset</code></li><li><code>TensorWrapper&lt;int&gt;* cum_seqlens</code>，累积的句子长度，是所有batch的累积</li><li><code>TensorWrapper&lt;int&gt;* input_lengths</code>，每个句子的输入长度<br>③获取掩码长度<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Tensor* context_length = input_tensors["context_length"];  launchBuildCausalMasks(attention_mask, seq_lens-&gt;as&lt;int&gt;(), context_length-&gt;as&lt;int&gt;());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li>入参：<ul><li><code>TensorWrapper&lt;T&gt;* mask</code></li><li><code>TensorWrapper&lt;int&gt;* q_lens</code>，每个句子的输入长度</li><li><code>TensorWrapper&lt;int&gt;* k_lens</code>，每个句子的上下文长度<br>④搭建32层context decoder layer并进行context attention<br>为啥：搜“疑问”<br>1)从函数输入的<code>input_tensors</code>和<code>output_tensors</code>获得相应键值对并取地址，检查是否为空<br>2)初始化<code>ctx_attn_inputs</code>和<code>ctx_attn_outpus</code>键值对，这里指的是每一层的输入和输出<br>3)进行32层Layer的context attention</li></ul></li><li>从for循环的变量获取<code>layer_id</code>并更新到<code>ctx_attn_inputs[layer_id]</code>中</li><li>获取context attntion的输入</li><li>进行context attention，输出为<code>ctx_attn_outputs</code></li><li>进行FusedAddBiasResidualRMSNorm，输出为<code>decoder_output</code>(ctx_attn_outputs[“attention_output”]的指针)</li><li>进行ffn，输入为<code>decoder_output</code>，输出直接复用输入的内存区</li><li>进行AddResidual，该kernel在实现时，残差加的结果放在decoder_out上</li><li>把当前Layer的输出作为下一层Layer的输入，直接用当前Layer的输出<code>decoder_output</code>更新到key为”attention_input”的value中</li></ul><h1 id="Lesson26-Self-Decoder"><a href="#Lesson26-Self-Decoder" class="headerlink" title="Lesson26 Self Decoder"></a>Lesson26 Self Decoder</h1><p>待解决：llama2是不包含第一个addbias的，所以只剩下RoPE，因为旋转编码的旋转大小是64，所以不能融合到Fused Masked self Attetion里，如果是2就可以</p><ul><li>RoPE没有出现！<ul><li>有的，是在Fused Masked self Attention里</li></ul></li></ul><p>除了一些不需要的变量，步骤方法和context decoder的搭建差不多</p><h1 id="Lesson27-llama-weights"><a href="#Lesson27-llama-weights" class="headerlink" title="Lesson27 llama weights"></a>Lesson27 llama weights</h1><p><code>tools/convert_downloaded_llama_weights.py</code><br><code>tools/weights_conver.py</code></p><ul><li>在python中<ul><li>下载模型</li><li>转换<ul><li>将原本的.pth形式的权重，对应输出到每一层的每一个类型的(qkvgemm, gate, down, up等等的)权重</li><li>合并qkv的权重，合并gate和up的权重，把所有权重文件转为.bin格式的，即转为二进制</li></ul></li></ul></li></ul><p><code>src/weights/llama/llama_weights.cc</code><br><code>src/weights/llama/llama_weights.h</code></p><ul><li>读取从python文件中得到的权重，并赋值给已分配好显存的指针</li><li>四个public成员(llama weights)<ul><li><code>llama_layer_weight</code>，有<code>num_layer</code>层</li><li><code>out_rmsnorm_weight</code></li><li><code>post_decoder_embedding_weight</code> (sampling的LMhead)</li><li><code>pre_decoder_embedding_weight</code></li></ul></li></ul><p><code>src/utils/weights_utils.cc</code><br><code>src/utils/weights_utils.h</code></p><ul><li>当pyhton转换完的权重格式与目标格式不一致时，如half和float，则进行转换再加载二进制文件</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">llama_layer_weight.reserve(num_layer);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>vector.push_back和vector.reserve的区别<ul><li>push_back，2-&gt;4-&gt;6-&gt;8-&gt;16-&gt;32-&gt;…，当向量中有2个元素，push_back到3个元素时，vector地址自动重新分配并且容量变为4，后续的增加同理</li><li>reserve，指定容量，不会自动重新分配</li></ul></li></ul><h1 id="Lesson28-llama类"><a href="#Lesson28-llama类" class="headerlink" title="Lesson28 llama类"></a>Lesson28 llama类</h1><p>更高层次的抽象</p><p><code>std::function&lt;返回值类型(参数列表)&gt;</code>定义了一个可调用对象的签名</p><ul><li>可调用对象的签名包括返回值类型和参数列表<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/Pasted%20image%2020250115113416.png"></li></ul><p><code>src/models/llama/llama.cpp</code><br><code>src/models/llama/llama.h</code></p><p><code>std::string Llama&lt;T&gt;::Response(const std::vector&lt;std::string&gt; &amp;input, CallBack PrintRes)</code></p><ul><li>入参<ul><li><code>input</code>：用户输入的类型为字符串向量的句子</li><li><code>PrintRes</code>：打印结果</li></ul></li><li><code>Encode</code><ul><li><code>input</code>、<code>history_str</code>、<code>total_str</code></li><li>上面这三个和<code>MakeInput</code>函数有关</li><li><code>MakeInput</code>中的<code>ret</code>就是<code>Response</code>中的<code>input</code><ul><li><code>total_str</code>是所有轮次的input，包括现在和之前的</li><li><code>history_str</code>是之前轮次的input</li><li><code>input</code>是现在轮次的input</li></ul></li><li>得到三者的token indexs</li><li>这三者的长度是<code>int_params_first_token</code>字典中的值</li></ul></li><li><code>attn_dyn_params</code> llama类模型里动态改变的变量<ul><li><code>batch_size</code>：硬写为1</li><li><code>num_tokens</code>：当前输入的长度</li><li><code>max_q_len</code>：batch中q的最大长度，因为一个batch只有一个句子，所以等于num_tokens</li><li><code>max_k_len</code>：动态最大上下文，<code>step</code>的值与其相同(在self decoder中用到)</li></ul></li><li>获得所有轮次的token string<ul><li>自定义<code>self_token_limit</code></li><li><code>firstTokenGen</code><ul><li>入参：<code>attn_dyn_params</code>、<code>int_params_first_token</code></li><li><code>InitializeForContextDecoder</code><ul><li>传入所有轮次、之前轮次和现在轮次到CPU中，再复制到GPU中</li></ul></li><li><code>inputEmbedding</code><ul><li>得到输入的句子对应的token在embed table里的词向量</li></ul></li><li>包装<code>decoder_inputs</code>和<code>decoder_outputs</code>这两个TensorMap</li><li>进行推理</li><li>进行RMSNorm</li><li>进行LMHead和topkSample<ul><li>LMHead<ul><li>如果是context decoder<ul><li>取输出里的最后一个token作为LMHead的输入，经过矩阵相乘得到<code>probs</code>维度为：<code>[1, vocab_size]</code>，就知道这几个vocab的可能性</li></ul></li><li>如果是self decoder<ul><li><code>decoder_output</code>就是唯一的token，直接作为LMHead的输入</li></ul></li></ul></li><li>topkSample<ul><li></li></ul></li></ul></li></ul></li><li><code>continueTokenGen</code></li></ul></li></ul><h1 id="Lesson29"><a href="#Lesson29" class="headerlink" title="Lesson29"></a>Lesson29</h1><p>提供接受用户输入或者promt的接口<br>实现大封装的API，创建C++类</p><p><code>std::unique_ptr</code></p><ul><li>独占所有权，不能被共享</li><li>自动释放内存</li><li>不可以被复制，所有权可以转让，转让后原来的变为空指针</li></ul><p><code>LLMengine-learn/user_entry.cpp</code></p><ul><li>传入模型和tokenizer的地址，直接调用Response</li></ul><h1 id="debug思路"><a href="#debug思路" class="headerlink" title="debug思路"></a>debug思路</h1><ol><li>打印/保存中间数据：将输出存为一个.bin文件，再使用<code>std::ifstream</code>读取，可以逐一比较(与huggingface的)结果</li></ol><ul><li>fp32两个结果的误差大于$10^{-6}$就说明有误差</li></ul><ol start="2"><li><code>DeviceSynAndCheckCudaError</code></li></ol><ul><li>检查有没有运行时错误</li><li>有<code>cudaDeviceSynchronize()</code>：CPU等待GPU上所有任务完成，因此最好在确保项目没有问题时关掉</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// CMakeList.txt中option(PERF  "measure the model inference performance"  OFF)if(PERF)add_compile_option(-DPRINT_DATA)endif()// context_attention.cpp中#ifndef PERFDeviceSynAndCheckCudaError();#else#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>CMake选项定义：<code>option(选项名称 “选项描述” 默认值)</code></li><li>如果<code>PERF</code>是ON，那么在编译选项中添加<code>-DPRINT_DATA</code>，即在编译时添加一个宏<code>PRINT_DATA</code></li><li><code>cmake .. -DPERF=ON</code>时打开不进行Check(即不打开“检查运行时错误“)</li></ul><ol start="3"><li>PRINT_DATA</li></ol><ul><li>通常在首先输入的kernel里需要，检查放在lanuch里</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>emm配完annaconda之后内存快炸了，查看任务管理器发现是vmmem的问题，是虚拟机资源分配的问题，这个问题上网查解决方法，不复杂</li></ol><ul><li><code>win+R</code>，输入<code>%UserProfile%</code></li><li>如果没有<code>.wslconfig</code>结尾的文件，可以新建一个，可以叫<code>Vmmem.wslconfig</code></li><li>添加以下内容<pre class="line-numbers language-none"><code class="language-none">#.wslconfig[wsl2]memory=3GB //分配给WSL内存，可以是内存的1/3或1/4swap=0     //设置交换分区localhostForwarding=true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>重启WSL：<code>win+R</code>，输入<code>services.msc</code>，找到<code>LxssManager</code>，重新启动</li></ul><ol start="2"><li>这个vmmem好像是个硬骨头啊！<br><a href="https://zhuanlan.zhihu.com/p/166102340">wsl导致vmmem占用高解决办法 - 知乎</a><br>(👆文中借鉴<a href="https://github.com/microsoft/WSL/issues/4166">WSL 2 consumes massive amounts of RAM and doesn’t return it - github.com</a>)<br>按照这个方法做到最后一步发现👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/Pasted%20image%2020241011223651.png" alt="|500"><br>然后就找到了这个方法👇<br><a href="https://bbs.csdn.net/topics/396240104">drop_cashes无法操作 no such file or directory-CSDN社区</a></li></ol><ul><li>先<code>sudo su</code>进入root</li><li>输入<code>echo 3 &gt; /proc/sys/vm/drop_caches</code></li><li>然后再回去<code>sudo stat -c '%y' /root/drop_caches_last_run</code>就能看到清除缓存的记录了</li></ul><ol start="3"><li>vscode疯狂爆红，转clion去了</li></ol><h2 id="软件抽象资源和硬件资源的对应关系"><a href="#软件抽象资源和硬件资源的对应关系" class="headerlink" title="软件抽象资源和硬件资源的对应关系"></a>软件抽象资源和硬件资源的对应关系</h2><p><a href="https://blog.csdn.net/qq_41554005/article/details/119765334">【GPU结构与CUDA系列4】GPU存储资源：寄存器，本地内存，共享内存，缓存，显存等存储器细节_gpu内寄存器 - CSDN</a></p><h2 id="如何高效访问gpu全局内存"><a href="#如何高效访问gpu全局内存" class="headerlink" title="如何高效访问gpu全局内存"></a>如何高效访问gpu全局内存</h2><p>(解答<em>为什么v是按行连续分布和为什么要那样计算qkvgemm</em>)</p><ul><li><p>越靠近CPU排序：寄存器Register &gt; 缓存Cache &gt; 内存Memory &gt; 硬盘</p></li><li><p>“C和CUDA中的多维数组元素是根据<strong>行优先</strong>约定放置在线性寻址的内存空间中的”</p><ul><li>非按行排列：<strong>cublas API</strong>接受的输入以及输出的内存排布全部都默认为<strong>列主序</strong></li></ul></li><li><p>“当线程访问矩阵数据时，如果<strong>数据排列的顺序与线程访问顺序匹配</strong>，内存带宽的利用率会更高”。这里应该和warp有关</p><ul><li>Fused SelfDecoder Attention kernel中，<code>block</code>的大小是<code>head_size</code>，<code>grid</code>的大小是<code>head_num*batch_size</code><br>👇根据线程访问顺序匹配(从blockIdx到threadIdx，threadIdx的跨度是顺序的)<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cache_offset = blockIdx.y * kv_head_num * max_seq_len * head_size +blockIdx.x/(head_num/kv_head_num)*max_seq_len*head_size+threadIdx.x * vec_size;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/c22b854c31b08ae192c8e310cb4a8fa%201.jpg"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/8ea8ba5aa4aa7e6763e069de3b29f14.jpg"></li></ul></li><li><p>一次数据传输的数据量默认情况下是32个字节</p></li><li><p>$合并度=\dfrac{线程束请求的字节数}{由该请求导致的所有数据传输处理的字节数}$</p></li><li><p>数据传输对数据地址的要求：在一次数据传输中，从全局内存转移到L2缓存的一片内存首地址一定是一个最小颗粒度(该例子是32)的整数倍。</p><ul><li>一次传输只取0<del>31、32</del>63、64~95……<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/808198b24f332fb853b67f74add48cd.jpg"><br>👇左行右列导致跨越式的非合并访问<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/LLM2%E6%8E%A8%E7%90%86%E5%BC%95%E6%93%8E/7b1158679c6058fdd34cdd461ad7d17.jpg"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> LLM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA编程：基础与实践学习笔记</title>
      <link href="/2024/08/02/cudac/"/>
      <url>/2024/08/02/cudac/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-CUDA中的线程组织"><a href="#第二章-CUDA中的线程组织" class="headerlink" title="第二章 CUDA中的线程组织"></a>第二章 CUDA中的线程组织</h1><p><code>cudaDeviceSynchronize();</code>：同步主机和设备，(因为调用输出函数时，输出流先放在缓冲区，但是缓冲区不会自动刷新，只有遇到某种同步操作时才会刷新)，如果没有这句话是不会执行核函数的内容</p><p><code>dim3</code>和<code>unit3</code>的区别</p><ul><li><code>unit3</code>：是一个结构体，具有<code>x</code>、<code>y</code>、<code>z</code>三个成员。适用<code>blockIdx</code>和<code>threadIdx</code></li><li><code>dim3</code>：是一个结构体，和<code>unit3</code>类似，适用<code>blockDim</code>和<code>gridDim</code></li><li>二者关系，xxxIdx.a的取值范围是yyyDim.a-1，如：<code>blockIdx.x</code>的取值范围是<code>gridDim.x-1</code></li></ul><h1 id="第三章-简单CUDA程序的基本框架"><a href="#第三章-简单CUDA程序的基本框架" class="headerlink" title="第三章 简单CUDA程序的基本框架"></a>第三章 简单CUDA程序的基本框架</h1><h3 id="3-2-2-设备内存的释放与分配"><a href="#3-2-2-设备内存的释放与分配" class="headerlink" title="3.2.2 设备内存的释放与分配"></a>3.2.2 设备内存的释放与分配</h3><p><code>cudaMalloc()</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">cudaError_t</span> <span class="token function">cudaMalloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>address<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>address</code>：待分配设备内存的指针。因为内存(地址)本身就是一个指针，所以address是指针的指针</li><li><code>size</code>：待分配内存的字节数</li><li><code>cudaError_t</code>：作为返回值，如果调用成功则返回<code>cudaSuccess</code></li><li><code>(void **)</code>：将某一种类型的双重指针变为void类型的双重指针</li><li>功能是改变指针d_x本身的值，即将一个指针赋值给d_x，因此要取d_x的地址，即<code>&amp;d_x</code>，同时该函数不是返回一个指针</li><li>配合<code>cudaFree()</code>函数使用</li></ul><h3 id="3-2-3-主机与设备之间数据的传递"><a href="#3-2-3-主机与设备之间数据的传递" class="headerlink" title="3.2.3 主机与设备之间数据的传递"></a>3.2.3 主机与设备之间数据的传递</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">cudaError_t</span> <span class="token function">cudaMemcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span>               <span class="token comment">// 目标地址</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span>         <span class="token comment">// 源地址</span><span class="token class-name">size_t</span> count<span class="token punctuation">,</span>            <span class="token comment">// 复制数据的字节数</span><span class="token keyword">enum</span> <span class="token class-name">cudaMemcpyKind</span> kind <span class="token comment">// 标志数据传递方向</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cudaMemcpy + <code>Host</code>/<code>Device</code> + To + <code>Device</code>/<code>Host</code><br>或者<code>cudaMemcpyDefault</code></p><h3 id="3-2-4-核函数中数据与线程的对应"><a href="#3-2-4-核函数中数据与线程的对应" class="headerlink" title="3.2.4 核函数中数据与线程的对应"></a>3.2.4 核函数中数据与线程的对应</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __global__ <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>y<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">*</span> blockIdx<span class="token punctuation">.</span>x <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    z<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主机中的add函数需要循环，设备中的不需要，只需要数组元素指标与线程指标一一对应即可，在3.3<code>add1.cu</code>中就用了<code>const int n = blockDim.x * blockIdx.x + blockIdx.x</code>来实现对应关系(而主机中的需要用<code>for(int n=0; n&lt;N; n++)</code>)</p><h3 id="3-2-6-核函数中if语句的必要性"><a href="#3-2-6-核函数中if语句的必要性" class="headerlink" title="3.2.6 核函数中if语句的必要性"></a>3.2.6 核函数中if语句的必要性</h3><p><code>N</code>为数组元素，$grid_size=\dfrac{N}{block_size}$，如果有余数需要+1，此时线程数为<code>N+block_size</code>，因为<code>grid_size</code>每加一，就多一个<code>block</code>，每一个<code>block</code>有<code>block_size</code>个线程，所以此时线程数为<code>N+block_size</code></p><table><thead><tr><th></th><th>原本</th><th>后来</th></tr></thead><tbody><tr><td>N</td><td>$10^8$</td><td>$10^8+1$</td></tr><tr><td>block_size</td><td>128</td><td>128</td></tr><tr><td>grid_size</td><td>$\dfrac{10^8}{128}=781250$</td><td>$\dfrac{10^8}{128}+1=781251$</td></tr><tr><td>实际的线程数$n=block_size*grid_size$</td><td>$10^8$</td><td>$10^8+128$</td></tr><tr><td>因此需要加上<code>if(n&gt;=N) return;</code>，如果不加上这句，会出现非法的设备内存操作</td><td></td><td></td></tr></tbody></table><h1 id="第四章-CUDA程序的错误检验"><a href="#第四章-CUDA程序的错误检验" class="headerlink" title="第四章 CUDA程序的错误检验"></a>第四章 CUDA程序的错误检验</h1><ul><li>在定义宏时，如果一行写不下，则需要在末尾写”\"，表示续行</li><li>用自定义的宏函数<code>CHECK</code>检查运行时API<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240829162039.png"></li><li>用以下两句检查核函数<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaGetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 捕捉第二个语句之前的最后一个错误</span><span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaDeviceSynchronize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 捕捉是否有无法同步主机与设备的错误。因为核函数的调用是异步的，即主机发出调用核函数的命令后会执行后面的语句，不会等待核函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>只要在核函数的调用之后 还有其他任何能<strong>返回错误值的API函数</strong>进行同步调用，都能触发主机与设备的同步并捕捉到核函数调用中可能发生的错误。</li></ul><p>一般情况下，如果需要获得准确的出错位置，需要显式同步。例如调用<code>cudaDeviceSynchronize()</code>函数，或者设置</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">$ export CUDA_LAUNCH_BLOCKING<span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置完毕后，所有核函数的调用都是同步的，但是最好只用于调试程序，因为这样会影响程序的性能。</p><p>❓这个<code>cuda-memcheck</code>没给我check出来错误<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240829164737.png"></p><h1 id="第五章-获得GPU加速的关键"><a href="#第五章-获得GPU加速的关键" class="headerlink" title="第五章 获得GPU加速的关键"></a>第五章 获得GPU加速的关键</h1><h3 id="5-1-1-为C-程序计时"><a href="#5-1-1-为C-程序计时" class="headerlink" title="5.1.1 为C++程序计时"></a>5.1.1 为C++程序计时</h3><p>选择浮点数精度</p><ul><li>单精度浮点数的运行时间👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240829200351.png" alt="单精度浮点数"></li><li>双精度浮点数的运行时间👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240829200445.png" alt="双精度浮点数"></li></ul><h3 id="5-1-2-为CUDA程序计时"><a href="#5-1-2-为CUDA程序计时" class="headerlink" title="5.1.2 为CUDA程序计时"></a>5.1.2 为CUDA程序计时</h3><ol><li>仅核函数</li></ol><ul><li>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240829201703.png"></li><li>双精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240829201718.png"></li></ul><ol start="2"><li>核函数与数据复制</li></ol><ul><li>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240829203507.png"></li><li>双精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240829203524.png"><br>对比是否加入了数据复制的用时，可以发现：</li><li>核函数的运行时间比数据复制时间要短的多，约占2.5%</li><li>如果一个程序的任务仅仅将来自主机端的两个数组相加，再将结果传到主机端，使用GPU的话效率更加低下，(CUDA程序相较于C++程序性能降低</li></ul><p>关于<code>nvprof</code><br>是一个可用于对CUDA程序进行更多性能剖析的CUDA工具箱里的可执行文件，如果设备计算能力大于8.0不可用，输入<code>nsys nvprof</code>可用<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240829205829.png"></p><ul><li>第一列是每类操作(第七列Name)占用时间百分比</li><li>第二列时每类操作所用的时间</li><li>第三列是每类操作被调用的次数</li><li>第四列是每类操作单词调用所用时间的平均值</li><li>第五列和第六列分别是每类操作单次调用所用时间的最小值和最大值</li></ul><h3 id="5-2-1-数据传输的比例"><a href="#5-2-1-数据传输的比例" class="headerlink" title="5.2.1 数据传输的比例"></a>5.2.1 数据传输的比例</h3><p>避免过多的数据经由(连接GPU和CPU)PCIe传递，必须尽量缩减数据传输所花时间的比例(数据在GPU和CPU上传输的时间比计算本身要多的话就得不偿失了)。理论上GPU的显存带宽为几百兆字节，常用的PCIe仅有16GB/s的带宽。</p><p><code>nvcc -O3</code>中的<code>-O3</code>是告诉编译器尽可能多地进行优化</p><h3 id="5-2-2-算数强度"><a href="#5-2-2-算数强度" class="headerlink" title="5.2.2 算数强度"></a>5.2.2 算数强度</h3><p>进行较复杂的浮点运算，可能会得到更高的加速比，于是将之前的数组相加函数进行更改为👇</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">arithmetic</span><span class="token punctuation">(</span>real <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">const</span> real x0<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> n<span class="token operator">&lt;</span>N<span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        real x_tmp <span class="token operator">=</span> x<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x_tmp<span class="token punctuation">)</span> <span class="token operator">&lt;</span> x0<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token operator">++</span>x_tmp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> x_tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>CPU</li></ol><ul><li>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240830164803.png"></li><li>双精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240830164907.png"></li></ul><ol start="2"><li>GPU<br>原本执行程序是<code>.\arithmetic2gpu</code>，因为有<code>const int N = atoi(argv[1]);</code>，所以变成<code>.\arithmetic2gpu N</code>，N可以是任何数字，在命令行中手动输入，将会被读取到程序中的N</li></ol><ul><li>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240830210914.png"></li><li>双精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240830211004.png"></li></ul><h3 id="5-2-3-并行规模"><a href="#5-2-3-并行规模" class="headerlink" title="5.2.3 并行规模"></a>5.2.3 并行规模</h3><p>并行规模可用GPU中总的线程数目来衡量<br>小结：</p><ul><li>数据传输比例小——减少主机与设备之间的数据传输</li><li>核函数的算术强度较高——提高核函数的算术强度</li><li>核函数中定义的线程数目较多——增大核函数的并行规模</li></ul><h1 id="第六章-CPU的组织内存"><a href="#第六章-CPU的组织内存" class="headerlink" title="第六章 CPU的组织内存"></a>第六章 CPU的组织内存</h1><h3 id="6-2-1-全局内存"><a href="#6-2-1-全局内存" class="headerlink" title="6.2.1 全局内存"></a>6.2.1 全局内存</h3><ol><li><p>在核函数中，可直接对静态全局内存变量进行访问，并不需要将它们以参数的形式传给核函数，即：<br>直接访问静态全局内村变量(d_x和d_y[])👇</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__device__ <span class="token keyword">int</span> d_x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>__device__ <span class="token keyword">int</span> d_y<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>__global__ <span class="token keyword">void</span> <span class="token function">my_kernel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    d_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> d_x<span class="token punctuation">;</span> <span class="token comment">// 直接访问</span>    d_y<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> d_x<span class="token punctuation">;</span> <span class="token comment">// 直接访问</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d_x = %d\t d_y[0] = %d\t d_y[1] = %d\n"</span><span class="token punctuation">,</span> d_x<span class="token punctuation">,</span> d_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> d_y<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    my_kernel<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 无需传参</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(d_data和value)作为参数传给核函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__global__ <span class="token keyword">void</span> <span class="token function">myKernel</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    data<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>d_data<span class="token punctuation">;</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token function">cudaMalloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d_data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    myKernel<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> N<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>d_data<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 需要传参(d_data和value)</span>    <span class="token function">cudaFree</span><span class="token punctuation">(</span>d_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>不可在主机函数中直接访问静态全局内存变量，但可以用<code>cudaMemcpyToSymbol()</code>和<code>cudaMemcpyFromSymbol()</code>函数在静态全局内存与主机内存之间传输数据，这两个CUDA运行时API函数如下(symbol指的是静态全局内存变量)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">cudaError_t</span> <span class="token function">cudaMemcpyToSymbol</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> symbol<span class="token punctuation">,</span> <span class="token comment">// 静态全局内存变量名</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> src<span class="token punctuation">,</span>    <span class="token comment">// 主机内存缓冲区指针</span><span class="token class-name">size_t</span> count<span class="token punctuation">,</span>       <span class="token comment">// 复制的字节数</span><span class="token class-name">size_t</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token comment">// 从symbol对应设备地址开始偏移的字节数</span>cudaMemcpyKind kind <span class="token operator">=</span> cudaMemcpyHostToDevice <span class="token comment">// 可选参数</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">cudaError_t</span> <span class="token function">cudaMemcpyFromSymbol</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span>          <span class="token comment">// 主机内存缓冲区指针</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> symbol<span class="token punctuation">,</span> <span class="token comment">// 静态全局内存变量</span><span class="token class-name">size_t</span> count<span class="token punctuation">,</span>       <span class="token comment">// 复制的字节数</span><span class="token class-name">size_t</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token comment">// 从symbol对应设备地址开始偏移的字节数</span>cudaMemcpyKind kind <span class="token operator">=</span> cudaMemcpyDeviceToHost <span class="token comment">// 可选参数</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>特点</p></li></ol><ul><li>所有线程都能访问，全局内存对整个网格的所有线程可见</li><li>没有放在GPU芯片上，具有较高延迟和较低的访问速度；是所有设备中内存最大的，容量基本上就是显存容量</li><li>可读可写</li><li>生命周期：从主机端用<code>cudaMalloc()</code>对他们分配开始，到主机端用<code>cudaFree()</code>释放他们的内存结束</li></ul><h3 id="6-2-2-常量内存"><a href="#6-2-2-常量内存" class="headerlink" title="6.2.2 常量内存"></a>6.2.2 常量内存</h3><ul><li>是有常量缓存的全局内存，仅有64KB</li><li>可读不可写</li><li>(因为有缓存)访问速度比全局内存高，速度高的前提是一个线程束中的线程(一个线程块中相邻的32个线程)要读取相同的常量内存数据</li><li>使用例子：用<code>__constant__</code>定义变量、<code>const int N</code>(这是在主机端定义的变量，通过传值的方式传送给核函数中的线程使用)，核函数对常量内存的访问比对全局内存的访问要快</li><li>给核函数传递的参数存放在常量内存中，最多只能用4KB常量内存</li></ul><h3 id="6-2-4-寄存器"><a href="#6-2-4-寄存器" class="headerlink" title="6.2.4 寄存器"></a>6.2.4 寄存器</h3><p>核函数中定义的且存放在寄存器的有：</p><ul><li>不加任何限定符的变量</li><li>不加任何限定符的数组(也有可能在局部内存中)</li><li>内建变量(如<code>gridDim</code>、<code>blockDim</code>、<code>blockIdx</code>、<code>threadIdx</code>、<code>warpSize</code>等等)<br>寄存器可读可写：</li><li>写入：<code>const int n = blockDim.x * blockIdx.x + threadIdx.x</code>中的<code>n</code>就是一个寄存器变量</li><li>读出：<code>z[n] = x[n] + y[n]</code><br>寄存器变量仅被一个线程可见(以可读可写处代码为例)：</li><li>每个线程都有一个变量<code>n</code>的副本，虽然都是同一个变量名<code>n</code>，但是不同线程中该寄存器变量的值可以不同。而且每个线程只能对它的副本进行读写</li><li>这就是为什么在主机函数中需要用到<code>for</code>循环写入和读出<code>n</code>(<code>for int n=0; n&lt;N; N++</code>和<code>z[n]=x[n]+y[n]</code>)，而核函数只需要<code>const int n = blockDim.x * blockIdx. + threadIdx.x</code>即可定位到不同的<code>n</code>，因为都是副本</li></ul><h3 id="6-2-5-局部内存"><a href="#6-2-5-局部内存" class="headerlink" title="6.2.5 局部内存"></a>6.2.5 局部内存</h3><p>寄存器中放不下的变量、索引值不能在编译时就确定的数组都有可能放在局部内存中</p><h3 id="6-2-6-共享内存"><a href="#6-2-6-共享内存" class="headerlink" title="6.2.6 共享内存"></a>6.2.6 共享内存</h3><ul><li>和寄存器类似，速度仅次于寄存器的读写速度</li><li>共享内存对整个<strong>线程块</strong>可见，每个线程块拥有一个共享内存变量的副本，共享内存变量的值在不同的线程块中可以不同。一个线程块中的所有线程都可以访问该线程块的共享变量副本，但是不能访问其他线程块的共享内存变量副本</li><li>主要作用是减少对全局内存的访问</li></ul><h2 id="6-4-用CUDA运行时API函数查询设备"><a href="#6-4-用CUDA运行时API函数查询设备" class="headerlink" title="6.4 用CUDA运行时API函数查询设备"></a>6.4 用CUDA运行时API函数查询设备</h2><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240831195051.png"></p><h1 id="第七章-全局内存的合理使用"><a href="#第七章-全局内存的合理使用" class="headerlink" title="第七章 全局内存的合理使用"></a>第七章 全局内存的合理使用</h1><h2 id="7-1-全局内存的合并与非合并访问"><a href="#7-1-全局内存的合并与非合并访问" class="headerlink" title="7.1 全局内存的合并与非合并访问"></a>7.1 全局内存的合并与非合并访问</h2><p>$合并度=\dfrac{线程束请求的字节数}{由该请求导致的所有数据传输处理的字节数}$<br><strong>数据传输对数据地址的要求：在一次数据传输中，从全局内存转移到L2缓存的一片内存首地址一定是一个最小颗粒度(本例是32)的整数倍。</strong></p><ol><li>顺序的合并访问<pre class="line-numbers language-c" data-language="c"><code class="language-c">__global__ <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>y<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> n <span class="token operator">=</span> threadIdx<span class="token punctuation">.</span>x <span class="token operator">+</span> blockIdx<span class="token punctuation">.</span>x <span class="token operator">*</span> blcokDim<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    z<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>第一个线程块(blockIdx.x=0)中的线程束将访问数组<code>x</code>中第0~31个元素(每个元素类型为float，占四个字节)，则对应32×4=128字节的连续内存</li><li>首地址一定是256字节的整数倍(使用CUDA运行时API如<code>cudaMalloc</code>分配的内存的首地址至少是256字节的整数倍)</li><li>这样只需要访问4次数据传输即可完成(要求：一次数据传输只能从全局内存读取地址为0<del>31字节、32</del>63字节等片段的数据。如果线程束请求的全局内存数据的地址刚好为0<del>127字节或者128</del>256字节，就能与<strong>4次数据传输</strong>(0<del>31、32</del>63、64<del>95、96</del>127四次)所处理的数据完全吻合)</li><li>合并度为100%</li></ul><ol start="2"><li>乱序的合并访问<pre class="line-numbers language-c" data-language="c"><code class="language-c">__global__ <span class="token keyword">void</span> <span class="token function">add_permuted</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>y<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> tid_permuted <span class="token operator">=</span> threadIdx<span class="token punctuation">.</span>x <span class="token operator">^</span> <span class="token number">0x1</span><span class="token punctuation">;</span><span class="token keyword">int</span> n <span class="token operator">=</span> tid_permuted <span class="token operator">+</span> blockIdx<span class="token punctuation">.</span>x <span class="token operator">*</span> blcokDim<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    z<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li><code>threadIdx.x ^ 0x1</code>异或，将<code>threadIdx.x</code>最后一位翻转</li><li>仅把线程块中奇偶次序调转。如第一个线程块中，原本n的顺序为0、1、2、3…。变为1、0、3、2…，即只不过线程号与数组元素指标不完全一致</li><li>合并度为100%</li></ul><ol start="3"><li>不对齐的非合并访问<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __global__ <span class="token function">add_offset</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>y<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> threadIdx<span class="token punctuation">.</span>x <span class="token operator">+</span> blockIdx<span class="token punctuation">.</span>x <span class="token operator">*</span> blcokDim<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    z<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>add_permuted<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>以第一个线程块为例，第一个线程块中的线程束将访问数组x中第1~32个元素。</li><li>假如数组x的首地址为256，那么<code>x[0]</code>为256<del>259，<code>x[1]</code>为260</del>263，<code>x[32]</code>为382~387</li><li>这将触发5次数据传输，对应的内存地址为256<del>287字节、288</del>319字节、320<del>351字节、352</del>383字节和384~415字节</li><li>合并度为$\dfrac{4}{5}×100=80%$</li></ul><ol start="4"><li>跨越式的非合并访问<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __global__ <span class="token function">add_stride</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> z<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>x <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x <span class="token operator">*</span> gridDim<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    z<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>add_stride<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>第一个线程块中的线程束将访问数组x中指标为<code>0 + threadIdx.x * gridDim.x=1*128、2*128、3*128...</code>的元素</li><li>每一对数据都不在一个连续的32字节的内存片段，因此该线程束的访问将触发32次数据传输</li><li>合并度为$\dfrac{4}{32}×100%=12.5%$</li></ul><ol start="5"><li>广播式的非合并访问<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __global__ <span class="token function">add_broadcast</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> y<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> z<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>x <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x <span class="token operator">*</span> gridDim<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    z<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>add_stride<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>第一个线程块中的线程束将一致地访问数组x中的第0个元素。这实际上只需要一次数据传输(处理32字节的数据)，但整个线程束都在访问同一个内存地址<code>x[0]</code>，只使用了4字节的数据</li><li>合并度为$\dfrac{4}{32}×100%=12.5%$</li></ul><h2 id="7-2-例子：矩阵转置"><a href="#7-2-例子：矩阵转置" class="headerlink" title="7.2 例子：矩阵转置"></a>7.2 例子：矩阵转置</h2><p><code>transpose1()</code>：对矩阵A中数据的访问(读取)是顺序的(/合并的)，对矩阵B中数据的访问(写入)不是顺序的(/非合并的)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>nx <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;</span> N<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        B<span class="token punctuation">[</span>nx <span class="token operator">*</span> N <span class="token operator">+</span> ny<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>ny <span class="token operator">*</span> N <span class="token operator">+</span> nx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240902095334.png" alt="|277"><br><code>transpose2()</code>：对矩阵A中数据的访问(读取)不是顺序的(/非合并的)，对矩阵B中数据的访问(写入)是顺序的(/合并的)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>nx <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;</span> N<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        B<span class="token punctuation">[</span>ny <span class="token operator">*</span> N <span class="token operator">+</span> nx<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>nx <span class="token operator">*</span> N <span class="token operator">+</span> ny<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240902095353.png" alt="|277"><br>可以发现<code>transpose2()</code>的用时比<code>transpose1()</code>的更久？<br>书上原话：</p><ul><li>在不能满足读取和写入都是合并的情况下，一般来说应当尽量做到合并地写入</li><li>书上的结果是2比1用时更短，因为编译器能够判断一个全局内存变量<strong>在整个核函数的范围都只可读</strong>，则会自动用函数<code>__ldg()</code>读取全局内存，从而对数据的读取进行<strong>缓存</strong>，缓解非合并访问带来的影响。而对于全局内存的写入则没有类似的函数可用<br>👇用了别人的代码后<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240902100134.png"></li></ul><h1 id="第八章-共享内存的合理使用"><a href="#第八章-共享内存的合理使用" class="headerlink" title="第八章 共享内存的合理使用"></a>第八章 共享内存的合理使用</h1><h2 id="8-1-例子：数组归约计算"><a href="#8-1-例子：数组归约计算" class="headerlink" title="8.1 例子：数组归约计算"></a>8.1 例子：数组归约计算</h2><ul><li>C++实现计算长度较大的累加计算时，会出现”大数吃小数“的现象</li><li>CUDA实现比C++实现上述内容时要稳健得多<br>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240911215856.png" alt="|325"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240911220431.png" alt="325"><br>上面两个出现大数吃小数的情况</li></ul><table><thead><tr><th>精度</th><th>reduce_global</th><th>reduce_shared</th><th>reduce_dynamic</th><th>结果</th></tr></thead><tbody><tr><td>float</td><td>6~7ms</td><td>7~8ms</td><td>7~9ms</td><td>123633392.000000.</td></tr><tr><td>double</td><td>9~11ms</td><td>15~17ms</td><td>15~18ms</td><td>122999999.998770.</td></tr></tbody></table><p>单精度的结果没有那么离谱，但是离正确答案还有一段距离</p><h3 id="8-1-1-仅使用全局内存"><a href="#8-1-1-仅使用全局内存" class="headerlink" title="8.1.1 仅使用全局内存"></a>8.1.1 仅使用全局内存</h3><ul><li>访问频繁</li><li>使用折半归约法</li><li>假设核函数的网格大小和线程块大小的乘积为<code>N</code></li><li>对于多线程的程序，两个不同线程中指令的执行次序可能和代码中展现的次序不同</li><li>例(循环的前两次)：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 循环的第一次</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> N<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>d_x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+=</span> d_x<span class="token punctuation">[</span>n <span class="token operator">+</span> N<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">// 在这次操作中可能会有向数组d_x[N/4]写入数据的操作；</span><span class="token comment">// 循环的第二次</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> N<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>d_x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+=</span> d_x<span class="token punctuation">[</span>n <span class="token operator">+</span> N<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">// 有可能在线程n=0开始执行这句时，n=N/4还没执行完上一行</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span><span class="token punctuation">]</span>N <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span> N<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> 第一次n<span class="token operator">=</span><span class="token number">0</span><span class="token operator">~</span><span class="token number">3</span><span class="token punctuation">,</span> d_x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> d<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> 等价于 d_x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span><span class="token number">5</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">[</span><span class="token number">6</span> <span class="token number">8</span> <span class="token number">10</span> <span class="token number">12</span><span class="token punctuation">]</span>N<span class="token operator">/</span><span class="token number">4</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> 第二次n<span class="token operator">=</span><span class="token number">0</span><span class="token operator">~</span><span class="token number">1</span><span class="token punctuation">,</span> 可能会出现上面还没加完，就执行这里的情况 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>解决方法：要保证核函数中语句的执行顺序与出现顺序一致，用同步函数<code>__syncthreads()</code><ul><li>只针对一个线程块中的线程(即只能够同步单个线程块中的线程)<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __global__ <span class="token function">reduce_global</span><span class="token punctuation">(</span>real<span class="token operator">*</span> d_x<span class="token punctuation">,</span> real<span class="token operator">*</span> d_y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">int</span> tid <span class="token operator">=</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span>real<span class="token operator">*</span> x <span class="token operator">=</span> d_x <span class="token operator">+</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">*</span> blockIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token comment">// 不同的线程块指向全局内存中的不同地址</span><span class="token comment">// 上面也可以写成 real* x = &amp;d_x[blockDim.x * blockIdx.x];</span><span class="token comment">// d_x是动态数组，数组名就是数组首地址</span><span class="token comment">// 取d_x[blockDim.x + blockIdx.x]的地址等价于首地址+偏移量(bDimx.x+bIdx.x)</span><span class="token comment">// 定义的x在不同的线程块中指向全局内存中的不同地址！</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> offset <span class="token operator">=</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> offset <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> offset <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>tid <span class="token operator">&lt;</span> offset<span class="token punctuation">)</span><span class="token punctuation">{</span>x<span class="token punctuation">[</span>tid<span class="token punctuation">]</span> <span class="token operator">+=</span> x<span class="token punctuation">[</span>tid<span class="token operator">+</span>offset<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">__syncthreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证同一个线程块内地线程按照代码出现地顺序执行命令</span><span class="token punctuation">}</span><span class="token comment">// 上述for循环保证各个线程块内对其中的数据独立地进行归约</span><span class="token keyword">if</span><span class="token punctuation">(</span>tid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>d_y<span class="token punctuation">[</span>blockIdx<span class="token punctuation">.</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">real<span class="token operator">*</span> x <span class="token operator">=</span> d_x <span class="token operator">+</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">*</span> blockIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>==x在不同的线程块中指向全局内存中的不同地址==，可以理解为上面每一个小数组(书上的例子的小数组长度为$10^8$)为一个<code>d_x</code>，不同的线程块对<code>d_x</code>中不同的部分进行归约，(同一个线程块中的线程的处理速度不一致？</li><li>该核函数仅将一个长度为$10^8$的数组<code>d_x</code>归约到一个长度为$\dfrac{10^8}{128}$的数组<code>d_y</code>(书上的操作是把<code>d_y</code>从设备复制到主机里并在主机继续对<code>d_y</code>进行归约得到最终的结果，实际上这样不是很高效)</li><li>利用位操作，将<code>blockDim.x/2</code>和<code>offset/=2</code>分别写成了<code>blockDim.x&gt;&gt;1</code>和<code>offset&gt;&gt;=1</code>，在核函数中，<strong>位操作比对应的整数操作高效</strong>。当所涉及的变量在编译期间就知道其可能的取值，编译器会自动用伪操作取代相应的整数操作</li></ul><h3 id="8-1-2-使用共享内存"><a href="#8-1-2-使用共享内存" class="headerlink" title="8.1.2 使用共享内存"></a>8.1.2 使用共享内存</h3><p>共享内存的主要作用：①减少核函数中对全局内存的访问次数②提高全局访问的合并度<br>共享内存的特点：对整个线程块可见，每个线程块都有一个共享内存变量的副本<br>定义共享内存变量<code>__shared__</code></p><ul><li>在一个核函数中定义一个共享内存变量，就相当于在<strong>每个线程块中有一个该变量的副本</strong>，虽然每个副本共用一个变量名，但是每个副本都不一样</li><li>核函数中，对共享内存变量的操作都是<strong>同时作用在所有的副本上</strong>的<pre class="line-numbers language-c" data-language="c"><code class="language-c">__global__ <span class="token keyword">void</span> <span class="token function">reduce_shared</span><span class="token punctuation">(</span>real <span class="token operator">*</span>d_x<span class="token punctuation">,</span> real <span class="token operator">*</span>d_y<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">int</span> tid <span class="token operator">=</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> bid <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> bid<span class="token operator">*</span>blockDimx<span class="token punctuation">.</span>x <span class="token operator">+</span> tid<span class="token punctuation">;</span>__shared__ real s_y<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 共享内存的数组长度与核函数的执行配置参数blockDim.x一样，如果这里写错了，会引起错误或降低核函数性能</span>s_y<span class="token punctuation">[</span>tid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">&lt;</span>N<span class="token punctuation">)</span> <span class="token operator">?</span> d_x<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">;</span> <span class="token comment">// 将全局内存中的数据复制到共享内存中</span><span class="token function">__syncthreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> offset <span class="token operator">=</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>tid <span class="token operator">&lt;</span> offset<span class="token punctuation">)</span><span class="token punctuation">{</span>s_y<span class="token punctuation">[</span>tid<span class="token punctuation">]</span> <span class="token operator">+=</span> s_y<span class="token punctuation">[</span>tid <span class="token operator">+</span> offset<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">__syncthreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>tid<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>d_y<span class="token punctuation">[</span>tid<span class="token punctuation">]</span> <span class="token operator">=</span> s_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/345a4268a6a5f1d9ad0e183fb311f40.jpg"></li><li>一般来说，在核函数中对共享内存访问的次数越多，则由于使用共享内存带来的加速效果越明显</li><li>因为有<code>n&lt;N</code>的判断，该函数能够处理<code>N</code>不是线程块大小的整数倍的情形</li></ul><h3 id="8-1-3-使用动态共享内存"><a href="#8-1-3-使用动态共享内存" class="headerlink" title="8.1.3 使用动态共享内存"></a>8.1.3 使用动态共享内存</h3><p>使用动态共享内存可以减少8.1.2中“<strong>共享内存的数组长度</strong>与核函数的执行配置参数需与<strong>blockDim.x</strong>一样，如果这里写错了，会引起错误或降低核函数性能”错误发生的概率</p><p>将静态内存改为动态内存的修改：</p><ul><li><code>&lt;&lt;&lt;grid_size, block_size, sizeof(real) * block_size&gt;&gt;&gt;</code>，第三个参数就是核函数中每个线程块需要定义的动态共享内存的字节数</li><li>改变核函数中共享内存变量的声明方式<ul><li>静态：<code>__shared__ real s_y[128];</code></li><li>动态：`extern <strong>shared</strong> real s_y[];</li></ul></li></ul><p>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240919200305.png" alt="|375"><br>双精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240919200331.png" alt="375"></p><h2 id="8-2-使用共享内存进行矩阵转置"><a href="#8-2-使用共享内存进行矩阵转置" class="headerlink" title="8.2 使用共享内存进行矩阵转置"></a>8.2 使用共享内存进行矩阵转置</h2><p>利用共享内存可以改善全局内存的访问模式，使得对全局内存的读和写都是合并的</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__gobal__ <span class="token keyword">void</span> <span class="token function">transpose1</span><span class="token punctuation">(</span><span class="token keyword">const</span> real <span class="token operator">*</span>A<span class="token punctuation">,</span> real <span class="token operator">*</span>B<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>__shared__ real S<span class="token punctuation">[</span>TILE_DIM<span class="token punctuation">]</span><span class="token punctuation">[</span>TILE_DIM<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用一个线程块处理一片32x32的矩阵</span><span class="token keyword">int</span> bx <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>x <span class="token operator">*</span> TILE_DIM<span class="token punctuation">;</span><span class="token keyword">int</span> by <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>y <span class="token operator">*</span> TILE_DIM<span class="token punctuation">;</span><span class="token keyword">int</span> nx1 <span class="token operator">=</span> bx <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token keyword">int</span> ny1 <span class="token operator">=</span> by <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>nx1 <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> ny1 <span class="token operator">&lt;</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>S<span class="token punctuation">[</span>threadIdx<span class="token punctuation">.</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>ny1 <span class="token operator">*</span> N <span class="token operator">+</span> nx1<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 因为相邻的threadIdx.x与全局内存中相邻的数据对应，所以这里对全局内存的访问是合并的</span><span class="token punctuation">}</span><span class="token function">__syncthreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> nx2 <span class="token operator">=</span> bx <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token keyword">int</span> ny2 <span class="token operator">=</span> by <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>nx2 <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> ny2 <span class="token operator">&lt;</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>B<span class="token punctuation">[</span>nx2 <span class="token operator">*</span> N <span class="token operator">+</span> ny2<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">[</span>threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>threadIdx<span class="token punctuation">.</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码的节选部分👇</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> nx2 <span class="token operator">=</span> bx <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token keyword">int</span> ny2 <span class="token operator">=</span> by <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token comment">// 上面这两行改变了对全局内存的访问方式</span><span class="token comment">// 这里的bx和by根据blockIdx.x和blockIdx.y的变化而变化。可以视为某个线程块在全局中的偏移量</span><span class="token keyword">if</span><span class="token punctuation">(</span>nx2 <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> ny2 <span class="token operator">&lt;</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>B<span class="token punctuation">[</span>nx2 <span class="token operator">*</span> N <span class="token operator">+</span> ny2<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">[</span>threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>threadIdx<span class="token punctuation">.</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 相邻的threadIdx.x与全局内存中的数组B中的相邻的数据对应</span><span class="token comment">//B的相邻是ny2，ny2又和threadIdx.x一致相邻</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第七章<code>transpose1()</code>相关部分👇</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__global__ <span class="token keyword">void</span> <span class="token function">transpose1</span><span class="token punctuation">(</span><span class="token keyword">const</span> real<span class="token operator">*</span> A<span class="token punctuation">,</span> real<span class="token operator">*</span> B<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> nx <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>x <span class="token operator">*</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> ny <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>y <span class="token operator">*</span> blockDim<span class="token punctuation">.</span>y <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nx <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;</span> N<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        B<span class="token punctuation">[</span>nx <span class="token operator">*</span> N <span class="token operator">+</span> ny<span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>ny <span class="token operator">*</span> N <span class="token operator">+</span> nx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跟上面代码一样的写法👇</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> nx2 <span class="token operator">=</span> bx <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token keyword">int</span> ny2 <span class="token operator">=</span> by <span class="token operator">+</span> threadIdx<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token comment">// 这样子定义nx2和ny2的话和上面全局内存的访问方式一样</span><span class="token keyword">if</span><span class="token punctuation">(</span>nx2 <span class="token operator">&lt;</span> N <span class="token operator">&amp;&amp;</span> ny2 <span class="token operator">&lt;</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>B<span class="token punctuation">[</span>nx2 <span class="token operator">*</span> N <span class="token operator">+</span> ny2<span class="token punctuation">]</span> <span class="token operator">=</span> S<span class="token punctuation">[</span>threadIdx<span class="token punctuation">.</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-3-避免共享内存的bank冲突"><a href="#8-3-避免共享内存的bank冲突" class="headerlink" title="8.3 避免共享内存的bank冲突"></a>8.3 避免共享内存的bank冲突</h2><p>为了获得高的内存带宽，共享内存在物理上被分为32个(刚好等于一个线程束中的线程数目32)同样宽度的、能被同时访问的内存bank</p><ul><li>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240913182434.png" alt="|350"></li><li>双精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240913182530.png" alt="|350"><br><code>bank</code>宽度为4字节的架构，$\dfrac{128字节(定义的共享内存数组的大小)}{32bank(大小和一个线程束中的线程数目相同)}=4字节/bank$</li><li>只要同一个线程束内的多个线程<strong>不同时</strong>访问同一个<code>bank</code>中不同层的数据，该线程束对共享内存的访问就只需要<strong>一次</strong>内存事务</li><li>当同一线程的多个线程数试图访问同一个<code>bank</code>中不同层(n层)的数据(将导致n次内存事务)，会发生bank冲突(n路bank冲突)</li><li>上面的<code>transpose with shared memory bank conflit</code>是发生了32路bank冲突<ul><li><code>B[nx2 * N + ny2] = S[threadIdx.x][threadIdx.y]</code></li><li>同一个线程束的32个线程(连续的32个<code>threadIdx.x</code>值)对应<code>S</code>中跨度为32的数据(<code>[threadIdx.y]</code>)</li></ul></li><li>于是将<code>__shared__ real S[TILE_DIM][TILE_DIM]</code>改为<code>__shared__ real S[TILE_DIM][TILE_DIM + 1]</code><ul><li>同一个线程束的32个线程(连续的32个<code>threadIdx.x</code>)对应<code>S</code>中跨度为33的数据</li><li>如果第一个线程访问第一个<code>bank</code>的第一层，第二个线程则会访问第二个<code>bank</code>的第二层，而不是第一个<code>bank</code>的第二层，以此类推，没有<code>bank</code>冲突<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E6%A1%A3_1.jpg"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E6%A1%A3_2.jpg"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E6%A1%A3_3.jpg"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E6%A1%A3_4.jpg"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E6%A1%A3_5.jpg"></li></ul></li></ul><h1 id="第九章-原子函数的合理使用"><a href="#第九章-原子函数的合理使用" class="headerlink" title="第九章 原子函数的合理使用"></a>第九章 原子函数的合理使用</h1><h2 id="9-1-完全在GPU中进行归约"><a href="#9-1-完全在GPU中进行归约" class="headerlink" title="9.1 完全在GPU中进行归约"></a>9.1 完全在GPU中进行归约</h2><ul><li>本书使用在先前的核函数的末尾利用<strong>原子函数</strong>进行归约直接得到最终的结果的方法</li><li>不能使用👇的原因：不管每个线程块第0号线程的执行次序如何，只有当一个线程的“读-写”操作不被其他线程干扰时，才能得到正确结果<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>tid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>d_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> s_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>如果存在两个线程块第0号线程同时读取d_y[0]的值，那结果就是错误的</li><li>原子函数<code>atomicAdd(address, val)</code>：<ul><li>第一个参数是待累加的变量的地址</li><li>第二个参数是累加的值</li><li>“在调用该版本的核函数之前，必须将<code>d_y[0]</code>的值初始化为0”</li><li>👇<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>tid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// threadIdx.x = 0，保证每个线程块的s_y[0]只累加一次</span><span class="token punctuation">{</span><span class="token function">atomicAdd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> s_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//&amp;d_y[0]可以写成d_y(数组名是数组首个元素的地址)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>代码中：<br><code>d_x</code>是长度为<code>M</code>的数组、<code>N</code>为元素个数</li></ul></li><li>初始化<code>h_x</code>，复制给<code>d_x</code></li><li><strong><code>timing(d_x)</code>：</strong><ul><li>重复<code>NUM_REPEATS</code>次</li><li>创建事件、计时、查询</li><li><strong><code>reduce(d_x)</code>、</strong><ul><li>定义网格大小</li><li><code>h_y[1]</code>作用是传一个初始值为0的值给<code>d_y</code>，满足<code>d_y[0]</code>的值初始化为0的要求<ul><li><strong><code>reduce(d_x, d_y, N)</code>：动态内存<code>&lt;&lt;&lt;grid_size, block_size, sizeof(real) * block_size&gt;&gt;&gt;</code></strong><ul><li>使用动态内存进行折半相加</li><li>使用<code>atomicAdd</code>对每个线程块的首个元素相加得到最终结果</li></ul></li></ul></li><li>将结果从<code>d_y</code>复制回<code>h_y</code>中</li><li>释放内存</li></ul></li><li>结束计时，打印计时结果和最后一次的求和结果</li></ul></li><li>释放<code>d_x</code>和<code>h_x</code>的内存</li></ul><p>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240919200542.png" alt="375"><br>双精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240919200554.png" alt="375"><br>确实是比先前的提升约2ms</p><h2 id="9-3-例子：邻居列表的建立"><a href="#9-3-例子：邻居列表的建立" class="headerlink" title="9.3 例子：邻居列表的建立"></a>9.3 例子：邻居列表的建立</h2><p><code>MN</code>是每个原子的最多邻居原子数<br><code>NN[n]</code>是第n个粒子的邻居个数<br><code>NL[n * MN + k]</code>是第n个粒子的第k个邻居的指标</p><h3 id="9-3-1-C-版本的开发"><a href="#9-3-1-C-版本的开发" class="headerlink" title="9.3.1 C++版本的开发"></a>9.3.1 C++版本的开发</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">find_neighbor</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>NN<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>NL<span class="token punctuation">,</span> <span class="token keyword">const</span> real<span class="token operator">*</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> real<span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        NN<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">// n1和n2代表两个可能互为邻居的原子</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n1 <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>n1<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        real x1 <span class="token operator">=</span> x<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">;</span>        real y1 <span class="token operator">=</span> y<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n2 <span class="token operator">=</span> n1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> n2 <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>n2<span class="token punctuation">)</span> <span class="token comment">// 因为n1和n2互为邻居，所以只考虑n2&gt;n1的情形</span>        <span class="token punctuation">{</span>            real x12 <span class="token operator">=</span> x<span class="token punctuation">[</span>n2<span class="token punctuation">]</span> <span class="token operator">-</span> x1<span class="token punctuation">;</span>            real y12 <span class="token operator">=</span> y<span class="token punctuation">[</span>n2<span class="token punctuation">]</span> <span class="token operator">-</span> y1<span class="token punctuation">;</span>            real distance_square <span class="token operator">=</span> x12 <span class="token operator">*</span> x12 <span class="token operator">+</span> y12 <span class="token operator">*</span> y12<span class="token punctuation">;</span> <span class="token comment">// </span>            <span class="token keyword">if</span><span class="token punctuation">(</span>distance_square <span class="token operator">&lt;</span> cutoff_square<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                NL<span class="token punctuation">[</span>n1 <span class="token operator">*</span> MN <span class="token operator">+</span> NN<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n2<span class="token punctuation">;</span> <span class="token comment">// 先添加邻居信息，再对邻居个数++</span>                NL<span class="token punctuation">[</span>n2 <span class="token operator">*</span> MN <span class="token operator">+</span> NN<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n1<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-3-2-利用原子操作的CUDA版本"><a href="#9-3-2-利用原子操作的CUDA版本" class="headerlink" title="9.3.2 利用原子操作的CUDA版本"></a>9.3.2 利用原子操作的CUDA版本</h3><p>如果仍然使用9.3.1中的<code>find_neighbor</code>函数，会导致“<strong>并发写入冲突</strong>”<br>一个线程与一个原子对应</p><ul><li>与n1对应的线程👇<pre class="line-numbers language-c" data-language="c"><code class="language-c">d_NL<span class="token punctuation">[</span>n1 <span class="token operator">*</span> MN <span class="token operator">+</span> NN<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n2<span class="token punctuation">;</span> d_NL<span class="token punctuation">[</span>n2 <span class="token operator">*</span> MN <span class="token operator">+</span> NN<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n1<span class="token punctuation">;</span> <span class="token comment">// 第二条语句</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>与n2对应的线程👇<pre class="line-numbers language-c" data-language="c"><code class="language-c">d_NL<span class="token punctuation">[</span>n2 <span class="token operator">*</span> MN <span class="token operator">+</span> NN<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n1<span class="token punctuation">;</span> <span class="token comment">// 第一条语句</span>d_NL<span class="token punctuation">[</span>n1 <span class="token operator">*</span> MN <span class="token operator">+</span> NN<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>书上原话“在与<code>n1</code>对应的线程中，第二条语句代表我们试图对<code>d_NN[n2]</code>进行累加操作。但是，在与<code>n2</code>对应的线程中，第一条语句代表我们也试图对<code>d_NN[n2]</code>进行累加操作”<br>需要用原子函数：<pre class="line-numbers language-c" data-language="c"><code class="language-c">d_NL<span class="token punctuation">[</span>n1 <span class="token operator">*</span> MN <span class="token operator">+</span> d_NN<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n2<span class="token punctuation">;</span>d_NL<span class="token punctuation">[</span>n2 <span class="token operator">*</span> MN <span class="token operator">+</span> d_NN<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>合理利用返回值：<br>可以将👇代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">NL<span class="token punctuation">[</span>n1 <span class="token operator">*</span> MN <span class="token operator">+</span> NN<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n2<span class="token punctuation">;</span>NL<span class="token punctuation">[</span>n2 <span class="token operator">*</span> MN <span class="token operator">+</span> NN<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>改写为👇</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">NL<span class="token punctuation">[</span>n1 <span class="token operator">*</span> MN <span class="token operator">+</span> NN<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> n2<span class="token punctuation">;</span>NN<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>NL<span class="token punctuation">[</span>n2 <span class="token operator">*</span> MN <span class="token operator">+</span> NN<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> n1<span class="token punctuation">;</span>NN<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但如果类似地改写原子函数的代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">d_NL<span class="token punctuation">[</span>n1 <span class="token operator">*</span> MN <span class="token operator">+</span> <span class="token function">atomicAdd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d_NN<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> n2<span class="token punctuation">;</span>d_NL<span class="token punctuation">[</span>n2 <span class="token operator">*</span> MN <span class="token operator">+</span> <span class="token function">atomicAdd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d_NN<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> n1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>👆改写为👇</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">d_NL<span class="token punctuation">[</span>n1 <span class="token operator">*</span> MN <span class="token operator">+</span> d_NN<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> n2<span class="token punctuation">;</span><span class="token function">atomicAdd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d_NN<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d_NL<span class="token punctuation">[</span>n2 <span class="token operator">*</span> MN <span class="token operator">+</span> d_NN<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> n1<span class="token punctuation">;</span><span class="token function">atomicAdd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d_NN<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>原子函数的操作本身是立即生效的，且在原子操作的执行过程中其他线程无法同时修改该变量</li><li>不同的线程可能会同时访问<code>d_NN[n1]</code>和<code>d_NN[n2]</code>，如果两个线程几乎同时执行对 <code>d_NN[n1]</code> 的 <code>atomicAdd</code> 操作，那么尽管操作本身是原子的，它们的执行顺序却是不确定的，一个线程可能在另一个线程更新<code>d_NN[n1]</code>之前就读到了该值<br>正确写法👇<pre class="line-numbers language-none"><code class="language-none">int tmp1 = atomicAdd(&amp;d_NN[n1], 1);d_NL[n1 * MN + tmp1] = n2;int tmp2 = atomicAdd(&amp;d_NN[n2], 1);d_NL[n2 * MN + tmp1] = n1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>使用临时变量<code>tmp1</code>和<code>tmp2</code>保存<code>d_NN[n1]</code>和<code>d_NN[n2]</code>的旧值</li></ul><p>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240921115244.png" alt="375"><br>双精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240921115308.png" alt="375"></p><p>在核函数<code>find_neighbor_no_atomic</code>中，<br>①将<code>d_NL[n1 * MN + count++]</code>改为<code>d_NL[(count++) * N + n1]</code><br>②<code>const int n1 = blockIdx.x * blockDim.x + threadIdx.x;</code></p><ul><li>前者的索引中：每个线程的地址跨度为<code>MN</code></li><li>后者的索引中：每个线程在每次循环时访问相邻的内存位置</li></ul><p>对于<code>find_neighbor_not_atomic</code><br>①将<code>if((distance_square) &lt; cutoff_square &amp;&amp; (n2 != n1))</code><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240921115244.png" alt="375"><br>改为<code>if((n2 != n1) &amp;&amp; (distance_square) &lt; cutoff_square)</code>，用时变多<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240921170942.png" alt="375"></p><p>对比使用寄存器变量与不使用寄存器变量<br>使用👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240921115244.png" alt="375"><br>不使用👇，用时变多<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240921171012.png" alt="375"></p><h1 id="第十章-线程束基本函数与协作组"><a href="#第十章-线程束基本函数与协作组" class="headerlink" title="第十章 线程束基本函数与协作组"></a>第十章 线程束基本函数与协作组</h1><h2 id="10-1-单指令-多线程执行模式"><a href="#10-1-单指令-多线程执行模式" class="headerlink" title="10.1 单指令-多线程执行模式"></a>10.1 单指令-多线程执行模式</h2><p>并发和同步：</p><ul><li>并发：侧重任务的(逻辑)同时进行，在同一段时间内<strong>多个任务交替进行</strong></li><li>同步：侧重控制人物的执行顺序，保证它们在合适的时刻访问共享资源</li></ul><p>单指令-多线程：同一时刻，一个线程束中的线程只能执行一个共同的指令或者闲置<br>分治发散：一个线程束中的线程顺序地执行判断语句中的不同分支(分支是依次执行的)</p><p>一个SM可以处理一个或多个线程块，一个线程块不会被分配到不同的SM中<br>一个线程块可以氛围若干线程束</p><h2 id="10-3-更多线程束内的基本函数"><a href="#10-3-更多线程束内的基本函数" class="headerlink" title="10.3 更多线程束内的基本函数"></a>10.3 更多线程束内的基本函数</h2><p><code>mask</code>为掩码，是一个32位的无符号整数，用于指定要参与计算的线程，掩码中的一个二进制位为0/1代表对应的线程参与/不参与计算<br>①<code>__ballot_sync(mask, predicate)</code>：返回一个新的掩码</p><ul><li><code>mask</code>先决定线程束内第n(n=1~32)个线程是否参与计算(0/1)</li><li><code>predicate</code>用于判断参与计算的线程是否满足条件，如果满足则该线程对应的<code>predicate</code>为1，对应的<code>mask</code>取1的比特位，否则对应的<code>predicate</code>为0，对应的<code>mask</code>取0</li></ul><p>②<code>__all_sync(mask, predicate)</code>：返回0/1</p><ul><li>线程束内所有参与的线程对应的<code>predicate</code>值都不为0才返回1，否则返回0</li><li>类似于选举操作，所有参选人都同意时通过<ul><li>例：<code>int result = __all_sync(FULL_MASK, tid);</code>如果所有线程的 <code>tid</code> 都为真（非零），函数返回 1，表示条件对所有线程都满足；否则返回 0，表示至少有一个线程的 <code>tid</code> 为零。</li></ul></li></ul><p>③<code>__any_sync(mask, predicate)</code>：返回0/1</p><ul><li>线程束内所有参与的线程对应的<code>predicate</code>值只要有一个不为0就返回1，如果全是0才返回0</li><li>类似选举操作，只要有一个参选人同意就通过</li></ul><p>④<code>__shfl_sync(mask, var, srcLane, width);</code>每个子组中参与的线程获取<code>land_id</code>为<code>srcLane</code>的线程中的变量</p><ul><li><code>land_id = threadIdx.x % w; = threadIdx.x &amp; (w - 1);</code></li><li><code>mask</code>：表示线程束内参与的线程</li><li><code>var</code>：表示当前线程的变量</li><li><code>srcLane</code>：表示从哪个线程索引读取<code>v</code>的值</li><li><code>width</code>：表示参与这个<code>shuffle</code>操作的<code>warp</code>的宽度<ul><li>例：<code>__shfl_sync(FULL_MASK, tid, 2, 8)</code><ul><li><code>8</code>表示<code>__shfl_sync()</code>操作只在8个线程的小组中进行，对于32线程的<code>wrap</code>，线程被分为4组有8个线程的子组(0-7, 8-15, 16-23, 24-31)</li><li><code>2</code>表示源线程索引，每个线程都会读取第2号线程的<code>tid</code>值并存到<code>value</code>变量中</li><li><code>tid</code>表示每个线程的局部变量</li></ul></li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">__global__ <span class="token keyword">void</span> <span class="token function">shuffleExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tid <span class="token operator">=</span> threadIdx<span class="token punctuation">.</span>x <span class="token operator">%</span> <span class="token number">32</span><span class="token punctuation">;</span>  <span class="token comment">// 假设每个线程的tid是线程索引（0~31）</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token function">__shfl_sync</span><span class="token punctuation">(</span><span class="token number">0xFFFFFFFF</span><span class="token punctuation">,</span> tid<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %d got value %d\n"</span><span class="token punctuation">,</span> tid<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//打印结果👇</span>Thread <span class="token number">0</span> got value <span class="token number">2</span>Thread <span class="token number">1</span> got value <span class="token number">2</span>Thread <span class="token number">2</span> got value <span class="token number">2</span>Thread <span class="token number">3</span> got value <span class="token number">2</span>Thread <span class="token number">4</span> got value <span class="token number">2</span>Thread <span class="token number">5</span> got value <span class="token number">2</span>Thread <span class="token number">6</span> got value <span class="token number">2</span>Thread <span class="token number">7</span> got value <span class="token number">2</span>Thread <span class="token number">8</span> got value <span class="token number">10</span>Thread <span class="token number">9</span> got value <span class="token number">10</span>Thread <span class="token number">10</span> got value <span class="token number">10</span>Thread <span class="token number">11</span> got value <span class="token number">10</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Thread <span class="token number">30</span> got value <span class="token number">26</span>Thread <span class="token number">31</span> got value <span class="token number">26</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将一个线程中的数据广播到所有(包括自己)线程</li></ul><p>⑤<code>__shfl_up_sync(mask, var, delta, width);</code></p><ul><li><code>delta</code>：表示每个线程从前面多少个线程处获取数据</li><li><code>width</code>：决定了<code>warp</code>内的分组范围，通信只在指定大小的组内进行<ul><li>例：<code>__shfl_up_sync(mask, var, 1, 8);</code></li></ul></li><li><code>vat</code>：决定获取的数据来源</li></ul><table><thead><tr><th>线程ID</th><th>tid</th><th>执行后的tid</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>2</td><td>2</td><td>1</td></tr><tr><td>3</td><td>3</td><td>2</td></tr></tbody></table><ul><li>是一种将数据向上平移的操作</li></ul><p>⑥<code>__shfl_down_sync(mask, var, delta, width);</code></p><ul><li>是一种将数据向下平移的操作</li></ul><p>⑦<code>__shfl_xor_sync(mask, var, landMask, width);</code><br>线程<code>i</code>与线程<code>i ^ landMask</code>(这里表示异或)交换数据<br>例子：<code>landMask=1</code>、<code>width=8</code></p><table><thead><tr><th>线程ID</th><th>tid</th><th>执行后的tid</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>2</td><td>2</td><td>3</td></tr><tr><td>3</td><td>3</td><td>2</td></tr><tr><td>4</td><td>4</td><td>5</td></tr><tr><td>5</td><td>5</td><td>4</td></tr><tr><td>6</td><td>6</td><td>7</td></tr><tr><td>7</td><td>7</td><td>6</td></tr><tr><td>8</td><td>8</td><td>9</td></tr><tr><td>9</td><td>9</td><td>8</td></tr><tr><td>10</td><td>10</td><td>11</td></tr><tr><td>11</td><td>11</td><td>10</td></tr><tr><td>12</td><td>12</td><td>13</td></tr><tr><td>13</td><td>13</td><td>12</td></tr><tr><td>14</td><td>14</td><td>15</td></tr><tr><td>15</td><td>15</td><td>14</td></tr><tr><td>以<code>__shlf</code>开头的函数为洗牌函数，好处是<strong>使得线程束中的线程彼此之间可以直接交换数据，而不是通过共享内存或全局内存来进行的</strong>。洗牌指令比共享内存有更低的延迟，并且该指令在执行数据交换时不消耗额外的内存</td><td></td><td></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240922162221.png"></p><ul><li><code>all_sync(FULL_MASK):0</code>，线程0的<code>tid</code>为0，不是全部参与的线程的<code>predicate</code>值都为1，所以为0</li><li><code>all_sync(mask1):1</code>，线程0没有参与，全部参与的线程的<code>predicate</code>值都为1，所以为1</li><li><code>any_sync(FULL_MASK):1</code>，线程0的<code>tid</code>为0，只要参与的线程的<code>predicate</code>值至少有一个为1则为1，所以为1</li><li><code>any_sync(mask2):1</code>，线程0的<code>tid</code>为0，参与的线程的只有线程0，<code>predicate</code>值只有0，所以为0</li></ul><h3 id="10-3-2-利用线程束洗牌函数进行规约计算"><a href="#10-3-2-利用线程束洗牌函数进行规约计算" class="headerlink" title="10.3.2 利用线程束洗牌函数进行规约计算"></a>10.3.2 利用线程束洗牌函数进行规约计算</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">real y <span class="token operator">=</span> s_y<span class="token punctuation">[</span>tid<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 将共享内存中的数据复制到寄存器，在线程束内使用洗牌函数进行归约时，不需要明显地使用共享内存</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span> offset <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> offset <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>y <span class="token operator">+=</span> <span class="token function">__shfl_down_sync</span><span class="token punctuation">(</span>FULL_MASK<span class="token punctuation">,</span> y<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// y是读取的值，offset是向后移的个数</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>tid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">atomicAdd</span><span class="token punctuation">(</span>d_y<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>👆理解：</p><ul><li>将共享内存中的数据复制到寄存器，在线程束内使用洗牌函数进行归约时，不需要明显地使用共享内存</li><li>洗牌函数先读取各个线程中y的值，再将洗牌操作的结果写入各个线程的y中<ul><li>假设<code>y(tid = n) = n</code><ul><li>`offset=16<ul><li><code>y(tid=0) += __shfl_down_sync(FULL_MASK, y(tid=0), offset);</code><ul><li><code>y(tid=0) = 0</code></li><li><code>__shfl_down_sync() -&gt; y(tid=0)' = y(tid=16) = 16</code>，<code>'</code>表示后来的</li><li><code>y(tid=0) = y(tid=0) + y(tid=0)' = 0 + 16 = 16</code></li></ul></li><li><code>y(tid=1) = 1 + 17 = 18</code></li><li>…</li><li><code>y(tid=15) = 15 + 31 = 46</code></li></ul></li><li><code>offset=8</code><ul><li><code>y(tid=0) = y(tid=0) + y(tid=7)</code></li><li>…</li></ul></li><li><code>offset=1</code><ul><li><code>y(tid=0) = y(tid=0) + y(tid=1)</code></li></ul></li></ul></li></ul></li></ul><h2 id="10-4-协作组"><a href="#10-4-协作组" class="headerlink" title="10.4 协作组"></a>10.4 协作组</h2><p>协作组：看作线程块和线程束同步机制的推广</p><ul><li>使用协作组的功能时需要在相关源文件包含如下头文件：<br><code>#include&lt;cooperative_groups.h&gt;</code></li><li>导入命名空间<code>cooprtative_groups</code>中的内容：<br><code>using namespace cooperative_groups;</code></li></ul><p>定义并初始化一个<code>thread_block</code>对象：<br><code>thread_block g = this_thread_block();</code>，<code>g</code>就代表了线程块</p><ul><li>等价关系：</li><li><code>g.sync()</code>↔<code>__syncthreads()</code></li><li><code>g.group_index()</code>↔<code>blockIdx</code></li><li><code>g.thread_index()</code>↔<code>threadIdx</code></li></ul><p><code>tiled_partition()</code>将一个线程块分为若干片(<code>tile</code>)，每一片构成一个新的线程组，大小只能是2、4、8、16、32</p><ul><li>模板化：<br><code>thread_block_tile&lt;32&gt; g32 = tiled_partition&lt;32&gt;(this_thread_block());</code><br><code>thread_block_tile&lt;4&gt; g4 = tiled_partition&lt;4&gt;(this_thread_block());</code><br>这样定义的线程组称为<strong>线程块片</strong>，线程块片函数不同的地方：</li><li>线程组内的所有线程都必须参与相关函数的运算</li><li>宽度就是线程块片的大小</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">real y <span class="token operator">=</span> s_y<span class="token punctuation">[</span>tid<span class="token punctuation">]</span><span class="token punctuation">;</span>thread_block_tile<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">&gt;</span> g <span class="token operator">=</span> tiled_partition<span class="token operator">&lt;</span><span class="token number">32</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function">this_thread_block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    y <span class="token operator">+=</span> g<span class="token punctuation">.</span><span class="token function">shfl_down</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>tid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">atomicAdd</span><span class="token punctuation">(</span>d_y<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把线程划分32个线程一组的，其他的与洗牌函数的步骤差不多，只是使用的方法不一样，所以他们两种方法的用时也差不多</p><p>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240922220201.png" alt="275"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240922220210.png" alt="275"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240922220219.png" alt="275"><br>双精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240922220240.png" alt="275"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240922220254.png" alt="275"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240922220302.png" alt="275"></p><h2 id="10-5-数组规约程序的进一步优化"><a href="#10-5-数组规约程序的进一步优化" class="headerlink" title="10.5 数组规约程序的进一步优化"></a>10.5 数组规约程序的进一步优化</h2><h3 id="10-5-1-提高线程利用率"><a href="#10-5-1-提高线程利用率" class="headerlink" title="10.5.1 提高线程利用率"></a>10.5.1 提高线程利用率</h3><p>“如果能够提高归约之前所做计算的比例，则应该可以从整体上升对线程的利用率…，可以在归约之前将多个全局内存数组的数据累加到一个共享内存数组的一个元素中”</p><p>“不要让一个线程处理相邻的若干数据，因为这必然导致全局内存的非合并访问”，如何理解这句话(这句话本人读了好一会才理明白)：</p><ul><li>什么是合并访问？<ul><li>$合并度=\dfrac{线程束请求的字节数}{由该请求导致的所有数据传输处理的字节数}$</li><li>合并访问就是合并度100%的情况，注意：线程的组织情况是以线程束为单位</li></ul></li><li>为什么一个线程处理会导致非合并<ul><li>(以下是带有主观的解释)一个线程处理相邻的数据，如</li><li><code>tid=0 -&gt; 访问 d_x[0], d_x[1], d_x[2], d_x[3]</code></li><li><code>tid=1 -&gt; 访问 d_x[4], d_x[5], d_x[6], d_x[7]</code></li><li>在一个线程束内，每一时刻每个线程访问的数据不是连续的(<code>d_x[tid * 4]</code>)，数据的传输的首地址某个最小颗粒度的倍数</li><li>假设需要请求的数据为<code>d_x[0]~d_x[31]</code>，每个元素大小为4字节，某个最小颗粒度为32</li><li>在第一个时刻中，<code>tid = 0 -&gt; 0 ... tid = 7 -&gt; 28</code></li><li>在第二个时刻中，<code>tid = 0 -&gt; 1 ... tid = 7 -&gt; 29</code></li><li>在第三个时刻中，<code>tid = 0 -&gt; 2 ... tid = 7 -&gt; 30</code></li><li>在第四个时刻中，<code>tid = 0 -&gt; 3 ... tid = 7 -&gt; 31</code></li><li>$合并度=\dfrac{线程束请求的字节数}{由该请求导致的所有数据传输处理的字节数}=\dfrac{128}{128*4}=\dfrac{1}{4}$，4是代表进行了4次从0<del>128字节的访问(即`d_x[0]</del>d_x[31]`)</li></ul></li><li>怎么样访问才是合并的？<ul><li>相邻线程访问连续的地址，例子见第七章第一节的顺序的合并访问</li></ul></li></ul><p>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240924211910.png" alt="375"><br>双精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240924211937.png" alt="375"><br>可以发现优化后在时间和精度上都有所提升！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">reduce_cp<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span>GRID_SIZE<span class="token punctuation">,</span> BLOCK_SIZE<span class="token punctuation">,</span> smem<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>d_x<span class="token punctuation">,</span> d_y<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>reduce_cp<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>d_y<span class="token punctuation">,</span> d_y<span class="token punctuation">,</span> GRID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 有GRID_SIZE个块需要归约</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>用<code>d_y[bid] = y;</code>代替了<code>atomicAdd(d_y, y)</code></li><li>使用两个核函数可以获得更加精确的结果，这是因为使用两个核函数时，将数组<code>d_y</code>归约到最终结果的计算使用了折半求和，比直接累加(使用原子函数或复制到主机再累加的情况)更稳健</li></ul><h3 id="10-5-2-避免反复分配与释放设备内存"><a href="#10-5-2-避免反复分配与释放设备内存" class="headerlink" title="10.5.2 避免反复分配与释放设备内存"></a>10.5.2 避免反复分配与释放设备内存</h3><p>在10.5.1的<code>reduce()</code>函数中，需要为数组<code>d_y</code>分配与释放设备内存。实际上，<strong>设备内存的分配与释放是比较耗时的</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">real <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">const</span> real<span class="token operator">*</span> d_x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">const</span> <span class="token keyword">int</span> ymem <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">*</span> GRID_SIZE<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaMalloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d_y<span class="token punctuation">,</span> ymem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配内存</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaFree</span><span class="token punctuation">(</span>d_y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放内存</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：使用静态全局内存代替动态全局内存，因为静态内存在编译期间就会分配好</p><ul><li>定义静态全局内存变量：<code>__device__ real static_y[GRID_SIZE];</code></li><li>在不改变核函数代码的情况下，可以用<code>cudaGetSymbolAddress()</code>获得一个指向该静态全局内存的指针<pre class="line-numbers language-c" data-language="c"><code class="language-c">__device__ real static_y<span class="token punctuation">[</span>GRID_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>real <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">const</span> real<span class="token operator">*</span> d_x<span class="token punctuation">)</span><span class="token punctuation">{</span>    real<span class="token operator">*</span> d_y<span class="token punctuation">;</span>    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaGetSymbolAddress</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d_y<span class="token punctuation">,</span> static_y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将指向d_y的指针指向static_y</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> smem <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">*</span> BLOCK_SIZE<span class="token punctuation">;</span>    reduce_cp<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span>GRID_SIZE<span class="token punctuation">,</span> BLOCK_SIZE<span class="token punctuation">,</span> smem<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>d_x<span class="token punctuation">,</span> d_y<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    reduce_cp<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>d_y<span class="token punctuation">,</span> d_y<span class="token punctuation">,</span> GRID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>      real h_y<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">CHECK</span><span class="token punctuation">(</span><span class="token function">cudaMemcpy</span><span class="token punctuation">(</span>h_y<span class="token punctuation">,</span> d_y<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span><span class="token punctuation">,</span> cudaMemcpyDeviceToHost<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> h_y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><code>cudaGetSymbolAddress(void** devPtr, const char* symbol);</code></li><li><code>void*8 devPtr</code>：是一个指向指针的指针，函数会修改这个指针，使其指向<strong>指定符号</strong>在设备上的地址</li><li><code>const char* symbol</code>：是一个字符串，表示你想要获取地址的符号名称(通常是全局变量或常量变量的名称，需要以<code>__device__</code>或<code>__constant__</code>存储类定义)</li><li>使用场景：在设备中定义了一个全局变量或常量，并希望在内核或其他CUDA函数中使用</li><li>示例👇<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 定义</span>__device__ <span class="token keyword">float</span> static_y<span class="token punctuation">;</span><span class="token comment">// 获取static_y的地址</span><span class="token keyword">float</span> <span class="token operator">*</span>d_y<span class="token punctuation">;</span><span class="token function">cudaGetSymbolAddress</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d_y<span class="token punctuation">,</span> <span class="token string">"static_y"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>单精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240926190202.png" alt="375"><br>双精度👇<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240926190218.png" alt="375"><br>用时比使用动态全局内存更短！</p><h1 id="第十一章-CUDA流"><a href="#第十一章-CUDA流" class="headerlink" title="第十一章 CUDA流"></a>第十一章 CUDA流</h1><p>核函数外部的并行主要指：</p><ul><li>核函数计算与数据传输之间的并行</li><li>主机计算与数据传输之间的并行</li><li>不同的数据传输之间的并行(cudaMemcpy函数中的第四个参数)</li><li>核函数计算与主机计算之间的并行</li><li>不同核函数之间的并行</li></ul><p>一般来说，要获得较高的加速比，如要<strong>减少主机与设备之间的数据传输及主机中的计算</strong>，<strong>尽量在设备中完成所有计算</strong></p><h2 id="11-1-CUDA流概述"><a href="#11-1-CUDA流概述" class="headerlink" title="11.1 CUDA流概述"></a>11.1 CUDA流概述</h2><p><strong>一个CUDA流指的是由主机发出的在一个设备中执行的CUDA操作</strong>(即和CUDA有关的操作，如主机-设备数据传输和核函数执行)<strong>序列</strong></p><p>CUDA流：</p><ul><li>默认流(空流)</li><li>非默认流(非空流)<ul><li>在主机端产生和销毁</li><li>一个CUDA流由类型为<code>cudaStream_t</code>的变量表示</li><li>产生：<code>cudaStreamCreate(cudaStream_t*)</code>，输入参数是<code>cudaStream_t</code>类型的指针</li><li>销毁：<code>cudaStreamDestroy(cudaStream_t*)</code>，输入参数<code>cudaStream_t</code>类型的变量</li><li>检查一个CUDA流中的所有操作是否都在设备中执行完毕：<ul><li><code>cudaStreamSynchronize(cudaStream_t stream)</code>，<code>cudaStreamSynchronize()</code>会强制阻塞主机，直到CUDA流stream中的所有操作都被执行完毕</li><li><code>cudaStreamQuery(cudaStream_t stream)</code>，<code>cudaStreamQuery()</code>不会阻塞主机，只是检查CUDA流stream中的所有操作是否都执行完毕</li></ul></li></ul></li></ul><h2 id="11-2-在默认流中重叠主机和设备计算"><a href="#11-2-在默认流中重叠主机和设备计算" class="headerlink" title="11.2 在默认流中重叠主机和设备计算"></a>11.2 在默认流中重叠主机和设备计算</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">cudaMemcpy</span><span class="token punctuation">(</span>d_x<span class="token punctuation">,</span> h_x<span class="token punctuation">,</span> M<span class="token punctuation">,</span> cudaMemcpyHostToDevice<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 主机发出命令后，需等待命令执行完毕才执行下一步，在等待的过程中主机闲置</span><span class="token function">cudaMemcpy</span><span class="token punctuation">(</span>d_y<span class="token punctuation">,</span> h_y<span class="token punctuation">,</span> M<span class="token punctuation">,</span> cudaMemcpyHostToDevice<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 主机发出命令后，需等待命令执行完毕才执行下一步，在等待的过程中主机闲置</span>sum<span class="token operator">&lt;&lt;</span><span class="token operator">&lt;</span>grid_size<span class="token punctuation">,</span> block_size<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>d_x<span class="token punctuation">,</span> d_y<span class="token punctuation">,</span> d_z<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 主机发出命令后，不会等待该命令执行完毕，主机紧接着会发出下一条指令</span><span class="token function">cudaMemcpy</span><span class="token punctuation">(</span>h_z<span class="token punctuation">,</span> d_z<span class="token punctuation">,</span> M<span class="token punctuation">,</span> cudaMemcpyDeviceToHost<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 因为这是默认流中的CUDA操作，必须等待前一个CUDA操作执行完毕才会执行这条命令</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>👆CUDA操作例子(注释是主机角度)<br>从设备角度看：上面4个CUDA操作在默认的CUDA流中<strong>按代码出现的顺序依次执行</strong><br>从主机角度看：<br>①主机在发出核函数命令的调用后会立刻发出下一个命令<br>②(1)如果下一个命令是数据传输，从设备角度看必须等待核函数执行完毕(实际上主机也在等执行完毕)<br>②(2)如果下一个命令是主机中的某个计算任务，那么主机会在设备执行核函数时同时进行一些计算，这样主机和设备就可以同时进行(<strong>设备完全不知道在它执行核函数时，主机偷偷地做了些计算</strong>)</p><p>实践(结果和书上的不符合)：</p><ul><li>采用单精度浮点数，在数据量一样时，<strong>核函数<code>gpu_sum</code>比主机端函数<code>cpu_sum</code>约快10倍</strong>，因此设置$ratio=\dfrac{设备端函数所处理的数据量}{主机端函数所处理的数据量}$，使得<code>gpu_sum</code>和<code>cpu_sum</code>执行时间差不多</li><li>这里的结果和书上的不太符合(思考.jpg)</li></ul><p>结果(书上的)：</p><ul><li>当主机函数和设备函数的计算量相当时，将<strong>主机函数放在设备函数之后</strong>(GPU -&gt; CPU)可以达到主机函数与设备函数并发执行的效果，从而有效地隐藏主机函数的执行过程</li><li>如果主机函数和设备函数计算时间差很多，加速效果不显著</li></ul><h2 id="11-3-用非默认CUDA流重叠多个核函数的执行"><a href="#11-3-用非默认CUDA流重叠多个核函数的执行" class="headerlink" title="11.3 用非默认CUDA流重叠多个核函数的执行"></a>11.3 用非默认CUDA流重叠多个核函数的执行</h2><p>同一个CUDA流中的<strong>CUDA操作在设备中是顺序执行的</strong>(非并行)，那么同一个CUDA流中的<strong>核函数</strong>也必须在设备中<strong>顺序执行</strong>，如果要实现<strong>多个核函数之间的并行</strong>必须使用<strong>多个CUDA流</strong></p><p>核函数的调度方式<br><code>my_kernel&lt;&lt;&lt;N_grid, N_block&gt;&gt;&gt;();</code> -&gt; 在默认流执行<br><code>my_kernel&lt;&lt;&lt;N_grid, N_block, N_shared&gt;&gt;&gt;();</code> -&gt; 在默认流执行<br><code>my_kernel&lt;&lt;&lt;N_grid, N_block, N_shared, stream_id&gt;&gt;&gt;();</code> -&gt; 非空流执行</p><ul><li><code>N_grid</code>是网格大小</li><li><code>N_block</code>是线程块大小</li><li><code>N_shared</code>是核函数中使用的<strong>动态共享内存</strong>的<strong>字节数</strong></li><li><code>stream_id</code>是CUDA流的编号</li></ul><p>可能是设备不同的问题，和书上的结果不太一样<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/Pasted%20image%2020240928191804.png" alt="500"><br>结果(书上的)：<br>CUDA流并发多个核函数可以提升GPU硬件的利用率，减少闲置的SM，从而从整体上获得性能提升</p><h2 id="11-4-用非默认CUDA流重叠核函数的执行与数据传递"><a href="#11-4-用非默认CUDA流重叠核函数的执行与数据传递" class="headerlink" title="11.4 用非默认CUDA流重叠核函数的执行与数据传递"></a>11.4 用非默认CUDA流重叠核函数的执行与数据传递</h2><p>若需要实现核函数执行与数据传输的并发(重叠)</p><ul><li>必须让这两个操作处于不同的非默认流</li><li>数据传输需要使用异步版本<code>cudaMemcpyAsync()</code>函数<ul><li>异步传输由GPU中的DMA(direct memory access)直接存储访问器，不需要主机参与<ul><li>DMA提供在<strong>外设和存储器之间</strong>或者<strong>存储器和存储器之间</strong>的高速数据传输</li><li>数据的复制和存储数据对于CPU来说没那么重要，可以交给DMA，解决大量数据转移过度消耗CPU资源的问题</li></ul></li><li>如果用同步的数据传输函数<code>cudaMemcpy()</code>，主机向一个流发出数据传输的命令后<strong>无法立刻获得控制权</strong>，必须等待数据传输完毕，即主机无法同时向另一个流调用核函数，也就不能实现核函数与数据传输的重叠</li><li><code>cudaMemcpyAsync(void *dst, const void *src, size_t count, enum cudaMemcpyKind kind, cudaStream_t stream)</code>比<code>cudaMemcpy()</code>多一个参数，是所<strong>在流的变量</strong></li><li>在使用异步的数据传输时，需要将主机内存定义为不可分页内存或者固定内存<ul><li>不可分页内存：若将主机内存声明为不可分页内存，则在程序运行期间其物理地址<strong>保持不变</strong></li><li>系统操作有权在一个程序运行期间改变程序中使用的<strong>可分页主机内存</strong>的物理地址</li></ul></li></ul></li></ul><p>不可分页<strong>主机内存</strong>的分配函数</p><ul><li><code>cudaMallocHost(void **ptr, size_t size);</code></li><li><code>cudaHostAlloc(void **ptr, size_t size, size_t flags);</code>，如果第三个参数取默认值<code>cudaHostAlllocDefault</code>，则和上面的函数等价<br>不可分页<strong>主机内存</strong>的释放函数</li><li><code>cudaFreeHost(void *ptr);</code></li></ul><p>这里的时间是把前几次REPEAT次数的时间也加上了</p><table><thead><tr><th></th><th>CUDA流=1</th><th>2</th><th>4</th><th>8</th><th>16</th><th>32</th><th>64</th></tr></thead><tbody><tr><td>REPEAT次数=1</td><td>0.727245</td><td>0.813056</td><td>0.671984</td><td>0.633242</td><td>0.640717</td><td>0.732979</td><td>0.711456</td></tr><tr><td>2</td><td>1.48132</td><td>1.6044</td><td>1.29539</td><td>1.25809</td><td>1.2987</td><td>1.37727</td><td>1.40511</td></tr><tr><td>3</td><td>2.15654</td><td>2.40559</td><td>1.94911</td><td>1.89739</td><td>1.98509</td><td>2.0228</td><td>2.10539</td></tr><tr><td>4</td><td>2.90161</td><td>3.17943</td><td>2.62284</td><td>2.54855</td><td>2.64568</td><td>2.66245</td><td>2.8182</td></tr><tr><td>5</td><td>3.5848</td><td>3.97385</td><td>3.29006</td><td>3.16776</td><td>3.29783</td><td>3.32314</td><td>3.53272</td></tr><tr><td>6</td><td>4.2719</td><td>4.79479</td><td>3.97973</td><td>3.8308</td><td>3.96661</td><td>4.00003</td><td>4.19064</td></tr><tr><td>7</td><td>5.04011</td><td>5.60569</td><td>4.61964</td><td>4.49671</td><td>4.65433</td><td>4.62836</td><td>4.84917</td></tr><tr><td>8</td><td>5.90314</td><td>6.3983</td><td>5.27192</td><td>5.15115</td><td>5.28048</td><td>5.26508</td><td>5.52204</td></tr><tr><td>9</td><td>6.73892</td><td>7.15903</td><td>5.94195</td><td>5.7894</td><td>5.90922</td><td>5.90743</td><td>6.19399</td></tr><tr><td>10</td><td>7.55339</td><td>8.02287</td><td>6.58859</td><td>6.41499</td><td>6.53621</td><td>6.56247</td><td>6.8724</td></tr></tbody></table><p>看起来并行效果是还不错的。</p><h1 id="第十四章-CUDA标准库的使用"><a href="#第十四章-CUDA标准库的使用" class="headerlink" title="第十四章 CUDA标准库的使用"></a>第十四章 CUDA标准库的使用</h1><h2 id="14-2-Thrust库"><a href="#14-2-Thrust库" class="headerlink" title="14.2 Thrust库"></a>14.2 Thrust库</h2><ul><li>Thrust库是一个实现了<strong>众多基本并行算法</strong>的C++模板库</li><li>该库中的所有类型与函数都在命名空间thrust中定义，所以用到<code>thrust::</code>开头</li><li>Thrust中有两种矢量：<ul><li><code>thrust::host_vector&lt;typename&gt;</code>，存储于主机中</li><li><code>thrust::device_vector&lt;typename&gt;</code>，存储于设备中<ul><li><code>thrust::devive_vectot&lt;double&gt; x(10, 0);</code>，元素类型为双精度浮点数(全部初始化为0)，长度为10</li></ul></li></ul></li><li>除了<code>thrust::copy</code>，Thrust算法的参数必须<strong>都</strong>来自于主机矢量或<strong>都</strong>来自于设备矢量，否则编译器会报错</li></ul><h3 id="14-2-4-例子：前缀和"><a href="#14-2-4-例子：前缀和" class="headerlink" title="14.2.4 例子：前缀和"></a>14.2.4 例子：前缀和</h3><ol><li>使用<code>device_vector</code>来实现<pre class="line-numbers language-c" data-language="c"><code class="language-c">thrust<span class="token operator">::</span><span class="token function">device_vector</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token function">x</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>thrust<span class="token operator">::</span><span class="token function">device_vector</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token function">y</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><ul><li>扫描操作<pre class="line-numbers language-c" data-language="c"><code class="language-c">thrust<span class="token operator">::</span><span class="token function">inclusive_scan</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><code>thrust::inclusive_scan(InputIterator begin, InputIterator end, OutputIterator result);</code><br>  <code>InputIterator begin</code> 输入范围的起始迭代器。<br>  <code>InputIterator end</code>: 输入范围的结束迭代器。<br>  <code>OutputIterator result</code>: 用于存储结果的输出范围起始迭代器。<br>  这里的迭代器可以理解为指针的推广<br>例子中使用了<code>thrust::inclusive_scan(x.begin(), x.end(), y.begin());</code></li><li>输出<br><code>y</code>是设备矢量，<code>y[i]</code>不是普通整型的变量，需要强制转化为整型后才能用<code>printf()</code>函数输出。用C++的输入/输出流可以直接输出<code>y[i]</code>而不需要先做强制类型转换</li></ul><ol start="2"><li>直接用设备中的数组(指针)实现</li></ol><ul><li><p>定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">cudaMalloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">cudaMalloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>y<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>扫描操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">thrust<span class="token operator">::</span><span class="token function">inclusive_scan</span><span class="token punctuation">(</span>thrust<span class="token operator">::</span>device<span class="token punctuation">,</span> x<span class="token punctuation">,</span> x <span class="token operator">+</span> N<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于使用设备矢量的版本，该函数用了一个额外的<strong>表示执行策略的参数</strong><code>thrust::device</code>，需要包含头文件<code>&lt;thrust/execution_policy.h&gt;</code></p></li><li><p>如果大量使用Thrust库提供的功能，使用设备矢量</p></li><li><p>如果偶尔使用Thrust库提供的功能，使用设备指针</p></li></ul><h2 id="14-3-cuBLAS库"><a href="#14-3-cuBLAS库" class="headerlink" title="14.3 cuBLAS库"></a>14.3 cuBLAS库</h2><p>行主序和列主序，前者要求矩阵的每一行元素在内存中是连续的，后者以此类推</p><p>cuBLAS库包含3个API，其中一个为<code>cuBLAS API</code>，可以实现BLAS三个层级的函数</p><ul><li>第一层函数处理矢量之间的运算</li><li>第二层函数处理矩阵和矢量之间的运算</li><li>第三层函数处理矩阵之间的运算</li></ul><h3 id="14-3-2-例子：矩阵乘法"><a href="#14-3-2-例子：矩阵乘法" class="headerlink" title="14.3.2 例子：矩阵乘法"></a>14.3.2 例子：矩阵乘法</h3><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/refs/heads/main/CUDAC/249b3070465d0ba1c51fff0da2c2ac6.jpg" alt="|400"><br>使用<code>cuBLAS</code>时使用<code>&lt;cublas_v2.h&gt;</code>作为头文件<br>在初始化<code>h_A</code>、<code>h_B</code>、<code>h_C</code>时用一维矢量来表示矩阵</p><ol><li>主机数组和设备数组的复制</li></ol><ul><li>从主机数组复制到设备数组<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">cublasStatus_t</span> <span class="token function">cublasSetVector</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> elemSize<span class="token punctuation">,</span>cosnt <span class="token keyword">void</span> <span class="token operator">*</span>x<span class="token punctuation">,</span><span class="token keyword">int</span> incx<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>y<span class="token punctuation">,</span><span class="token keyword">int</span> incy<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><code>n</code>：复制的元素个数<br><code>elemSize</code>：每个元素的字节数<br><code>incx</code>/<code>incy</code>：表示对数组x/y进行访问时每incx/incy个数据中取一个<br><code>x</code>：主机数组<br><code>y</code>：设备数组<br>例：<code>cublasSetVector(MK, sizeof(double), h_A, 1, g_A, 1);</code></li><li>从设备数组复制到主机数组<br><code>cublasGetVector()</code>其中参数相同，顺序不同<br>例：<code>cublasGetVector(MK, sizeof(double), g_A, 1, h_A, 1);</code></li></ul><ol start="2"><li>矩阵乘法计算</li></ol><ul><li>定义一个<code>cublasHandle</code>类型的变量并用<code>cublasCreate()</code>函数初始化</li><li>调用<code>cublasDgemm()</code>函数做矩阵相乘的计算<ul><li>是第三层的<code>cuBLAS</code>函数之一</li><li><code>D</code>：double</li><li><code>gemm</code>：GEneral Matrix-Matrix multiplication</li><li>执行如下计算<code>C = alpha * transa(A) * transb(B) + beta * C</code><ul><li><code>transa(A)</code>是对矩阵<code>A</code>做一个变换之后得到的矩阵，维度是<code>m × k</code></li><li><code>transb(B)</code>是对矩阵<code>B</code>做一个变换之后得到的矩阵，维度是<code>k × n</code></li><li><code>C</code>的维度是<code>m × n</code></li></ul></li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">cublasDgemm</span><span class="token punctuation">(</span><span class="token class-name">cublasHandle_t</span> handle<span class="token punctuation">,</span><span class="token class-name">cublasOperation_t</span> transa<span class="token punctuation">,</span><span class="token class-name">cublasOperation_t</span> transb<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>alpha<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>A<span class="token punctuation">,</span><span class="token keyword">int</span> lda<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>B<span class="token punctuation">,</span><span class="token keyword">int</span> ldb<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>beta<span class="token punctuation">,</span><span class="token keyword">double</span> <span class="token operator">*</span>C<span class="token punctuation">,</span><span class="token keyword">int</span> ldc<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>cublasOperation_t transa</code>中<code>transa</code>为：</p><ul><li><code>cuBLAS_OP_N</code>，<code>transa(A)</code>等于<code>A</code></li><li><code>cuBLAS_OP_T</code>，<code>transa(A)</code>等于<code>A</code>的转置</li><li><code>cuBLAS_OP_C</code>，<code>transa(A)</code>等于<code>A</code>的共轭转置<br><code>lda</code>、<code>ldb</code>和<code>ldc</code>分别是<code>transa(A)</code>、<code>transa(B)</code>和<code>C</code>的主维度，他们都是列主序，所以他们的主维度是矩阵的行数</li></ul><p>最后的结果<code>h_C</code>是列主序的(10 13 28 40)，打印时需要注意</p><h1 id="补充Event"><a href="#补充Event" class="headerlink" title="补充Event"></a>补充Event</h1><ul><li><strong>创建事件</strong>：首先使用 <code>cudaEventCreate()</code> 创建事件对象。</li><li><strong>记录事件</strong>：在需要记录的时间点调用 <code>cudaEventRecord(event, stream)</code>。</li><li><strong>计算时间</strong>：通过 <code>cudaEventElapsedTime()</code> 计算两个事件之间的时间差。</li><li><strong>销毁事件</strong>：最后使用 <code>cudaEventDestroy()</code> 销毁事件对象以释放资源。</li><li><strong>同步</strong>：<code>cudaEventSynchronize(stop)</code> 会阻塞 CPU，直到 GPU 确保从 <code>start</code> 到 <code>stop</code> 之间的所有操作都完成了。这对于测量内核函数执行时间或在 CPU 侧进行同步非常重要。</li><li><strong>检查事件是否完成</strong>：<code>cudaEventQuery(start)</code>它的主要功能是<strong>检查指定的 CUDA 事件是否已经完成</strong>，而不需要阻塞主机线程。<code>cudaEventQuery</code> 常用于需要频繁检查事件状态的场景。和 <code>cudaEventSynchronize</code> 不同，<code>cudaEventQuery</code> 是非阻塞的，不会让 CPU 等待 GPU 任务完成，而只是检查 GPU 的执行状态。如果事件还未完成，它会立即返回 <code>cudaErrorNotReady</code>，让程序可以继续执行其他任务。</li></ul><h1 id="补充运行"><a href="#补充运行" class="headerlink" title="补充运行"></a>补充运行</h1><p><code>$nvcc -arch=_75 add1.cu -o add1</code>，选择真实架构计算能力<br><code>$nvcc -O3 -arch=_75 add1.cu -o add1</code>，选择最激进的优化，生成最快的代码，但可能会增加编译时间和二进制文件大小。(C++程序的性能显著地依赖于优化选项)<br><code>$nvcc -O3 -arch=sm_75 -DUSE_DP add1.cu -o add1</code>使用<code>if</code>的选项，不写<code>-DUSE_DP</code>的话使用<code>else</code>的选项</p><h1 id="补充C-语法"><a href="#补充C-语法" class="headerlink" title="补充C++语法"></a>补充C++语法</h1><p><code>void read_xy(std::vector&lt;real&gt;&amp; x, std::vector&lt;real&gt; y);</code>：</p><ul><li><code>std::vector</code>：C++的动态数组，大小是动态的</li><li><code>std::vector&lt;real&gt;&amp; x</code>：对于<code>x</code>是引用传递，在<code>read_xy</code>函数内部对<code>x</code>的任何修改，都会直接影响到他们本身(而不是副本)，对外部的<code>x</code>也会有影响</li></ul><p><code>std::ifstream infile("xy.txt");</code></p><ul><li><code>std::ifstream</code>：表示输入文件流，用于从文件读取数据</li><li><code>infile</code>：用来打开文件并读取内容</li></ul><p><code>std::ofstream outfile("neighbor.txt");</code></p><ul><li><code>std::ofstream</code>：表示输出文件流，将数据写入到文件中</li></ul><p><code>std::istringstream words(line);</code></p><ul><li><code>std::istringstream</code>：表示输入字符串流，可以从一个字符串中逐个提取数据</li><li><code>words</code>：从字符串中提取数据</li><li>这段代码作用：使用<code>words</code>来逐个读取<code>line</code>中的单词或数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPU </tag>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mlc-llm 香橙派部署过程</title>
      <link href="/2024/01/27/mlc-llm-orangepi-bu-shu-guo-cheng/"/>
      <url>/2024/01/27/mlc-llm-orangepi-bu-shu-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>参考网站：<a href="https://blog.mlc.ai/2023/08/09/GPU-Accelerated-LLM-on-Orange-Pi">GPU-Accelerated LLM on a $100 Orange Pi</a>、<a href="https://llm.mlc.ai/docs/install/gpu.html#orange-pi-5-rk3588-based-sbc">Orange Pi 5 (RK3588 based SBC)¶</a></p><p>资料来源：<a href="https://github.com/mlc-ai/mlc-llm">Github——mlc-llm</a></p><p>相关论坛：<a href="https://www.reddit.com/r/MachineLearning/comments/15r1vy5/project_gpuaccelerated_llm_on_a_100_orange_pi/?rdt=33752&amp;onetap_auto=true">Reddit——GPU-Accelerated LLM on a $100 Orange Pi</a></p><h1 id="1-Prepare"><a href="#1-Prepare" class="headerlink" title="1 Prepare"></a>1 Prepare</h1><h2 id="1-1-Installation"><a href="#1-1-Installation" class="headerlink" title="1.1 Installation"></a>1.1 Installation</h2><p><strong>- Download and istall the Ubuntu 22.04 for your board from <a href="https://github.com/Joshua-Riek/ubuntu-rockchip/releases/tag/v1.22">here</a></strong>(pick “Orange Pi 5 Plus”)<br>(:ps 在这个版本里，我无法使用串口，apt update会出现无法解析域名等问题，于是最后用了<a href="https://pan.baidu.com/s/1cQR1pcca0P-xuQbTrnGXAw?pwd=pjhv#list/path=%2Fsharelink1077680202-1101560075650855%2FUbuntu&amp;parentPath=%2Fsharelink1077680202-1101560075650855">香橙派官方的系统——1.0.8_ubuntu_jammy_desktop_xfce_linux5.10.150</a><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127153142.png"></p><ol><li>在烧录前，需要准备一张SD卡(我用的32G)，准备<a href="https://etcher.balena.io/#download-etcher">烧录软件balenaEtcher</a></li><li>如何知道自己是否烧录成功？<ul><li>使用串口<a href="https://blog.csdn.net/itt21044ZCY/article/details/132742245#:~:text=%E9%A6%99%E6%A9%99%E6%B4%BE%E4%B8%B2%E5%8F%A3%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91%20%E4%B8%B2%E5%8F%A3%E8%BF%9E%E6%8E%A5%EF%BC%9AGND%E6%8E%A5GND%EF%BC%8CTX%E6%8E%A5RX%EF%BC%8CRX%E6%8E%A5TX%20%E4%B8%B2%E5%8F%A3%E7%9A%84%20TX%20%E5%92%8C%20RX%20%E6%98%AF%E9%9C%80%E8%A6%81%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%83%B3%E4%BB%94%E7%BB%86%E5%8C%BA%E5%88%86%20TX%E5%92%8C,TX%20%E5%92%8C%20RX%20%E5%85%88%E9%9A%8F%E4%BE%BF%E6%8E%A5%E4%B8%8A%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B5%8B%E8%AF%95%E4%B8%B2%E5%8F%A3%E6%B2%A1%E6%9C%89%E8%BE%93%E5%87%BA%E5%86%8D%E4%BA%A4%E6%8D%A2%E4%B8%8B%20TX%20%E5%92%8C%20RX%20%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E6%80%BB%E6%9C%89%E4%B8%80%E7%A7%8D%E9%A1%BA%E5%BA%8F%E6%98%AF%E5%AF%B9%E7%9A%84">CSDN——使用香橙派连接电脑，串口和SSH</a></li><li>使用另一个显示屏查看</li></ul></li><li>烧录成功后，通过上面两种办法知道香橙派的ip地址(如果是用显示屏的，在官方文档里查阅“设置静态IP地址的方法”)，我自己的修改为了192.168.1.201，如下图所示，用自己的电脑ping一下香橙派<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240126214418.png"></li><li>使用vscode连接香橙派<a href="https://blog.csdn.net/mjmmm/article/details/133981063#:~:text=%E7%82%B9%E5%87%BB%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%9A%20%E4%B8%AD%E9%97%B4%E4%B8%8A%E6%96%B9%E9%80%89%E6%8B%A9%E2%80%9Csmart_bin%E2%80%9D%EF%BC%9A,%E7%82%B9%E5%87%BB%E2%80%9C%E7%A1%AE%E5%AE%9A%E2%80%9D%EF%BC%9A%20%E5%86%8D%E6%AC%A1%E9%80%89%E6%8B%A9%E2%80%9CLinux%E2%80%9D%EF%BC%8C%E5%B9%B6%E8%BE%93%E5%85%A5%E9%A6%99%E6%A9%99%E6%B4%BE%E5%AF%86%E7%A0%81%EF%BC%9A%20%E6%AD%A4%E6%97%B6%EF%BC%8C%E5%B0%B1%E6%88%90%E5%8A%9F%E8%BF%9E%E6%8E%A5%E4%B8%8A%E4%BA%86smart_bin%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8VSCODE%E5%AF%B9%E4%BA%8E%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%BE%91%E6%93%8D%E4%BD%9C%E4%BA%86%EF%BC%81">CSDN——使用Visual Studio Code远程连接香橙派</a><ul><li>踩坑点：注意Ubuntu上是否开启了ssh</li><li>更新软件包<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>下载<code>open ssh</code><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> openssh-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>下载完成后查看<code>ssh</code>是否打开<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">ps</span> <span class="token parameter variable">-e</span> <span class="token operator">|</span><span class="token function">grep</span> <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>连接成功后会出现下面的图<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240126222152.png"></li></ul></li></ol><p><strong>- Download and install&nbsp;<code>libmali-g610.so</code></strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/lib <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">wget</span> https://github.com/JeffyCN/mirrors/raw/libmali/lib/aarch64-linux-gnu/libmali-valhall-g610-g6p0-x11-wayland-gbm.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>我的香橙派无法访问github，于是采用主机下载文件后用FileZilla传输文件到虚拟机上，用了之前方法但是显示无法连接<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127093218.png"></li><li>更改协议后连接成功，协议如下图所示<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127094737.png"></li><li>在主机上点击<a href="https://github.com/JeffyCN/mirrors/tree/libmali/lib/aarch64-linux-gnu">网站</a>找到libmali-valhall-g610-g6p0-x11-wayland-gbm.so并下载</li><li>FileZilla出现“无法启动传输”字样 <img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127100058.png"><ul><li>原因：文件权限不足</li><li>解决：修改远程站点文件的权限<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token number">777</span> 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127100350.png"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127100646.png"></li></ul></li></ol><p><strong>- Check if file&nbsp;<code>mali_csffw.bin</code>&nbsp;exist under path&nbsp;<code>/lib/firmware</code>, if not download it with command:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /lib/firmware <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">wget</span> https://github.com/JeffyCN/mirrors/raw/libmali/firmware/g610/mali_csffw.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我找到了这个文件所以就不用下载了，<a href="https://github.com/JeffyCN/mirrors/tree/libmali/firmware/g610">文件下载处</a><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127101202.png"></p><p><strong>- Download OpenCL ICD loader and manually add libmali to ICD</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> mesa-opencl-icd<span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /etc/OpenCL/vendors<span class="token builtin class-name">echo</span> <span class="token string">"/usr/lib/libmali-valhall-g610-g6p0-x11-wayland-gbm.so"</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/OpenCL/vendors/mali.icd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-Validata-Installation"><a href="#1-2-Validata-Installation" class="headerlink" title="1.2 Validata Installation"></a>1.2 Validata Installation</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">clinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-3-Prepare"><a href="#1-3-Prepare" class="headerlink" title="1.3 Prepare"></a>1.3 Prepare</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># clone mlc-llm from GitHub</span><span class="token function">git</span> clone <span class="token parameter variable">--recursive</span> https://github.com/mlc-ai/mlc-llm.git <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> mlc-llm<span class="token comment"># Download prebuilt weights and libs</span><span class="token function">git</span> lfs <span class="token function">install</span><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> dist/prebuilt <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> dist/prebuilt<span class="token function">git</span> clone https://github.com/mlc-ai/binary-mlc-llm-libs.git lib<span class="token function">git</span> clone https://huggingface.co/mlc-ai/mlc-chat-RedPajama-INCITE-Chat-3B-v1-q4f16_1<span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我采用在本地拉取后再传输到香橙派上，建议是先压缩再传输，再在香橙派上解压(.zip)</p><p>在第一步<code>git clone --recursive https://github.com/mlc-ai/mlc-llm.git &amp;&amp; cd mlc-llm</code>如果遇到这个443问题，点击<a href="https://blog.csdn.net/qq_40296909/article/details/134285451">链接</a><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127140733.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> http.proxy <span class="token number">127.0</span>.0.1:7890<span class="token function">git</span> config <span class="token parameter variable">--global</span> https.proxy <span class="token number">127.0</span>.0.1:7890<span class="token comment"># 注意7890要改成自己的电脑上的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone <span class="token parameter variable">--recursive</span> https://github.com/mlc-ai/mlc-llm.git <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> mlc-llm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> lfs <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这一步之前先install<code>git-lfs</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> git-lfs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>👇在宿主机中创建文件并进入文件<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127143842.png"><br>👇会直接在你(主机)选中的目录下(我这里的是mlc-llm)下有一个lib文件<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127144257.png"><br>将主机中的lib压缩后拖进宿主机的lib文件下<br>👇在宿主机中cd到lib并将刚才的压缩包解压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">unzip</span> FileName.zip <span class="token comment"># 解压</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127152142.png"></p><p>RedPajama-INCITE-Chat-3B-v1-q4f16_1:<a href="https://huggingface.co/togethercomputer/RedPajama-INCITE-Chat-3B-v1">https://huggingface.co/togethercomputer/RedPajama-INCITE-Chat-3B-v1</a></p><p>Llama-2-7b-chat-hf-q4f16_1:<a href="https://huggingface.co/mlc-ai/mlc-chat-Llama-2-7b-chat-hf-q4f16_1">https://huggingface.co/mlc-ai/mlc-chat-Llama-2-7b-chat-hf-q4f16_1</a></p><p>Llama-2-13b-chat-hf-q4f16_1:<a href="https://huggingface.co/mlc-ai/mlc-chat-Llama-2-13b-chat-hf-q4f16_1">https://huggingface.co/mlc-ai/mlc-chat-Llama-2-13b-chat-hf-q4f16_1</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://huggingface.co/mlc-ai/mlc-chat-Llama-2-13b-chat-hf-q4f16_1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>👆在主机上下载(注意这个网址取决于你用什么来作为模型)，下载完毕后采用👇命令传输到香橙派上，好处是可以看到传输的过程(这个文件有13多个G)<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127151212.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> <span class="token parameter variable">-r</span> ./mlc-chat-Llama-2-13b-chat-hf-q4f16_1 orangepi@192.168.1.202:/home/orangepi/Project/MLC-LLM/dist/prebuit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> <span class="token parameter variable">-r</span> 相对路径下需要传输的文件 主机名@ip:被传输文件的目的文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-Try-out-the-CLI"><a href="#2-Try-out-the-CLI" class="headerlink" title="2 Try out the CLI"></a>2 Try out the CLI</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> mlc-llm/<span class="token comment"># create build directory</span><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> build <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> build<span class="token comment"># generate build configuration</span>python3 <span class="token punctuation">..</span>/cmake/gen_cmake_config.py<span class="token comment"># build `mlc_chat_cli`</span>cmake <span class="token punctuation">..</span> <span class="token operator">&amp;&amp;</span> cmake <span class="token parameter variable">--build</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">--parallel</span> <span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token punctuation">..</span>/cmake/gen_cmake_config.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>👆这一步中，<code>CUDA</code>、<code>Vulkan</code>、<code>ROCm</code>、<code>Metal</code>全选<code>n</code>，其余选<code>y</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake <span class="token punctuation">..</span> <span class="token operator">&amp;&amp;</span> cmake <span class="token parameter variable">--build</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">--parallel</span> <span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>👆在这一步可能会报两次错<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127155002.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还有一个报错没找到图，大概意思是找不到cargo，install一个就好👇</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">cargo</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127155902.png"><br>解决方法<a href="https://blog.csdn.net/iamzhoujunjia/article/details/113835347">更换Cargo软件源</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> <span class="token environment constant">$HOME</span>/.cargo/config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>👆我的是新建的一个文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 中科大</span><span class="token punctuation">[</span>source.crates-io<span class="token punctuation">]</span>registry <span class="token operator">=</span> <span class="token string">"https://github.com/rust-lang/crates.io-index"</span>replace-with <span class="token operator">=</span> <span class="token string">'ustc'</span><span class="token punctuation">[</span>source.ustc<span class="token punctuation">]</span>registry <span class="token operator">=</span> <span class="token string">"git://mirrors.ustc.edu.cn/crates.io-index"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次执行👇可以看到有后续的进度</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake <span class="token punctuation">..</span> <span class="token operator">&amp;&amp;</span> cmake <span class="token parameter variable">--build</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">--parallel</span> <span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127161834.png"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127162004.png"></p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127162200.png"></p><p>👆这一步是让我们看是否有三个文件，分别对应右图中绿色的三个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./build/mlc_chat_cli <span class="token parameter variable">--model</span> Llama-2-13b-chat-hf-q4f16_1 –device mali<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>报错：找不到<code>mlc-chat-config.json</code><br>解决问题<a href="https://github.com/mlc-ai/mlc-llm/issues/730">Github——Cannot find “mlc-chat-config.json” in path “”dist”/RedPajama-INCITE-Chat-3B-v1-q4f16_1</a>：<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127164042.png"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127164305.png"><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127164020.png"><br>原因：<code>mlc-chat-config.json</code>在<code>mlc-llm</code>的上一级文件里的<code>mlc-chat-Llama-2-13b-chat-hf-q4f16_1</code>文件中，一开始是在<code>mlc-llm</code>中<code>bulid</code>中运行，因为无法调用/访问<code>mlc-llm</code>的同级文件所以报错。所以换成<code>MLC-LLM</code>来调用<code>mlc_chat_cli</code>，即<code>dist</code>的上一级</p><p><strong>大功告成！</strong><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LLM%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%89%87/Pasted%20image%2020240127170657.png"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测(环境配置)</title>
      <link href="/2023/12/04/mu-biao-jian-ce/"/>
      <url>/2023/12/04/mu-biao-jian-ce/</url>
      
        <content type="html"><![CDATA[<p>附本菜鸡在windows上运行成功的(通过电脑摄像头的)yolo<a href="https://github.com/Wabbybabb0/yolov5-5.0_hat_person">目标检测</a></p><p><strong>配置环境的时候想清楚放在哪个盘，特别是虚拟机，放C盘很可能会g</strong></p><p>目前因为芯片问题卡住了，还会持续更新的….(也许是24年？)</p><h1 id="1-项目代码结构整"><a href="#1-项目代码结构整" class="headerlink" title="1 项目代码结构整"></a>1 项目代码结构整</h1><ul><li>data：主要是存放一些超参数的配置文件（这些文件（yaml文件）是用来配置训练集和测试集还有验证集的路径的，其中还包括目标检测的种类数和种类的名称）；还有一些官方提供测试的图片。如果是训练自己的数据集的话，那么就需要修改其中的yaml文件。但是自己的数据集不建议放在这个路径下面，而是建议把数据集放到yolov5项目的同级目录下面。</li><li>models：里面主要是一些网络构建的配置文件和函数，其中包含了该项目的四个不同的版本，分别为是s、m、l、x。从名字就可以看出，这几个版本的大小。他们的检测测度分别都是从快到慢，但是精确度分别是从低到高。这就是所谓的鱼和熊掌不可兼得。如果训练自己的数据集的话，就需要修改这里面相对应的yaml文件来训练自己模型。</li><li>utils：存放的是工具类的函数，里面有loss函数，metrics函数，plots函数等等。</li><li>weights：放置训练好的权重参数。</li><li>detect.py：利用训练好的权重参数进行目标检测，可以进行图像、视频和摄像头的检测。</li><li>train.py：训练自己的数据集的函数。</li><li>test.py：测试训练的结果的函数。</li><li>requirements.txt：这是一个文本文件，里面写着使用yolov5项目的环境依赖包的一些版本，可以利用该文本导入相应版本的包。</li></ul><h1 id="2-从github上拉取的包"><a href="#2-从github上拉取的包" class="headerlink" title="2 从github上拉取的包"></a>2 从github上拉取的包</h1><h2 id="2-1-最好创建一个新的虚拟环境，因为yolo对一些库有版本要求"><a href="#2-1-最好创建一个新的虚拟环境，因为yolo对一些库有版本要求" class="headerlink" title="2.1 最好创建一个新的虚拟环境，因为yolo对一些库有版本要求"></a>2.1 最好创建一个新的虚拟环境，因为<code>yolo</code>对一些库有版本要求</h2><p><a href="https://www.bilibili.com/video/BV1cD4y1H7Tk/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1e1c4d48c6129699686897a835e568ea">创建虚拟环境–b站视频教程</a>，视频评论区置顶处下有pdf讲义，可下载。不想看视频的可以直接点<a href="https://pan.baidu.com/s/1Xnhv-NSmtggYqKlg3uAlMg#list/path=%2F">讲义链接</a><br>其中：</p><ul><li>注意<code>NVIDA</code>、<code>CUDA</code>、<code>pytorch</code>的型号是否互相兼容</li><li>注意网络问题，有时候关掉梯子会好点</li><li>源的问题，找到一个阿里云比较好用的：<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip config <span class="token builtin class-name">set</span> global.index-url https://mirrors.aliyun.com/pypi/simple pip config <span class="token builtin class-name">set</span> install.trusted-host mirrors.aliyun.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>记录途中用到的<code>whl</code>路径<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> D:<span class="token punctuation">\</span>whl<span class="token punctuation">\</span>torch-1.12.0+cu116-cp39-cp39-win_amd64.whlpip <span class="token function">install</span> D:<span class="token punctuation">\</span>whl<span class="token punctuation">\</span>torchvision-0.13.0+cu116-cp39-cp39-win_amd64.whlpip <span class="token function">install</span> D:<span class="token punctuation">\</span>whl<span class="token punctuation">\</span>torchaudio-0.12.0+cu116-cp39-cp39-win_amd64.whl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-2-修改代码时的一些注意事项"><a href="#2-2-修改代码时的一些注意事项" class="headerlink" title="2.2 修改代码时的一些注意事项"></a>2.2 修改代码时的一些注意事项</h2><ol><li><code>train.py</code>、<code>dectect.py</code>可以面向CSDN编程</li></ol><ul><li>e.g.报错No module named ‘yaml‘  ，在终端输入如下指令<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> pyyaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>注意是在终端处下载还是在<code>Anaconda Prompt</code>处下载</li><li>注意<code>conda install</code>还是<code>pip install</code>，注意先激活虚拟环境再安装包<code>conda activate xxx</code></li></ul><ol start="2"><li>注意路径问题：<ol><li>绝对路径：在<code>train.py</code>中的三行代码里最好使用绝对路径<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/Pasted%20image%2020231205120324.png"></li><li>相对路径：在<code>detect.py</code>中的<code>weights</code>，在我使用绝对路径的时候是无法实现想要的效果的，但是更改为<code>weights/best.pt</code>(使用最佳模型做测试)时可以正常运行</li></ol></li></ol><h1 id="3-配置VMware和Ubuntu"><a href="#3-配置VMware和Ubuntu" class="headerlink" title="3 配置VMware和Ubuntu"></a>3 配置VMware和Ubuntu</h1><p>下面是两个安装教程，可以结合食用：</p><h2 id="3-1VMware虚拟机安装Linux教程："><a href="#3-1VMware虚拟机安装Linux教程：" class="headerlink" title="3.1VMware虚拟机安装Linux教程："></a>3.1<a href="https://blog.csdn.net/weixin_52799373/article/details/124324077">VMware虚拟机安装Linux教程</a>：</h2><p>(以下是该教程的虚拟机和iso选择，可根据个人需要进行更改，但是配置过程大差不差)</p><ol><li>虚拟机：VMware16 pro</li><li>Linux系统iso镜像：CentOS-7.5-x86_64</li></ol><h2 id="3-2-VMware虚拟机安装Ubuntu20-04详细图文教程"><a href="#3-2-VMware虚拟机安装Ubuntu20-04详细图文教程" class="headerlink" title="3.2 VMware虚拟机安装Ubuntu20.04详细图文教程"></a>3.2 <a href="https://blog.csdn.net/weixin_41805734/article/details/120698714">VMware虚拟机安装Ubuntu20.04详细图文教程</a></h2><p>(以下是该教程的虚拟机和iso选择，可根据个人需要进行更改，但是配置过程大差不差)</p><ol><li>虚拟机：VMware16</li><li>Linux系统iso镜像：Ubuntu20.04</li></ol><h2 id="3-3-一些说明"><a href="#3-3-一些说明" class="headerlink" title="3.3 一些说明"></a>3.3 一些说明</h2><p>正如上面一位博主所说“不必刻意用旧版”</p><ol><li><p>关于虚拟机：可选择VMware 17，<a href="https://www.vmware.com/cn/products/workstation-player/workstation-player-evaluation.html">VMware官方网站</a></p></li><li><p>关于iso镜像：新手推荐下Ubuntu，可以去<a href="https://ubuntu.com/download/desktop">Ubuntu官方网站</a><br> 这里附上<a href="http://mirrors.aliyun.com/ubuntu-releases/20.04/">Ubuntu20.04</a>的链接(是国内镜像源，下载会快些)!<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/1701762736537.png"></p></li><li><p>设置内核和内存时可以最好设置好之后就不改了，因为修改内存或硬盘大小之后重启可能会b溃，本人在下图修改硬盘大小之后无法再打开虚拟机<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/Pasted%20image%2020231205155730.png"></p></li></ol><h2 id="3-4-宿主机与虚拟机互传文件"><a href="#3-4-宿主机与虚拟机互传文件" class="headerlink" title="3.4 宿主机与虚拟机互传文件"></a>3.4 宿主机与虚拟机互传文件</h2><p><a href="https://blog.51cto.com/u_15309736/5424668">windows主机和ubuntu互传文件的4种方法</a><br>本人选择第二个方法：</p><ol><li>ubuntu安装FTP服务<br> 在ubuntu终端输入如下命令<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> vsftpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>安装完后检查<code>/etc /vsftpd.conf</code>配置文件<br>输入如下命令打开配置文件：（注意此处在网址上输入的是<code>sudo vi</code>，但是本人不太会使用<code>vi</code>编辑器，也找不到<code>vi</code>编辑器的使用方法，因此使用了<code>vim</code>，<code>vim</code>编辑器的的指令在下文4.9有提到）<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vim</span> /etc/bsftpd.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>windows安装和配置FIleZilla<br>点击<a href="https://www.filezilla.cn/download">FileZilla下载中心</a>下载客户端</li><li>FileZilla软件配置：<br>打开FileZilla软件，选择：文件-&gt;站点管理器-&gt;点击新增站点，然后配置连接参数，如下图：<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/1701834260705.png"><br>主机处输入的是ubuntu的IPv4地址，查找方式如下：</li></ol><ul><li>点击设置<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/1701834357072.png"></li><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/1701834466524.png"></li><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/1701834503573.png"></li></ul><ol start="5"><li>可以看到ubuntu下的文件(右边)<br>![](<a href="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/Pasted">https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/Pasted</a> image 20231206114943.png)</li></ol><h1 id="4-Ubuntu22-04配置anaconda"><a href="#4-Ubuntu22-04配置anaconda" class="headerlink" title="4 Ubuntu22.04配置anaconda"></a>4 Ubuntu22.04配置anaconda</h1><h2 id="4-1-配置过程"><a href="#4-1-配置过程" class="headerlink" title="4.1 配置过程"></a>4.1 配置过程</h2><p><a href="https://www.xtuos.com/6527.html">参考来源</a></p><ol><li><p>首先，通过在终端中运行以下命令，确保所有系统包都是最新的。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> upgrade<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">wget</span> apt-transport-https gnupg2 software-properties-common<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在 Ubuntu 22.04 上安装 Anaconda Python。<br>默认情况下，Anaconda 在 Ubuntu 22.04 基础存储库中不可用。现在运行以下命令将 Anaconda 的最新稳定版本下载到您的 Ubuntu 系统：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://repo.anaconda.com/archive/Anaconda3-2022.05-Linux-x86_64.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/Pasted%20image%2020231205114818.png"><br>下载Anaconda安装程序后，现在使用以下命令运行脚本：</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">bash</span> Anaconda3-2022.05-Linux-x86_64.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按照向导说明完成 Anaconda 安装过程(可以一路按”Enter”)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Welcome to Anaconda3 <span class="token number">2022.05</span>In order to <span class="token builtin class-name">continue</span> the installation process, please review the licenseagreement.Please, press ENTER to <span class="token builtin class-name">continue</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下一步是指明安装路径，默认指向根目录。如果您具有 root 访问权限，则可以将其保留在那里，但您也可以将其安装在您帐户的 HOME 目录中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Anaconda3 will now be installed into this location:/root/anaconda3- Press ENTER to confirm the location- Press CTRL-C to abort the installation- Or specify a different location below<span class="token punctuation">[</span>/root/anaconda3<span class="token punctuation">]</span> <span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意地址是：<code>/home/wabbybabbo(你自己的用户名)/anaconda3</code><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/Pasted%20image%2020231205201819.png"></p><ol start="3"><li><p>安装 Anaconda 后，下一步是通过运行以下命令来使用“ ”文件中添加的环境设置：<code>.bashrc</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>验证Anaconda安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如果要更新运行的整个环境(非必要)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda update-all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看虚拟机上的虚拟环境有哪些</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda info <span class="token parameter variable">--envs</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到这时候有一个名为<code>base</code>的虚拟环境<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/Pasted%20image%2020231205155441.png"></p></li></ol><h2 id="4-2-其他指令"><a href="#4-2-其他指令" class="headerlink" title="4.2 其他指令"></a>4.2 其他指令</h2><h3 id="4-2-1-unbutu一些指令"><a href="#4-2-1-unbutu一些指令" class="headerlink" title="4.2.1 unbutu一些指令"></a>4.2.1 unbutu一些指令</h3><p><a href="https://blog.csdn.net/zjc910997316/article/details/82983251">来源</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> www  <span class="token comment"># 到www目录；  </span><span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>   <span class="token comment"># 到上一级目录；  </span><span class="token builtin class-name">cd</span> -    <span class="token comment"># 返回到上次的目录，类似windows返回 ；  </span><span class="token builtin class-name">cd</span> /    <span class="token comment"># 回到根目录。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-2-Linux-vim编辑器的指令"><a href="#4-2-2-Linux-vim编辑器的指令" class="headerlink" title="4.2.2 Linux vim编辑器的指令"></a>4.2.2 Linux vim编辑器的指令</h3><p><a href="https://blog.csdn.net/xie_xiansheng/article/details/78134626">来源</a></p><ul><li>编写：按<code>a</code></li><li>退出：先按<code>ESC</code>键，跳到命令模式，再根据选择输入下面的(记得输入冒号)<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">:w      <span class="token comment"># 保存文件但不退出vi</span>:w <span class="token function">file</span> <span class="token comment"># 将修改另外保存到file中，不退出vi</span>:w<span class="token operator">!</span>     <span class="token comment"># 强制保存，不推出vi</span>:wq     <span class="token comment"># 保存文件并退出vi</span>:wq<span class="token operator">!</span>    <span class="token comment"># 强制保存文件，并退出vi</span>:q      <span class="token comment"># 不保存文件，退出vi</span>:q<span class="token operator">!</span>     <span class="token comment"># 不保存文件，强制退出vi</span>:e<span class="token operator">!</span>     <span class="token comment"># 放弃所有修改，从上次保存文件开始再编辑</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-2-3-进入和退出conda-base环境"><a href="#4-2-3-进入和退出conda-base环境" class="headerlink" title="4.2.3 进入和退出conda base环境"></a>4.2.3 进入和退出<code>conda base</code>环境</h3><p>进入<code>conda base</code>环境：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/anaconda3/bin/activate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出<code>conda base</code>环境：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/Pasted%20image%2020231205205557.png"></p><h1 id="5-yolo模型部署到orangepi-3"><a href="#5-yolo模型部署到orangepi-3" class="headerlink" title="5 yolo模型部署到orangepi 3"></a>5 yolo模型部署到orangepi 3</h1><p>附上两个参考网站：<a href="https://blog.csdn.net/m0_55217834/article/details/130583886"># 香橙派5 RK3588 yolov5模型转换rknn及部署踩坑全记录 orangepi 5</a>、<a href="http://years.love/yolov5.html">linux板上运行yolov5 目标检测</a></p><h2 id="5-1-所谓的yolov5目录"><a href="#5-1-所谓的yolov5目录" class="headerlink" title="5.1 所谓的yolov5目录"></a>5.1 所谓的yolov5目录</h2><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/Pasted%20image%2020231205161134.png"><br> 这个<strong>yolov5目录</strong>在本人的电脑上，这个文件是这样的<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/Pasted%20image%2020231205161233.png"></p><h2 id="5-2-路径问题"><a href="#5-2-路径问题" class="headerlink" title="5.2 路径问题"></a>5.2 路径问题</h2><p> <code>weight</code>和<code>data/coco128</code>改成自己的weight和data的路径</p><h2 id="5-3-生成的-onnx文件"><a href="#5-3-生成的-onnx文件" class="headerlink" title="5.3 生成的.onnx文件"></a>5.3 生成的<code>.onnx</code>文件</h2><p> 生成的yolov5n.onnx文件在本人电脑上的位置在这里，名为<code>best.onnx</code><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/yolo_picture/Pasted%20image%2020231205161724.png"></p><h2 id="5-4-在Ubuntu创建虚拟环境"><a href="#5-4-在Ubuntu创建虚拟环境" class="headerlink" title="5.4 在Ubuntu创建虚拟环境"></a>5.4 在Ubuntu创建虚拟环境</h2><ol start="4"><li>创建名为<code>rknn</code>的虚拟环境时输入<code>conda create -name rknn python=3.9</code>报错了，但是输入<code>conda create -n rknn python=3.9</code>就不会，很奇怪</li></ol><h2 id="5-5-Ubuntu解压缩"><a href="#5-5-Ubuntu解压缩" class="headerlink" title="5.5 Ubuntu解压缩"></a>5.5 Ubuntu解压缩</h2><p><a href="https://blog.csdn.net/songbinxu/article/details/80435665">参考网址</a><br>本人用到的是</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">unzip</span> FileName.zip <span class="token comment"># 解压</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再之后的跟着上面的两个博客走，基本上没什么坑了</p><h1 id="6-遇到的其他问题"><a href="#6-遇到的其他问题" class="headerlink" title="6 遇到的其他问题"></a>6 遇到的其他问题</h1><p>在开机时黑屏且遇到了：<br><a href="https://blog.csdn.net/qq_38132831/article/details/77932173">SMbus Host Controller not enabled</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlexNet模型复现</title>
      <link href="/2023/11/28/alexnet-mo-xing-fu-xian/"/>
      <url>/2023/11/28/alexnet-mo-xing-fu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="1-创建net"><a href="#1-创建net" class="headerlink" title="1 创建net"></a>1 创建net</h1><h2 id="1-1-torch-nn-Module"><a href="#1-1-torch-nn-Module" class="headerlink" title="1.1 torch.nn.Module()"></a>1.1 torch.nn.Module()</h2><p><strong>Base class for all neural network modules</strong></p><h3 id="1-1-1-Variables"><a href="#1-1-1-Variables" class="headerlink" title="1.1.1 Variables"></a>1.1.1 Variables</h3><ol><li><code>cuda(device=None)</code><br>Moves all model parameters and buffers to the GPU<br>将所有模型参数和缓冲区移至 GPU</li><li><code>eval()</code><br>Sets the module in evaluation mode<br>将模块设置为评估模式 ^eval</li><li><code>forward()</code><br>Defines the computation performed at every call.<br>定义每次调用时执行的计算 ^forward</li></ol><h2 id="1-2-阅读论文后得到net的参数"><a href="#1-2-阅读论文后得到net的参数" class="headerlink" title="1.2 阅读论文后得到net的参数"></a>1.2 阅读论文后得到net的参数</h2><p>关注$C_{in}$、$C_{out}$、$kernel_size$、$padding$、$stride$<br>其中，$stride$需要根据公式计算得出<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/a0dda904b7f38e1eea5ebad874024a7.jpg">)</p><h2 id="1-3-编写init"><a href="#1-3-编写init" class="headerlink" title="1.3 编写init"></a>1.3 编写init</h2><p>定义每个步骤的具体执行过程<br>e.g.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>c1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> out_channels<span class="token operator">=</span><span class="token number">48</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里规定<code>c1</code>的执行过程是接收输入通道为$3$的图像，用<code>size</code>为$11$的<code>kernel</code>…最后以输出通道为$48$作为输出</p><h2 id="1-4-编写forward"><a href="#1-4-编写forward" class="headerlink" title="1.4 编写forward"></a>1.4 编写forward</h2><p>[[#^forward]]<br>按照卷积的顺序进行x的更迭</p><h2 id="1-5-测试"><a href="#1-5-测试" class="headerlink" title="1.5 测试"></a>1.5 测试</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当这段代码只在直接运行当前脚本时才会执行，如果当前脚本被其他脚本引入作为模块使用，则这部分代码不会执行。<br>通常会对<code>x</code>和<code>y</code>赋予简单的数字对<code>net</code>进行测试</p><h1 id="2-划分数据集"><a href="#2-划分数据集" class="headerlink" title="2 划分数据集"></a>2 划分数据集</h1><h2 id="2-1-创建文件"><a href="#2-1-创建文件" class="headerlink" title="2.1 创建文件"></a>2.1 创建文件</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 如果文件不存在，则创建文件  </span><span class="token keyword">def</span> <span class="token function">mkfile</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>cla = [Cat, Dog]</li><li><code>data/train/</code>+<code>cla</code><ul><li><code>data/train/Cat</code></li><li><code>data/train/Dog</code></li><li><code>data/val/Cat</code></li><li><code>dara/val/Dog</code></li></ul></li></ul><h2 id="2-2-遍历与划分"><a href="#2-2-遍历与划分" class="headerlink" title="2.2 遍历与划分"></a>2.2 遍历与划分</h2><ol><li>遍历所有类别的图像<br><code>images</code>存储了原始data下<code>cla</code>分别为<code>Cat</code>和<code>Dog</code>的图像名称</li><li>按比例划分为训练集和测试集<br><code>eval_index</code>是<code>images</code>中的随机抽取的$\dfrac{2}{10}$的图像名称的集合</li></ol><p>随后再次遍历<code>images</code></p><ul><li>如果图像的名字在<code>eval_index</code>中存在，则将这个图像复制到新路径<code>data/val/+cla</code>(<code>val</code>中<code>Cat</code>或<code>Dog</code>的文件下)</li><li>如果不在<code>eval_index</code>中存在，则复制到<code>data/train/+cla</code>中</li></ul><h1 id="3-编写train-py"><a href="#3-编写train-py" class="headerlink" title="3 编写train.py"></a>3 编写train.py</h1><h2 id="3-1-用到的库"><a href="#3-1-用到的库" class="headerlink" title="3.1 用到的库"></a>3.1 用到的库</h2><h3 id="3-1-1-torchvision-transforms"><a href="#3-1-1-torchvision-transforms" class="headerlink" title="3.1.1 torchvision.transforms"></a>3.1.1 torchvision.transforms</h3><ol><li><p>.Normalize(<em>mean, std, inplace=False</em>)<br>ps: It’s scriptable transforms, which can’t use [[#^Compose]]    :)<br>归一化处理<br>output[channel] = (input[channel] - mean[channel] / std[channel])<br>^normalize</p></li><li><p>.Compose(<em>transforms</em>)<br>Composes several transforms together.This transform does not support torchscript.<br>^Compose</p></li></ol><h2 id="3-1-对图像像素归一化处理"><a href="#3-1-对图像像素归一化处理" class="headerlink" title="3.1 对图像像素归一化处理"></a>3.1 对图像像素归一化处理</h2><p>[[#^normalize]]</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">normalize <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 减0.5再除0.5最后归一化到[-1, 1]之间</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-2-训练集和验证集预处理"><a href="#3-2-训练集和验证集预处理" class="headerlink" title="3.2 训练集和验证集预处理"></a>3.2 训练集和验证集预处理</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 训练集预处理  </span>train_transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>      transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># Resize the input image to the given size.因此将参数设置为论文中网络输入的参数大小  </span>    transforms<span class="token punctuation">.</span>RandomVerticalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># 随机垂直旋转，使数据集更多  </span>    transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># 转换为张量  </span>    normalize  <span class="token comment"># 归一化  </span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment">#验证集预处理  </span>val_transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>      transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      normalize  <span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[[#^Compose]]<br>创建数据集👇</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">train_dataset <span class="token operator">=</span> ImageFolder<span class="token punctuation">(</span>ROOT_TRAIN<span class="token punctuation">,</span> transform<span class="token operator">=</span>train_transform<span class="token punctuation">)</span>  val_dataset <span class="token operator">=</span> ImageFolder<span class="token punctuation">(</span>ROOT_TEST<span class="token punctuation">,</span> transform<span class="token operator">=</span>val_transform<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>ImageFolder</code>用于创建一个数据集，该数据集包含了图像数据和相应的标签</p><p>👇设置批量加载</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">train_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>train_dataset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  val_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>val_dataset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>DataLoader</code>用于从数据集中加载批量数据的工具<br>每批数据有32个样本<br><code>shuffle=True</code>表示每个<code>epoch</code>开始前对数据继续随机排序</p><h2 id="3-4-使用GPU加载数据"><a href="#3-4-使用GPU加载数据" class="headerlink" title="3.4 使用GPU加载数据"></a>3.4 使用GPU加载数据</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">device <span class="token operator">=</span> <span class="token string">'cuda'</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">'cpu'</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>device<span class="token punctuation">)</span>  model <span class="token operator">=</span> MyAlexNet<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>  <span class="token comment"># 将'MyAlexNet'实例化对象移动到'device'上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-5-定义损失函数和优化器并设置学习率"><a href="#3-5-定义损失函数和优化器并设置学习率" class="headerlink" title="3.5 定义损失函数和优化器并设置学习率"></a>3.5 定义损失函数和优化器并设置学习率</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义一个损失函数  </span>loss_fn <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 定义一个优化器  </span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span> momentum<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">)</span>  <span class="token comment"># 将模型参数传给优化器  </span><span class="token comment"># 学习率每隔10轮变为原来的0.5  </span>lr_scheduler <span class="token operator">=</span> lr_scheduler<span class="token punctuation">.</span>StepLR<span class="token punctuation">(</span>optimizer<span class="token punctuation">,</span> step_size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> gamma<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token comment"># 帮助优化器再训练过程中逐步减小学习率</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-6-定义训练函数和损失函数"><a href="#3-6-定义训练函数和损失函数" class="headerlink" title="3.6 定义训练函数和损失函数"></a>3.6 定义训练函数和损失函数</h2><p>①从<code>dataloader</code>中取出图像数据和对应的标签<br>②计算<code>cur_loss</code>和<code>cur_acc</code>^train</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>dataloader<span class="token punctuation">,</span> model<span class="token punctuation">,</span> loss_fn<span class="token punctuation">,</span> optimizer<span class="token punctuation">)</span><span class="token punctuation">:</span>loss<span class="token punctuation">,</span> current<span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0</span>  <span class="token keyword">for</span> batch<span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>dataloader<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 将数据取出来训练  </span>    image<span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>      output <span class="token operator">=</span> model<span class="token punctuation">(</span>image<span class="token punctuation">)</span>      cur_loss <span class="token operator">=</span> loss_fn<span class="token punctuation">(</span>output<span class="token punctuation">,</span> y<span class="token punctuation">)</span>      _<span class="token punctuation">,</span> pred <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>      cur_acc <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>y<span class="token operator">==</span>pred<span class="token punctuation">)</span><span class="token operator">/</span>output<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>③反向传播</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 反向传播  </span>optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>  cur_loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>  optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>④计算$\dfrac{所有损失值}{个数}$和$\dfrac{所有正确值}{个数}$</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss <span class="token operator">+=</span> cur_loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>  current <span class="token operator">+=</span> cur_acc<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>  n <span class="token operator">=</span> n<span class="token operator">+</span><span class="token number">1</span>train_loss <span class="token operator">=</span> loss <span class="token operator">/</span> n  train_acc <span class="token operator">=</span> current <span class="token operator">/</span> n  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'train_loss'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>train_loss<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'train_acc'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>train_acc<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> train_loss<span class="token punctuation">,</span> train_acc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>损失函数除了不需要反向传播，其他都和训练函数类似</p><h2 id="3-7-定义画图函数"><a href="#3-7-定义画图函数" class="headerlink" title="3.7 定义画图函数"></a>3.7 定义画图函数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 定义一个画图函数  </span><span class="token keyword">def</span> <span class="token function">matplot_loss</span><span class="token punctuation">(</span>train_loss<span class="token punctuation">,</span> val_loss<span class="token punctuation">)</span><span class="token punctuation">:</span>      plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>train_loss<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'train_loss'</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>val_loss<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'val_loss'</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'best'</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'loss'</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'epoch'</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"训练集和验证集loss值对比图"</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">matplot_acc</span><span class="token punctuation">(</span>train_acc<span class="token punctuation">,</span> val_acc<span class="token punctuation">)</span><span class="token punctuation">:</span>      plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>train_acc<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'train_acc'</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>val_acc<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'val_acc'</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'best'</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'acc'</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'epoch'</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"训练集和验证集acc值对比图"</span><span class="token punctuation">)</span>      plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-8-开始训练"><a href="#3-8-开始训练" class="headerlink" title="3.8 开始训练"></a>3.8 开始训练</h2><p>①初始化四个<code>list</code>，定义<code>epoch</code>和<code>min_acc</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss_train <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  acc_train <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  loss_val <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  acc_val <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>epoch <span class="token operator">=</span> <span class="token number">20</span>  min_acc <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 最小精确度，找出最好的模型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②调用<code>train</code>和<code>val</code>函数进行训练<br>[[#^train]]</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> t <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>epoch<span class="token punctuation">)</span><span class="token punctuation">:</span>      lr_scheduler<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"epoch</span><span class="token interpolation"><span class="token punctuation">{</span>t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span></span><span class="token string">\n-------"</span></span><span class="token punctuation">)</span>      train_loss<span class="token punctuation">,</span> train_acc <span class="token operator">=</span> train<span class="token punctuation">(</span>train_dataloader<span class="token punctuation">,</span> model<span class="token punctuation">,</span> loss_fn<span class="token punctuation">,</span> optimizer<span class="token punctuation">)</span>      val_loss<span class="token punctuation">,</span> val_acc <span class="token operator">=</span> val<span class="token punctuation">(</span>val_dataloader<span class="token punctuation">,</span> model<span class="token punctuation">,</span> loss_fn<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>③计算得到的<code>train_loss</code>、<code>train_acc</code>、<code>val_loss</code>、<code>val_acc</code>分别放入到初始化的四个<code>list</code>中</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 列表  </span>loss_train<span class="token punctuation">.</span>append<span class="token punctuation">(</span>train_loss<span class="token punctuation">)</span>  acc_train<span class="token punctuation">.</span>append<span class="token punctuation">(</span>train_acc<span class="token punctuation">)</span>  loss_val<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val_loss<span class="token punctuation">)</span>  acc_val<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val_acc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>④保存最好的权重和最后一轮的权重</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 保存最好的权重  </span><span class="token keyword">if</span> val_acc <span class="token operator">&gt;</span> min_acc<span class="token punctuation">:</span>      folder <span class="token operator">=</span> <span class="token string">'save_model'</span>      <span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>folder<span class="token punctuation">)</span><span class="token punctuation">:</span>          os<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span><span class="token string">'save_model'</span><span class="token punctuation">)</span>      min_acc <span class="token operator">=</span> val_acc      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"save best model, 第</span><span class="token interpolation"><span class="token punctuation">{</span>t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span></span><span class="token string">轮"</span></span><span class="token punctuation">)</span>      torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>model<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'save_model/best_model.pth'</span><span class="token punctuation">)</span>  <span class="token comment"># 保存最后一轮的权重文件  </span><span class="token keyword">if</span> t <span class="token operator">==</span> epoch<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>      torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>model<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'save_model/last_model.pth'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果有<code>val_acc</code>(某一个轮次训练得到的)大于<code>min_acc</code>，则说明该次的训练效果暂时是目前最好的，保存到<code>.save_model/best_model.pth</code>中</p><h2 id="3-9-画图"><a href="#3-9-画图" class="headerlink" title="3.9 画图"></a>3.9 画图</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">matplot_loss<span class="token punctuation">(</span>loss_train<span class="token punctuation">,</span> loss_val<span class="token punctuation">)</span>  matplot_acc<span class="token punctuation">(</span>acc_train<span class="token punctuation">,</span> acc_val<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="4-编写test-py"><a href="#4-编写test-py" class="headerlink" title="4 编写test.py"></a>4 编写test.py</h1><h2 id="4-1-训练集和验证集预处理、调用GPU"><a href="#4-1-训练集和验证集预处理、调用GPU" class="headerlink" title="4.1 训练集和验证集预处理、调用GPU"></a>4.1 训练集和验证集预处理、调用GPU</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">train_transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>      transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># Resize the input image to the given size.因此将参数设置为论文中网络输入的参数大小  </span>    transforms<span class="token punctuation">.</span>RandomVerticalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># 随机垂直旋转，使数据集更多  </span>    transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># 转换为张量  </span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment">#验证集预处理  </span>val_transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>      transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      normalize  <span class="token punctuation">]</span><span class="token punctuation">)</span>train_dataset <span class="token operator">=</span> ImageFolder<span class="token punctuation">(</span>ROOT_TRAIN<span class="token punctuation">,</span> transform<span class="token operator">=</span>train_transform<span class="token punctuation">)</span>  val_dataset <span class="token operator">=</span> ImageFolder<span class="token punctuation">(</span>ROOT_TEST<span class="token punctuation">,</span> transform<span class="token operator">=</span>val_transform<span class="token punctuation">)</span>    train_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>train_dataset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>  val_dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>val_dataset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    device <span class="token operator">=</span> <span class="token string">'cuda'</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">'cpu'</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>device<span class="token punctuation">)</span>  model <span class="token operator">=</span> MyAlexNet<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>  <span class="token comment"># 将'MyAlexNet'实例化对象移动到'device'上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-加载模型"><a href="#4-2-加载模型" class="headerlink" title="4.2 加载模型"></a>4.2 加载模型</h2><p>加载<code>best_model.pth</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">"E:/Project/Cat_and_Dog_Classification/save_model/best_model.pth"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-3-验证阶段"><a href="#4-3-验证阶段" class="headerlink" title="4.3 验证阶段"></a>4.3 验证阶段</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">model<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token number">3010</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      x<span class="token punctuation">,</span> y <span class="token operator">=</span> val_dataset<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> val_dataset<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># x为第i张照片的的图片，y为第i张图片的标签  </span>    show<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>      x <span class="token operator">=</span> Variable<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span>x<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>      x <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>model.eval()</code><br>[[#^eval]]<br><code>torch.unsqueeze(x, dim=0)</code>将<code>x</code>在维度0上添加一个维度，大小为1(批次维度)</p><p>在禁止梯度计算的情况下得到<code>predicted</code>和<code>actual</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      pred <span class="token operator">=</span> model<span class="token punctuation">(</span>x<span class="token punctuation">)</span>      predicted<span class="token punctuation">,</span> actual <span class="token operator">=</span> classes<span class="token punctuation">[</span>torch<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>pred<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> classes<span class="token punctuation">[</span>y<span class="token punctuation">]</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'predicted:"</span><span class="token interpolation"><span class="token punctuation">{</span>predicted<span class="token punctuation">}</span></span><span class="token string">", Actual:"</span><span class="token interpolation"><span class="token punctuation">{</span>actual<span class="token punctuation">}</span></span><span class="token string">"'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>pred</code>：<code>tensor([[-2.1302,  2.3210]], device='cuda:0')</code><br><code>y</code>：<code>0</code>(Cat)或者<code>1</code>(Dog)</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 卷积神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RNN(李宏毅)</title>
      <link href="/2023/11/06/rnn-li-hong-yi/"/>
      <url>/2023/11/06/rnn-li-hong-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Example-Application"><a href="#1-Example-Application" class="headerlink" title="1 Example Application"></a>1 Example Application</h1><h2 id="1-1-Slot-Filling"><a href="#1-1-Slot-Filling" class="headerlink" title="1.1 Slot Filling"></a>1.1 Slot Filling</h2><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106133700.png"><br>👆句子中只有<strong>Taipei</strong>和<strong>November</strong> $2^{nd}$ 属于两个slot中，其余词汇不属于任何slot</p><h2 id="1-2通过feedforward-network实现slot-filling"><a href="#1-2通过feedforward-network实现slot-filling" class="headerlink" title="1.2通过feedforward network实现slot filling"></a>1.2通过feedforward network实现slot filling</h2><p>Input : a word<br>(Each word is represented as a vector):</p><ol><li>1-of-N encoding</li><li>beyond 1-of-N encoding<ol><li>dimension for “other”：在1-of-N encoding多加一个dimension，这个dimension代表other(没见过的词汇)<br> <img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107222413.png"><br> 2.word hashing<br> <img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106134607.png"></li></ol></li></ol><p>Output：probability distribution that the input word belonging to the slots</p><h2 id="1-3Problem"><a href="#1-3Problem" class="headerlink" title="1.3Problem"></a>1.3Problem</h2><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106135520.png"><br>input Taipei这个词汇，要么都是destination几率最高，要么都是place of departure几率最高👉我们希望nerual network是有记忆力的👉如果他能记住arrive和leave那他的output就可以不同</p><h2 id="1-4-Solution"><a href="#1-4-Solution" class="headerlink" title="1.4 Solution"></a>1.4 Solution</h2><p>使用Recurrent Neural Network时，要先给memory的起始值<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106140426.png"><br>👆初始值为0，输入为1，绿色neuron接收1、1和0、0<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106140717.png"><br>👆$y_1=4$、$y_2=4$<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106140826.png"><br>👆绿色neuron里memory的值变成2<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106140937.png"><br>👆第二次输入[1,1]<br>如果input的顺序不一样，output的内容也会不一样</p><p>总况：<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106141627.png"><br>在memory中store不同的values使得Taipei的slot不同，一个是destination一个是place of departure</p><h1 id="2-Deep-hidden-layer-RNN"><a href="#2-Deep-hidden-layer-RNN" class="headerlink" title="2 Deep hidden layer RNN"></a>2 Deep hidden layer RNN</h1><p>👇每一个绿色框是一个hidden layer，蓝色箭头是hidden layer的值memory<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106144457.png"></p><h2 id="2-1-Elman-Network"><a href="#2-1-Elman-Network" class="headerlink" title="2.1 Elman Network"></a>2.1 Elman Network</h2><p>👇hidden layer的值先存起来，下一个时间点再读出来<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106144650.png"></p><h2 id="2-2-Jordan-Network"><a href="#2-2-Jordan-Network" class="headerlink" title="2.2 Jordan Network"></a>2.2 Jordan Network</h2><p>👇把output的值先存在memory里面，下一个时间点再读出来<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106144747.png"></p><h2 id="2-3-Bidirectional-RNN"><a href="#2-3-Bidirectional-RNN" class="headerlink" title="2.3 Bidirectional RNN"></a>2.3 Bidirectional RNN</h2><p>👇同时train正向和逆向的RNN，把正向和逆向的output都丢到output layer产生$y^t$<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106150157.png"><br>相当于看了整个sequence</p><h1 id="3-Long-Short-term-Memory"><a href="#3-Long-Short-term-Memory" class="headerlink" title="3 Long Short-term Memory"></a>3 Long Short-term Memory</h1><p>4 input:①想要存到memory中的值 ②操控Input Gate的信号 ③操控Output Gate的信号 ④操控Forget Gate的信号<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106151107.png"></p><p>$f(z_i)$决定$g(z)$能否输入<br>Forget Gate被关闭，即$f(z_f)$数值为0时代表遗忘，反之为记忆<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106210058.png"></p><h2 id="3-1-LSTM-Example"><a href="#3-1-LSTM-Example" class="headerlink" title="3.1 LSTM - Example"></a>3.1 LSTM - Example</h2><p>t时刻对memory的影响会在t+1时刻体现<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106211702.png"></p><p>weight 和 bias用training data通过gradient descent得到的<br>LSTM vs original network: 4 times of parameter</p><ul><li>*$x^t$乘上一个transform得到vector$z$，vector$z$的每一个dimension操控每一个LSTM的input，$z$的dimension数目=LSTM memory cell的数目，$z^i$、$z^o$、$z^f$同理</li><li>*$z^i$、$z^o$、$z^f$、$z$丢到cell里的值只是他们其中的一个dimension</li><li>$c^{t-1}$、$h^{t-1}$、$x^t$一起乘transform然后作为输入<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231106223442.png"></li></ul><h2 id="3-2-Learning-Target"><a href="#3-2-Learning-Target" class="headerlink" title="3.2 Learning Target"></a>3.2 Learning Target</h2><p>有一个training sentence，要给sentence里的每一个word一个label<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107165449.png"><br>👇输入arrive得到一个vetor，vetor中dimension<code>other</code>的值为1，其余为0。在丢$x^2$之前要先丢$x^1$<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107165849.png"><br>reference vector(红色那条)的长度就是slot的数目</p><p>👇RNN可以用gradient descent train出来<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107170120.png"></p><h2 id="3-3-Problem"><a href="#3-3-Problem" class="headerlink" title="3.3 Problem"></a>3.3 Problem</h2><p>👇RNN-based network is not always easy to learn<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107171122.png"><br>👇从最右边的橙色点update到中间的再update到左边的橙色点，Total Loss突然暴增<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107171305.png"><br>👇Error Surface 最左边橙色的点的位置的gradient很大，一开始的gradient很小，learning rate有可能设置得很高，导致$gradient$ x $learning$ $rate$会很大，就像开飞机一样<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107194049.png"><br>👆解决办法：设置threshold value，当gradient大于某值时将gradient设置为某值</p><p>RNN的问题在于time sequence的weigh在不同的时间点会被反复使用<br>👇$w$等于$1$、$1.01$、$0.99$、$0.01$时，$y$的取值变化都会很大<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107200606.png"></p><h2 id="3-4-Solution"><a href="#3-4-Solution" class="headerlink" title="3.4 Solution"></a>3.4 Solution</h2><p><strong>LSTM</strong></p><ol><li>Can deal with gradient vanishing(not gradient explode) 不会出现error surface很平坦的地方，可以解决梯度消失的问题👉所以learning rate可以设置得小一点</li><li>RNN vs LSTM<ol><li>RNN中每个时间$t$ memory的值会被覆盖掉</li><li>LSTM中<ol><li>每个时间$t$ menory and input are <strong>added</strong>👉解决梯度消失</li><li>The influence never disappears unless forget gate is closed，只有foget gate关上才有可能导致LSTM不断更新input和memory的值</li><li>No gradient vanishing(If forget gate is opened)</li></ol></li></ol></li></ol><h1 id="4-More-Applications"><a href="#4-More-Applications" class="headerlink" title="4 More Applications"></a>4 More Applications</h1><h2 id="4-1-Sequence-to-sequence"><a href="#4-1-Sequence-to-sequence" class="headerlink" title="4.1 Sequence-to-sequence"></a>4.1 Sequence-to-sequence</h2><ol><li>Input is a vector sequence, but output is only one vector(Many to  One)<ol><li>Sentiment Analysis</li><li>Key Term Extraction</li></ol></li><li>Both input and output are both sequences, but the output is shorter(Many to Many)<ol><li>Speech Recognition</li><li>Connectionist Temporal Classification(CTC)<ol><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107205719.png"></li><li>把右边三种结果都视为正确丢到training data中 <img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107205955.png"></li><li>机器不需要认识某个词汇<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107210143.png"></li></ol></li><li>Sequence to sequence learning(Many to Many(No Limitation))<ol><li>RNN的input和output都是sequence，input和output的长度不确定。除此之外，在最后一个时间点，memory里存了所有input sequence的information，然后就让machine开始吐character，再将之前的output的character作为input，再读取上一个memory的值，继续output</li><li>Problem:Don’t know when to stop<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107222413.png"></li><li>Solution:Add a symbol “===“断<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231107222616.png"></li></ol></li></ol></li><li>Sequence-to-sequence Auto-encoder<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231108102135.png"><br>👆RNN Encoder和RNN Decoder是一起train的，目的是让train出来的$y_1$、$y_2$、$y_3$、$y_4$与$x_1$、$x_2$、$x_3$、$x_4$相近</li></ol><h2 id="4-2-Attention-based-Model"><a href="#4-2-Attention-based-Model" class="headerlink" title="4.2 Attention-based Model"></a>4.2 Attention-based Model</h2><p>👇中央处理器DNN/RNN操控Reading Head Controller、读写头决定Reading Head放的位置<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231108102942.png"><br>👇版本Ⅱ Neural Turing Machine(2014)<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231108103018.png"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 循环神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN(李宏毅)</title>
      <link href="/2023/11/04/cnn-li-hong-yi/"/>
      <url>/2023/11/04/cnn-li-hong-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Image-Classification"><a href="#1-Image-Classification" class="headerlink" title="1 Image Classification"></a>1 Image Classification</h1><p>一张100x100pixels的图片其实是一个3D-tensor：<br>①图片的高<code>100</code>②图片的宽<code>100</code>③3 channels<code>RGB</code><br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231104203002.png"><br>每一个数值代表某一个颜色某一个pixel的强度</p><h1 id="2-Image-Feature-Observation"><a href="#2-Image-Feature-Observation" class="headerlink" title="2 Image Feature Observation"></a>2 Image Feature Observation</h1><h2 id="2-1-Observation-1"><a href="#2-1-Observation-1" class="headerlink" title="2.1 Observation 1"></a>2.1 Observation 1</h2><ol><li><p>Identifying some critical patterns<br> 比如说一只鸟，只用看鸟嘴、眼睛和脚也能大致辨认出来<br> A neuron does not have to see the whole image</p></li><li><p>Simplification<br> 设定一个区域为Receptive field，每一个neuron只关心自己的Receptive field。<br> Receptive field can be overlapped<br> neuron can have the same receptive field<br> <img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231104204207.png"></p></li><li><p>Simplification 1-Typical Setting</p></li><li><p>会看all channels，不用提深度，高和宽合起来叫kernel size</p></li><li><p>Each receptive field has a set of neurons</p></li><li><p>平移receptive field，步长为stride，receprive field有重叠，防止交界处有pattern没被neuron侦测到</p></li><li><p>平移时超出范围了，用填补0代替超出的范围(方法不唯一)</p></li></ol><h2 id="2-2-Observation-2"><a href="#2-2-Observation-2" class="headerlink" title="2.2 Observation 2"></a>2.2 Observation 2</h2><ol><li>The same patterns appear in different regions<br> 👇solution: parameter sharing<br> 线条代表weight，相同颜色代表weight一样，守备的receptive field不一样，参数一样，因为输入不一样，所以输出也不一样<br> <img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231104215341.png"></li><li>Simplification 2-Typical Setting<ol><li>每一个receptive field都有一组neurons</li><li>相同颜色的圆圈代表共享一样的参数的neurons</li><li>每一个receptive field都只有一组参数，这些参数叫filter x<br> <img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231104215840.png"></li></ol></li></ol><h2 id="2-3-Obeservation-3"><a href="#2-3-Obeservation-3" class="headerlink" title="2.3 Obeservation 3"></a>2.3 Obeservation 3</h2><p>Subsampling the pixels will not change the object<br>e.g.拿掉image奇数行和偶数列的pixels，图片变成原来的$\frac{1}{4}$大小</p><h1 id="3-Benefit-of-Convolutional-Layer"><a href="#3-Benefit-of-Convolutional-Layer" class="headerlink" title="3 Benefit of Convolutional Layer"></a>3 Benefit of Convolutional Layer</h1><ul><li><code>Fully Connected Layer</code>不需要看整个图片，只需要重要的pattern👉<code>receptive field</code>某一些neurons一定要一摸一样👉<code>parameter sharing</code></li><li><code>receptive field</code>+<code>parameter sharing</code>=<code>convolutional layer</code>，虽然会有较大的model bias，但是convolutional layer是专门为影像设计的，所以用在image上偏差不会很大</li><li>用<code>convolutional layer</code>的network叫做<code>CNN</code></li></ul><h1 id="4-Multiple-Convolutional-Layers"><a href="#4-Multiple-Convolutional-Layers" class="headerlink" title="4 Multiple Convolutional Layers"></a>4 Multiple Convolutional Layers</h1><ul><li>n个filters可形成feature map with n channels</li><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231104223016.png"><ol><li>先是将<code>RGB</code>图片放入convolution里，假设有64个filter(每个filter都是3x3x3)，那么就会得到一个 feature map(可以看作是一个新的图片，只是他的channels有64个) </li><li>再把feature map放入convolution里，filter的大小为：3x3x<strong>64</strong>(filter的高度就是它要处理的image的channel)</li></ol></li><li>filter比较小的情况下也能让network看比较大范围的pattern<br>   <img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231104224407.png"><br>   右下角蓝色圆圈的是其中一个filter，右上角是image，image左上角红色框对应filter左上角红色框，image右下角红色框对应filter右下角红色框。feature map的3x3对应image的5x5<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231104225301.png"></li></ul><h1 id="5-Pooling-Max-Pooling"><a href="#5-Pooling-Max-Pooling" class="headerlink" title="5 Pooling - Max Pooling"></a>5 Pooling - Max Pooling</h1><p>在feature map中，n x n个数字一组<br><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231104225853.png">👉<img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231104225920.png"><br>max pooling就是选一组里最大的那个数<br>做完convolution之后通常会搭配pooling，pooling不改变channels，但是改变长宽</p><h1 id="6-The-whole-CNN"><a href="#6-The-whole-CNN" class="headerlink" title="6 The whole CNN"></a>6 The whole CNN</h1><p>Flatten：将pooling的output本来矩阵的样子拉直</p><h1 id="7-Application-Playing-Go"><a href="#7-Application-Playing-Go" class="headerlink" title="7 Application: Playing Go"></a>7 Application: Playing Go</h1><ul><li>Alpha Go uses 5x5 for first layer，可能是5x5的范围比较重要</li><li>同样可能存在相同的patters在不同的regions里</li><li>不用pooling</li></ul><h1 id="8-实操"><a href="#8-实操" class="headerlink" title="8 实操"></a>8 实操</h1><h2 id="8-1-Code"><a href="#8-1-Code" class="headerlink" title="8.1 Code"></a>8.1 Code</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchvision<span class="token punctuation">.</span>transforms <span class="token keyword">as</span> transformsimage_data <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment"># Your image data here</span><span class="token comment"># Applying the transformations</span>transform <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>    transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.1307</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0.3081</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>transformed_data <span class="token operator">=</span> transform<span class="token punctuation">(</span>image_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-2-原理"><a href="#8-2-原理" class="headerlink" title="8.2 原理"></a>8.2 原理</h2><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231113221316.png"></p><h1 id="9-Advanced-CNN"><a href="#9-Advanced-CNN" class="headerlink" title="9 Advanced CNN"></a>9 Advanced CNN</h1><ul><li>当训练次数过多时会发生过拟合，因此并不是训练次数越多模型准确度越高</li><li>解决梯度消失(过拟合)，使用<strong>Residual net</strong></li></ul><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/DL%26ML_picture/Pasted%20image%2020231119135500.png"><br>$z=H(x)$<br>$\dfrac{\partial z}{x}=\dfrac{\partial F(x)}{\partial x} + \dfrac{\partial x}{\partial x}=\dfrac{\partial F(x)}{\partial x}+1$<br>梯度=$\dfrac{\partial L}{\partial z}\times\dfrac{\partial z}{\partial x}$<br>当$\dfrac{\partial F}{\partial x}$很小的时候，$\dfrac{\partial z}{\partial x}$不会在0的附近</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 卷积神经网络 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐含迪利克雷模型LDA</title>
      <link href="/2023/05/21/lda-mo-xing/"/>
      <url>/2023/05/21/lda-mo-xing/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/v_JULY_v/article/details/41209515?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;utm_relevant_index=2">参考博客</a></p><p><a href="https://oa7vrw2neqh.feishu.cn/docx/CB0WdZbkioi90JxOFTVczXfmngd">飞书版笔记(带pdf)</a></p><h1 id="1-整体把握"><a href="#1-整体把握" class="headerlink" title="1.整体把握"></a>1.整体把握</h1><p>LDA是一种<strong>主题模型</strong>，可以将文档集中每篇文档的主题以<strong>概率分布</strong>的形式给出，根据给定的一篇文章，反推其主题分布</p><p>一篇文档可以包含多个主题，文档中每一个词都由其中的一个主题生成</p><h2 id="1-1LDA的图模型结构"><a href="#1-1LDA的图模型结构" class="headerlink" title="1.1LDA的图模型结构"></a>1.1LDA的图模型结构</h2><p>  类似贝叶斯网络结构</p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702178138892.jpg"></p><h3 id="1-1-1贝叶斯的定义"><a href="#1-1-1贝叶斯的定义" class="headerlink" title="1.1.1贝叶斯的定义"></a>1.1.1贝叶斯的定义</h3><p>  节点表示随机变量${X_1,X_2,…,X_n}$，认为有<strong>因果关系</strong>(或非条件独立)的变量或命题用箭头来连接。如果用一个单箭头来连接，表示其中一个节点是“因(parents)”，另一个是“果(children)”，两节点就会产生一个条件概率值</p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177828629.jpg"></p><p>  👆圈表示随机变量(random variables)，用箭头表示条件依赖(conditional dependencies)</p><p>  令$G = (I,E)$表示一个有向无环图(DAG)，其中I代表图形中所有的节点的集合，而E代表有向连接线段的集合，且令$X = (X_i),i ∈ I$为其有向无环图中的某一节点i所代表的随机变量，若节点X的联合概率可以表示成$p(x)=\prod\limits_{i\in I}p(x_i|x_{pa(i)})$，则称$X$为相对于一有向无环图G 的贝叶斯网络，其中，$pa(i)$表示节点i之“因”，或称$pa(i)$是$i$的parents（父母）。</p><p>  联合概率：事件A和事件B同时发生的概率，记为$P(AB)$或$P(A,B)$或$P(A∩B)$</p><p>  对于任意的随机变量，其联合概率可由各自的局部条件概率分布相乘得出：</p><p>  $p(x_1,….,x_K)=p(x_K|x_1,….,x_{K-1})…p(x_2|x_1)p(x_1)$</p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177836358.jpg"></p><p>  👆一个简单的贝叶斯网络(a导致b，a和b导致c)</p><p>  $p(a,b,c)=p(c|a.b)p(b|a)p(a)$</p><h2 id="1-2二项式分布"><a href="#1-2二项式分布" class="headerlink" title="1.2二项式分布"></a>1.2二项式分布</h2><p>随机变量只有两个(非正即负)，即重复n次的伯努利实验，记为$X\sim b(n,p)$</p><p>二项分布的概率密度函数为：</p><p>$P(K=k)=(n,k)p^k(1-p)^{n-k}$</p><p> 对于k = 0, 1, 2, …, n，其中的</p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177851194(1).jpg"></p><p>是二项式系数（这就是二项分布的名称的由来），又记为$\dfrac{n!}{k!(n-k)!}$</p><h2 id="1-3多项式分布"><a href="#1-3多项式分布" class="headerlink" title="1.3多项式分布"></a>1.3多项式分布</h2><p>由二项分布扩展到多维的情况</p><p>随机变量取值不是0-1，而是有多种离散值的可能(1,2,3,…,k)</p><p>假设有$i$个离散值，那么有$\sum_{i=1}^kp_i=1,p_i&gt;0$</p><p>多项式分布的概率密度函数为：$P(x_1,x_2,…,x_k;n,p_1,p_2,…,p_k)=\dfrac{n!}{x_1!…x_k!}p^{x_1}…p^{x_k}$</p><h2 id="1-4Gamma分布"><a href="#1-4Gamma分布" class="headerlink" title="1.4Gamma分布"></a>1.4Gamma分布</h2><p><a href="https://zhuanlan.zhihu.com/p/69606875">Beta函数和Gamma函数的关系</a></p><p>Gamma函数实际意义：阶乘一般化，将阶乘推广到实数域</p><p>This content is only supported in a Feishu Docs</p><h1 id="2-Beta分布"><a href="#2-Beta分布" class="headerlink" title="2.Beta分布"></a>2.Beta分布</h1><p>This content is only supported in a Feishu Docs</p><h2 id="2-1Beta分布"><a href="#2-1Beta分布" class="headerlink" title="2.1Beta分布"></a>2.1Beta分布</h2><p>beta是指一组定义在$(0,1)$区间的连续概率分布，有两个参数$\alpha$和$\beta$，且$\alpha,\beta&gt;0$</p><p>二项分布的共轭先验分布</p><p>给定参数$\alpha&gt;0$和$\beta&gt;0$，取值范围为[0,1]的随机变量 x 的概率密度函数：$f(x;\alpha,\beta)=\dfrac{1}{B(\alpha,\beta)}x^{\alpha-1}(1-x)^{\beta-1}$</p><p>其中$\dfrac{1}{B(\alpha,\beta)}=\dfrac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)},\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt$</p><p>见pdf</p><h2 id="2-2Beta-Binomial共轭"><a href="#2-2Beta-Binomial共轭" class="headerlink" title="2.2Beta-Binomial共轭"></a>2.2Beta-Binomial共轭</h2><ul><li>问题引入：<ul><li><strong>问题1</strong>：随机变量$X_1,X_2,…,X_n\sim^{idd}Uniform(0,1)$，把这n个随机变量排序后得到顺序统计量$X_{(1)},X_{(2)},…,X_{(n)}$，问$X_{(k)}$的分布是什么</li><li><strong>问题2</strong>：$X_{(k)}$的分布是什么 &lt;==&gt; 猜测$p=X_{(k)}$，<ul><li>$Y_1,Y_2,…,Y_n\sim^{idd}Uniform(0,1)$,$Y_i$中有$m_1$个比$p$小，$m_2$个比$p$大，问$P(p|Y_1,Y_2,…Y_m)$的分布是什么</li></ul></li></ul></li><li>分析：<ul><li>换言之，$Y_i$中有$m_1$个比$X_{(k)}$小，有$m_2$个比$X_{(k)}$大，所以$X_{(k)}$是$X_1,X_2,…,X_n,Y_1,Y_2,…,Y_n\sim^{idd}Uniform(0,1)$中第$k+m_1$大的数</li><li>事件服从Beta分布</li><li>可知$p=X_{(k)}$的密度概率函数为：$Beta(p|k+m_1,n-k+1+m_2)$</li></ul></li><li>与贝叶斯结合过程<ul><li><p>贝叶斯派思考问题的固定模式：</p></li><li><p><strong>先验分布</strong>$\pi(\theta)$<strong>+ 样本信息</strong>$X$$\rightarrow$<strong>后验分布</strong>$\pi(\theta|x)$</p></li><li><p>在得到新的样本信息之前，人们对$\theta$的认知是先验分布$\pi(\theta)$，在得到新的样本信息</p><p>$X$后，人们对$\theta$的认知为$\pi(\theta|x)$</p></li><li><p>过程</p><ul><li>为了猜测$p=X_{(k)}$，在获得一定的观测数据前，我们对$p$的认知是：$f(p)=Beta(p|k,n-k+1)$，此称为$p$的先验分布</li><li>为了获得结果$Y_i$中有$m_1$个比$p$小，$m_2$个比$p$大，针对$Y_i$做了$m$次伯努利实验，所以$m_1$服从二项分布$B(m,p)$</li><li>在得到$(m_1,m_2)$的数据后，$p$的后验分布为$f(p|m_1,m_2)=Beta(p|k+m_1,n-k+1+m_2)$</li></ul></li><li><p>结合贝叶斯</p><ul><li>$Beta(p|k,n-k+1)+Count(m_1,m_2)=Beta(p|k+m_1,n-k+1+m_2)$</li><li>更一般的，对于非负实数$\alpha$和$\beta$：有如下关系$Beta(p|\alpha,\beta)+Count(m_1,m_2)=Beta(p|\alpha+m_1,\beta+m_2)$，其中$Count(m_1,m_2)$对应$B(m,p)$</li><li>针对这种观测到的数据符合以下条件的，就是Beta-Binomial共轭，换言之，Beta分布是二项式分布的共轭先验概率分布<ul><li>条件一：二项分布</li><li>条件二：参数的先验分布和后验分布都是Beta分布</li><li>共轭先验分布→2.3</li></ul></li><li>二项分布和Beta分布是共轭分布意味着，如果我们为二项分布的参数p选取的先验分布是Beta分布，那么以p为参数的二项分布用贝叶斯估计得到的后验分布仍然服从Beta分布</li></ul></li><li><p>$\alpha$和$\beta$可以认为是形状参数</p></li></ul></li></ul><h2 id="2-3共轭先验分布"><a href="#2-3共轭先验分布" class="headerlink" title="2.3共轭先验分布"></a>2.3共轭先验分布</h2><p>如果后验概率和先验概率满足同样的分布律，那么先验分布和后验分布被叫做共轭分布，同时，先验分布叫做似然函数的共轭先验分布。</p><p>  比如，某观测数据服从概率分布P(θ)(先验)时，当观测到新的X数据(样本信息)时，我们一般会遇到如下问题：</p><ul><li>可否根据新观测数据X，更新参数θ？</li><li>根据新观测数据可以在多大程度上改变参数θ，即$\theta \leftarrow \theta + \triangle \theta$</li><li>当重新估计θ的时候，给出新参数值θ的新概率分布，即P(θ|x)。</li></ul><h2 id="2-4从Beta分布推广到Dirichlet分布"><a href="#2-4从Beta分布推广到Dirichlet分布" class="headerlink" title="2.4从Beta分布推广到Dirichlet分布"></a>2.4从Beta分布推广到Dirichlet分布</h2><p>见pdf</p><p>结论是：对于Beta分布的随机变量，其均值(期望)可以用$\dfrac{\alpha}{\alpha+\beta}$来估计</p><p>类比到Dirichlet分布：如果$\mathop{p}\limits^{\rightarrow}\sim Dir(\mathop{t}\limits^{\rightarrow}|\mathop{\alpha}\limits^{\rightarrow})$，那么有$E(\mathop{p}\limits^{\rightarrow})=(\dfrac{\alpha_1}{\sum^K_{i=1}\alpha_i},\dfrac{\alpha_2}{\sum^K_{i=1}\alpha_i},…,\dfrac{\alpha_3}{\sum^K_{i=1}\alpha_i})$</p><h1 id="3-Dirichlet分布"><a href="#3-Dirichlet分布" class="headerlink" title="3.Dirichlet分布"></a>3.Dirichlet分布</h1><p>是beta分布在高纬度上的推广</p><p>$f(x_1,x_2,…,x_k;\alpha_1,\alpha_1,…,\alpha_k)=\dfrac{1}{B(\alpha)}\prod_{i=1}^kx_{i}^{a^i-1}$</p><p>其中$B(\alpha)=\dfrac{\prod_{i=1}^k\Gamma(a^i)}{\Gamma(\sum_{i=1}^k)a^i},\sum x_i=1$</p><h2 id="3-1Dirichlet分布"><a href="#3-1Dirichlet分布" class="headerlink" title="3.1Dirichlet分布"></a>3.1Dirichlet分布</h2><p>This content is only supported in a Feishu Docs</p><h2 id="3-2Dirichlet-Multinomial共轭"><a href="#3-2Dirichlet-Multinomial共轭" class="headerlink" title="3.2Dirichlet-Multinomial共轭"></a>3.2Dirichlet-Multinomial共轭</h2><ul><li>问题引入：在2.2的问题2的基础上继续深入<ul><li><strong>问题3</strong>：随机变量$X_1,X_2,…,X_n\sim^{idd}Uniform(0,1)$，把这n个随机变量排序后得到顺序统计量$X_{(1)},X_{(2)},…,X_{(n)}$，问$(X_{(k_1)},X_{k_1+k_2})$的联合分布是什么<ul><li>计算见pdf</li></ul></li><li>为论证Dirichlet分布是多项式分布的共轭先验概率分布，在问题3的基础上继续深入<ul><li>问题4：<ul><li>随机变量$X_1,X_2,…,X_n\sim^{idd}Uniform(0,1)$，把这n个随机变量排序后得到顺序统计量$X_{(1)},X_{(2)},…,X_{(n)}$</li><li>令$p_1=X_{k_1},p_2=X(k_1+k_2),p_3=1-p_1-p_2$，现在要猜测$\mathop{p}\limits^{\rightarrow}=(p_1,p_2,p_3)$</li><li>$Y_1,Y_2,…,Y_m\sim^{idd}Uniform(0,1)$，$Y_i$中落到$(0,p_1],[p_1,p_2),[p_2,1]$三个区间的个数分别为$m_1,m_2,m_3$，$m=m_1+m_2+m_3$</li><li>问后验分布$P(\mathop{p}\limits^{\rightarrow}|Y_1,Y_2,…Y_m)$的分布是什么</li><li>讨论见pdf</li></ul></li></ul></li></ul></li><li>与贝叶斯结合推理：<ul><li>要猜测参数$\mathop{p}\limits^{\rightarrow}=(p_1,p_2,p_3)$，其先验分布为$Dir(\mathop{p}\limits^{\rightarrow}|\mathop{k}\limits^{\rightarrow})$</li><li>$Y_1,Y_2,…,Y_m\sim^{idd}Uniform(0,1)$，$Y_i$中落到$(0,p_1],[p_1,p_2),[p_2,1]$三个区间的个数分别为$m_1,m_2,m_3$，所以$\mathop{m}\limits^{\rightarrow}=(m_1,m_2,m_3)$服从多项分布$Mult(\mathop{m}\limits^{\rightarrow}|\mathop{p}\limits^{\rightarrow})$</li><li>给定了来自数据提供的$\mathop{m}\limits^{\rightarrow}$后，$\mathop{p}\limits^{\rightarrow}$的后验分布变为$Dir(\mathop{p}\limits^{\rightarrow}|\mathop{k}\limits^{\rightarrow}+\mathop{m}\limits^{\rightarrow})$</li><li>直观表述：<ol><li>$Dir(\mathop{p}\limits^{\rightarrow}|\mathop{k}\limits^{\rightarrow})+MultCount(\mathop{m}\limits^{\rightarrow})=Dir(\mathop{p}\limits^{\rightarrow}|\mathop{k}\limits^{\rightarrow}+\mathop{m}\limits^{\rightarrow})$</li><li>令$\mathop{\alpha}\limits^{\rightarrow}=\mathop{k}\limits^{\rightarrow}，可以把$\mathop{\alpha}\limits^{\rightarrow}$从整数集合延拓到实数集合，从而得到更一般的表达：</li><li>$Dir(\mathop{p}\limits^{\rightarrow}|\mathop{\alpha}\limits^{\rightarrow})+MultCount(\mathop{m}\limits^{\rightarrow})=Dir(\mathop{p}\limits^{\rightarrow}|\mathop{\alpha}\limits^{\rightarrow}+\mathop{m}\limits^{\rightarrow})$</li></ol></li></ul></li><li>结论：<ul><li>观测到的数据符合多项分布</li><li>参数的先验分布和后验分布都是Dirichlet分布</li><li>就是Dirichlet-Multinomial共轭</li><li>一般形式的Dirichlet分布定义和对于给定的$\mathop{p}\limits^{\rightarrow}$和$N$，其多项式分布见pdf</li><li>Dirichlet分布$Dir(\mathop{p}\limits^{\rightarrow}|\mathop{\alpha}\limits^{\rightarrow})$和多项分布$MultCount(\mathop{n}\limits^{\rightarrow}|\mathop{p}\limits^{\rightarrow},N)$是共轭关系</li></ul></li></ul><h1 id="4-LDA模型"><a href="#4-LDA模型" class="headerlink" title="4.LDA模型"></a>4.LDA模型</h1><p><strong>定义的变量</strong></p><ul><li>$w$表示词，$V$表示所有单词的个数（固定值）</li><li>$z$表示主题，是主题的个数（预先给定，固定值）</li><li>$D(w_1,…,w_M)$表示语料库，其中的$M$是语料库中的文档数（固定值）</li><li>$\mathbf{w}=(w_1,w_2,…,w_N)$表示文档，其中的$N$表示一个文档中的词数（随机变量）</li></ul><h2 id="4-1各个模型基础"><a href="#4-1各个模型基础" class="headerlink" title="4.1各个模型基础"></a>4.1各个模型基础</h2><h3 id="4-1-1Unigram-model"><a href="#4-1-1Unigram-model" class="headerlink" title="4.1.1Unigram model"></a>4.1.1Unigram model</h3><p>对于文档$\mathbf{w}=(w_1,w_2,…,w_N)$，用$p(w_n)$表示词$w_n$的先验概率，生成文档$\mathbf{w}$的概率为：$p(\mathbf{w})=\sum^N_{n=1}p(w_n)$</p><p>图模型为</p><ul><li><p>图模型一</p><ul><li>(图中被涂色的w(word)表示可观测变量，N表示一篇文档中总共N个单词，M表示M篇文档)</li><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177856933.jpg"></li></ul></li><li><p>图模型二</p><ul><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177862768.jpg"></li><li>nigram model假设文本中的词服从Multinomial分布，而我们已经知道Multinomial分布的先验分布为Dirichlet分布。上图中的$w_n$表示在文本中观察到的第n个词，$n\in[1,N]$表示该文本中一共有$N$个单词。加上方框表示重复，即一共有$N$个这样的随机变量$w_n$。其中，$p$和$\alpha$是隐含未知变量：</li><li>$p$是词服从的Multinomial分布的参数</li><li>$\alpha$是Dirichlet分布(即Multinomial分布的先验分布)的参数</li><li>一般$\alpha$由经验事先给定(先验)，$p$由观察到的文本中出现的词学习得到(样本)，表示文本中出现每个词的概率</li></ul></li></ul><h3 id="4-1-2Mixture-of-unigrams-model"><a href="#4-1-2Mixture-of-unigrams-model" class="headerlink" title="4.1.2Mixture of unigrams model"></a>4.1.2Mixture of unigrams model</h3><p>该模型的生成过程是：给某个文档先选择一个主题$z$，再根据该主题生成文档，该文档中的所有词都来自一个主题。假设主题有$z_1,…z_k$，生成文档$\mathbf{w}$的概率为：</p><p>$p(\mathbf{w})=p(z_1)\prod^N_{n=1}p(w_n|z_1)+…+p(z_k)\prod^N_{n=1}p(w_n|z_k)=\sum_zp(z)\prod^N_{n=1}p(w_n|z)$</p><p>图模型为：(图中被涂色的w表示可观测变量，未被涂色的z表示未知的隐变量，N表示一篇文档中总共N个单词，M表示M篇文档)</p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177867686(1).jpg"></p><h2 id="4-2PLSA模型"><a href="#4-2PLSA模型" class="headerlink" title="4.2PLSA模型"></a>4.2PLSA模型</h2><p>建议直接<a href="https://blog.csdn.net/v_JULY_v/article/details/41209515?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;utm_relevant_index=2">看这个</a></p><h3 id="4-2-1pLSA模型下生成文档"><a href="#4-2-1pLSA模型下生成文档" class="headerlink" title="4.2.1pLSA模型下生成文档"></a>4.2.1pLSA模型下生成文档</h3><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177872673.jpg"></p><h3 id="4-2-2根据文档反推其主题分布"><a href="#4-2-2根据文档反推其主题分布" class="headerlink" title="4.2.2根据文档反推其主题分布"></a>4.2.2根据文档反推其主题分布</h3><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177893244.jpg"></p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177906171.jpg"></p><h3 id="4-2-3EM算法"><a href="#4-2-3EM算法" class="headerlink" title="4.2.3EM算法"></a>4.2.3EM算法</h3><p>This content is only supported in a Feishu Docs</p><h4 id="4-2-3-1EM算法的简单介绍"><a href="#4-2-3-1EM算法的简单介绍" class="headerlink" title="4.2.3.1EM算法的简单介绍"></a>4.2.3.1EM算法的简单介绍</h4><p><a href="https://zhuanlan.zhihu.com/p/78311644">EM算法</a></p><p>隐变量$Z=(z_1,z_2,z_3,z_4,z_5)$代表每一轮所使用的硬币</p><p>所以第一步先估算$Z$，这步同时是E-step</p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177911648.jpg"></p><p>👆流程：</p><ol><li>随机初始化$\theta_A=0.6$和$\theta_B=0.5$(E-step)</li><li>H代表正面，T代表反面；对于第一轮来说，实际的情况是5个正的5个反的，进行如下计算<ol><li>$P_A=\dfrac{0.6^5<em>0.4^5}{(0.6^5</em>0.4^5)+(0.5^5+0.5^5)}=0.45$</li><li>$P_B=\dfrac{(0.5^5+0.5^5)}{(0.6^5*0.4^5)+(0.5^5+0.5^5)}=0.55$<ul><li>​    对于第一轮抛掷，该枚硬币是硬币A的概率为0.45，是硬币B的概率为0.55，其他轮同理，这一步得到了Z的概率分布</li><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177916936.jpg"></li></ul></li></ol></li><li>利用期望求硬币A和硬币B的贡献，对于第一轮来说<ol><li>H：0.45*5=2.25</li><li>T：0.55*5=2.75</li><li>其他轮同理</li><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177922766.jpg"></li><li>用极大似然估计来估计新的$\theta_A$和$\theta_B$，这步就是M-Step<ul><li>$\theta_A=\dfrac{21.3}{21.3+8.6}=0.71$</li><li>$\theta_B=\dfrac{11.7}{11.7+8.4}=0.58$</li></ul></li></ol></li><li>如此反复迭代，可以算出最终的参数值</li><li>$L(\theta)$与$J(z,Q)$的关系<ol><li>这张图的意思是</li><li>先固定$\theta$，调整$Q(z)$使下界$J(z,Q)$上升至与$L(\theta)$在该$\theta$值下相同(由绿线到蓝线)</li><li>然后固定$Q(z)$，调整$\theta$使下界$J(z,Q)$达到最大值</li><li>再固定$\theta$…</li><li>直到收敛到似然函数$L(\theta)$的最大值时，得到该处的$\theta^{*}$</li><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177927472.jpg"></li></ol></li><li>EM算法的整体框架</li></ol><p>Repeat until convergence{</p><p>  (E-step) For each </p><p>$i$</p><p>,set</p><p>​    $Q_i(z):=p(z^{(i)}|x^{(i)};\theta)$                                   找隐变量的分布(直线往上移)</p><p>​     (M-step) Set</p><p>​    $\theta:=arg max_{\theta}\sum_i\sum_{z^{(i)}}log\dfrac{p(x^{(i)},z^{(i)};\theta)}{Q_i(z^{(i)})}$   找新的$\theta$(点位往左右移)</p><p>}</p><h4 id="4-2-3-2EM算法估计pLSA的两个未知参数"><a href="#4-2-3-2EM算法估计pLSA的两个未知参数" class="headerlink" title="4.2.3.2EM算法估计pLSA的两个未知参数"></a>4.2.3.2EM算法估计pLSA的两个未知参数</h4><p>从<strong>矩阵角度</strong>描述带估计的两个未知变量$P(w_j|z_k)$和$P(z_k|d_i)$</p><p>词表$V$有$j$个词项；所有主题$Z$有$k$个主题；有$i$篇文章</p><ul><li>假定用$\phi_k$表示词表$V$在主题$z_k$上的一个多项分布，则$\phi_k$可以表示成一个向量，每个元素$\phi_{k,j}$表示词项$w_j$出现在主题$z_k$中的概率，即：<ul><li>$P(w_j|z_k)=\phi_{k,j}$，$\sum_{w_j\in V}\phi_{k,j}=1$</li></ul></li><li>假定用$\theta_i$表示所有主题$K$在文档$d_i$上的一个多项分布，则$\theta_i$可以表示成一个向量，每个元素$\theta_{i,k}$表示主题$z_k$出现在文档$d_i$中的概率，即：<ul><li>$P(z_k|d_i)=\theta_{i,k}$，$\sum_{z_k\in K}\theta_{i,k}=1$</li></ul></li></ul><p>$P(w_j|z_k)$和$P(z_k|d_i)$转换成了两个矩阵，换言之，我们要求解的参数就是这两个矩阵：</p><ul><li>$\Phi=[\phi_1,…\phi_K], z_k\in Z$</li><li>$\Theta=[\theta_i,…,\theta_M],d_i\in D$</li></ul><p>词和词之间是相互独立的，整篇文档$N$个词的分布为：</p><ul><li>$P(W|d_i)=\prod_{j=1}^NP(d_i,w_j)^{n(d_i,w_j)}$</li></ul><p>文档和文档之间也是相互独立的，整个语料库($M$篇文档,每篇文档$N$个词)中词的分布为</p><ul><li>$P(W|D)=\prod_{i=1}^M\prod_{j=1}^NP(d_i,w_j)^{n(d_i,w_j)}$</li></ul><p>其中，</p><p>$n(d_i,w_j)$表示词项$w_j$在文档$d_i$中的词频</p><p>$n(d_i)$表示文档$d_i$中文档词的总数</p><p>显然有$n(d_i)=\sum_{w_j\in V}n(d_i,w_j)$，一篇文档中词的总数等于词表中每个词出现的次数之和</p><p>整个语料库的词分布的对数似然函数：</p><p>$\begin{align} l(\Phi,\Theta)&amp;=\sum_{i=1}^{M}\sum_{j=1}^Nn(d_i,w_j)logP(d_i,w_j)\ &amp;=\sum_{i=1}^Mn(d_i)\left(logP(d_i)+\sum_{j=1}^N\dfrac{n(d_i,w_j)}{n(d_i)}log\sum_{k=1}^KP(w_j|z_k)P(z_k|d_i)\right)\ &amp;=\sum_{i=1}^Mn(d_i)\left(logP(d_i)+\sum_{j=1}^N\dfrac{n(d_i,w_j)}{n(d_i)}log\sum_{k=1}^K\phi_{k,j}\theta_{i,k}\right) \end{align}$</p><ul><li>(1)对应的是$L(\theta)\geq\sum_{i=1}^n\sum_z^ZQ_i(z)log\dfrac{P(x_i,z;\theta)}{Q_i(z)}$，其中$Q_i(z)$表示的是样本$i$隐含变量$z$的某种分布；$log\dfrac{P(x_i,z;\theta)}{Q_i(z)}$表示的是对数似然函数</li><li>(2)分别求文本的对数似然函数和词的对数似然函数，见pdf</li><li>(3)就是上面得到的以矩阵的形式表达多项式分布</li></ul><p>多元函数在有约束条件$\sum_{j=1}^{M}\theta_{k,j}=1$和$\sum_{k=1}^K\phi_{i,k}=1$下求极值，用拉格朗日乘数法(即通过引入拉格朗日乘子将约束条件和多元(目标)函数融合到一起，转化为无约束条件的极值问题)见pdf</p><p>总结：</p><ol><li>为求得$P(w_j|z_k)$和$P(z_k|d_i)$，因此用EM算法去估计$\theta=(P(w_j|z_k),z_k|d_i)$这个参数</li><li>$\phi_{k,j}$表示词项$w_j$出现在主题$z_k$中的频率，即$P(w_j|z_k)=\phi_{k,j}$，从而把$P(w_j|z_k)$转换成矩阵$\Phi$</li><li>$\theta_{i,k}$表示主题$z_k$出现在文档$d_i$中的频率，即$P(z_k|d_i)=\theta_{k,i}$，从而把$P(z_k|d_i)$转换成矩阵$\Theta$</li><li>最后通过EM算法求出两个矩阵</li></ol><h5 id="4-2-3-2-1拉格朗日乘数法"><a href="#4-2-3-2-1拉格朗日乘数法" class="headerlink" title="4.2.3.2.1拉格朗日乘数法"></a>4.2.3.2.1拉格朗日乘数法</h5><ol><li>没有约束条件</li></ol><p>目标函数$f(x,y)$是一座山的高度，约束$g(x,y)$是镶嵌在山上的一条曲线，如下图</p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177933575.jpg"></p><p>红线是约束曲线</p><p>目的：找红线上的最低点</p><p>步骤：</p><ul><li>从第0条线开始往上数，数到第三条，与约束曲线有交点，比第三条低的地方都不在约束范围内，所以这是约束曲线的最低点</li><li>约束曲线不会和等高线相交，一定是相切，如果是相交的话，约束曲线有一部分在最低点的曲线的下端(即目标曲线并不能包括约束曲线的最低点)，如下图中约束曲线有一部分在B区域，但是B区域比等高线低<ul><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177938067.jpg"></li></ul></li><li>那么两条线只能相切，意味他们的法线平行&lt;==&gt;法向量只差一个任意的常数乘子(取-$\lambda$)：<ul><li>∇$f(x,y)=-\lambda$∇$g(x,y)$</li><li>∇$f(x,y)+\lambda$∇$g(x,y)=0$</li></ul></li></ul><ol><li><a href="https://zhuanlan.zhihu.com/p/55532322">有约束条件</a></li></ol><p>见pdf</p><h2 id="4-3LDA模型"><a href="#4-3LDA模型" class="headerlink" title="4.3LDA模型"></a>4.3LDA模型</h2><h3 id="4-3-1pLSA和LDA的对比：生成文档与参数估计"><a href="#4-3-1pLSA和LDA的对比：生成文档与参数估计" class="headerlink" title="4.3.1pLSA和LDA的对比：生成文档与参数估计"></a>4.3.1pLSA和LDA的对比：生成文档与参数估计</h3><p>👇频率派vs贝叶斯派</p><p>This content is only supported in a Feishu Docs</p><p><strong>LDA</strong>模型中一篇文档生成的方式：</p><ol><li>按照先验分布$P(d_i)$选择一篇文档$d_i$</li><li>从Dirichlet分布$\alpha$中取样生成文档$d_i$的主题分布$\theta_i$，即主题分布$\theta_i$由超参数为$\alpha$的Dirichlet分布生成①</li><li>从主题的多项式分布$\theta_i$中取样生成文档$d_i$第$j$个词的主题$z_{i,j}$</li><li>从Dirichlet分布$\beta$中取样生成主题$z_{i,j}$对应的词语分布$\phi_{z_i,j}$，即词语分布$\phi_{z_i,j}$由参数为$\beta$的Dirichlet分布生成②</li><li>从词语的多项式分$\phi_{z_i,j}$中采样最终生成词语$w_{i,j}$</li></ol><p>👇LDA和pLSA的区别：</p><ul><li>LDA是pLSA的贝叶斯版本，主题分布和词分布本身都由先验知识随机给定</li><li>①②LDA在pLSA的基础上为主题分布和词分布加了两个Dirichlet先验分布$\alpha$和$\beta$</li><li><strong>pLSA</strong>中主题分布和词分布是唯一确定的，但是<strong>LDA</strong>中主题分布和词分布不再唯一确定不变，即无法确切给出，但是再怎么变化也依然服从一定的分布，即主题分布和词分布由Dirichlet先验随机确定</li><li>文本生成后，两者都要根据文档去推断主题分布和词分布，只是用的参数推断方法不同<ul><li>pLSA中用极大似然估计的思想</li><li>LDA中把两个参数视为随机变量，加入Dirichlet先验</li></ul></li><li>pLSA属于频率派思想，样本随机，参数($\theta_{k,j}$和$\phi_{i,j}$)虽未知但固定；LDA属于贝叶斯派思想，样本固定，参数($\theta_i$和$\phi_{z_i,j}$)未知但不固定，是个随机变量，服从一定的分布(Dirichlet分布)<ul><li><strong>pLSA中</strong><ul><li>主题分布和词分布确定后，以一定概率$\left(P(z_k|d_i),P(w_j|z_k)\right)$分别选取具体的主题和词项，生成好文档</li><li>然后根据生成好的文档反推其主题分布、词分布</li><li>最终用EM算法求解出两个未知但固定的参数的值：<ul><li>$\phi_{k,j}$(由$P(w_j|z_k)$转换而来)</li><li>$\theta_{i,k}$(由$P(z_k|d_i)$转换而来)</li><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177942549.jpg"></li></ul></li></ul></li><li><strong>LDA****中</strong><ul><li>主题分布和词分布是随机变量(即文档$d_i$产生主题$z_k$和主题$z_k$产生词项$w_j$的概率都是随机变量)</li><li>Dirichlet先验为文档$d_i$生成主题分布$\Theta$，然后根据主题分布$\Theta$产生主题$z_k$</li><li>从无穷多个主题分布中按照Dirichlet先验随机抽取出某个主题分布出来</li><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177951260.jpg"></li></ul></li></ul></li><li>例子<ul><li>好比，去一朋友家：<ul><li>按照<strong>频率派</strong>的思想，我估计他在家的概率是1/2，不在家的概率也是1/2，是个<strong>定值</strong>。</li><li>而按照贝叶斯派的思想，他在家不在家的概率不再认为是个定值1/2，而是随机变量。比如按照我们的经验（比如当天周末），猜测他在家的概率是0.6，但这个0.6不是说就是完全确定的，也有可能是0.7。如此，贝叶斯派没法确切给出参数的确定值（0.3,0.4，0.6,0.7，0.8,0.9都有可能），但至少明白在哪个范围或哪些取值（0.6,0.7，0.8,0.9）更有可能，哪个范围或哪些取值（0.3,0.4） 不太可能。进一步，贝叶斯估计中，参数的多个估计值服从一定的先验分布，而后根据实践获得的数据（例如周末不断跑他家），不断修正之前的参数估计，从先验分布慢慢过渡到后验分布。</li></ul></li></ul></li></ul><h3 id="4-3-2LDA生成文档–三维坐标系"><a href="#4-3-2LDA生成文档–三维坐标系" class="headerlink" title="4.3.2LDA生成文档–三维坐标系"></a>4.3.2LDA生成文档–三维坐标系</h3><p><a href="https://blog.csdn.net/v_JULY_v/article/details/41209515?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;utm_relevant_index=2">看</a></p><h3 id="4-3-3pLSA和LDA概率图对比"><a href="#4-3-3pLSA和LDA概率图对比" class="headerlink" title="4.3.3pLSA和LDA概率图对比"></a>4.3.3pLSA和LDA概率图对比</h3><p>z跟w都得是小写，阴影圆圈表示可观测的变量，非阴影圆圈表示隐变量或参数，箭头表示两变量间的条件依赖性，方框表示重复抽样，方框右下角的数字代表重复抽样的次数</p><ul><li>pLSA<ul><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177955942.jpg"></li></ul></li><li>LDA <ul><li><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177960834(1).jpg"></li><li>假定语料库中共有M篇文章，每篇文章下的Topic的主题分布是一个从参数为$\alpha$的Dirichlet先验分布中采样得到的Multinomial分布，每个Topic下的词分布是一个从参数$\beta$为的Dirichlet先验分布中采样得到的Multinomial分布。</li><li>对于某篇文章中的第n个词，首先从该文章中出现的每个主题的Multinomial分布中选择或采样一个主题，然后再在这个主题对应的词的Multinomial分布中选择或采样一个词。不断重复这个随机生成过程，直到M篇文章全部生成完成。</li><li>M 篇文档会对应于 M 个独立的 Dirichlet-Multinomial 共轭结构，K 个 topic 会对应于 K 个独立的 Dirichlet-Multinomial 共轭结构<ul><li>$\alpha\rightarrow\theta\rightarrow z$表示生成文档中的所有词对应的主题<ul><li>$\alpha\rightarrow\theta$对应的是Dirichlet分布</li><li>$\theta\rightarrow z$对应的是Multinomial分布</li><li>​      因此整体是一个Dirichlet-Multinomial共轭结构</li></ul></li><li>$\beta\rightarrow\theta\rightarrow w$表示某个主题对应的词<ul><li>同上</li></ul></li></ul></li></ul></li></ul><h3 id="4-3-4pLSA和LDA参数估计方法的对比"><a href="#4-3-4pLSA和LDA参数估计方法的对比" class="headerlink" title="4.3.4pLSA和LDA参数估计方法的对比"></a>4.3.4pLSA和LDA参数估计方法的对比</h3><ul><li>pLSA<ul><li>使用EM算法估计$\Phi$和$\Theta$，使用的思想是极大似然估计</li></ul></li><li>LDA<ul><li>估计$\Phi$和$\Theta$可用变分(Variational inference)-EM算法<strong>，</strong>也可以用gibbs采样<strong>，</strong>前者的思想是最大后验估计MAP（MAP与MLE类似，都把未知参数当作固定的值），后者的思想是贝叶斯估计</li></ul></li></ul><h3 id="4-3-5Gibbs采样"><a href="#4-3-5Gibbs采样" class="headerlink" title="4.3.5Gibbs采样"></a>4.3.5Gibbs采样</h3><p>Gibbs抽样是马尔可夫链蒙特卡尔理论（MCMC）中用来获取一系列近似等于指定多维概率分布（比如2个或者多个随机变量的联合概率分布）观察样本的算法。</p><h1 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5.代码实现"></a>5.代码实现</h1><p>This content is only supported in a Feishu Docs</p><h2 id="5-1corpora-Dictionary-texts"><a href="#5-1corpora-Dictionary-texts" class="headerlink" title="5.1corpora.Dictionary(texts):"></a>5.1<strong>corpora.Dictionary(texts)</strong>:</h2><p>为每个出现在语料库中的单词分配了一个独一无二的编号id</p><h2 id="5-2dictionary-doc2bow"><a href="#5-2dictionary-doc2bow" class="headerlink" title="5.2dictionary.doc2bow():"></a>5.2<strong>dictionary.doc2bow()</strong>:</h2><p>把文档变成一个稀疏向量，[(0,1), (1,1)]，表明id为0，1的词汇出现了一次，而其他词汇没有出现</p><h2 id="5-3models-Ldamodel"><a href="#5-3models-Ldamodel" class="headerlink" title="5.3models.Ldamodel:"></a>5.3<strong>models.Ldamodel</strong>:</h2><p><strong>参数：</strong></p><p>corpus：一组文档的语料库，是list of list of tuple的形式，每个list内的元素是(word_id, count)，表示一个文档中每个词出现的次数</p><p>num_topics：主题数量</p><p>id2word：将每个词的id映射到该词的字符串表示</p><p>passes：在拟合模型中要执行的迭代次数</p><p>random_state：随机数生成器的种子</p><h2 id="5-4ldamodel-show-topics"><a href="#5-4ldamodel-show-topics" class="headerlink" title="5.4ldamodel.show_topics"></a>5.4ldamodel.show_topics</h2><p>用于展示LDA模型的主题函数</p><h3 id="5-4-1x"><a href="#5-4-1x" class="headerlink" title="5.4.1x"></a>5.4.1x</h3><p>格式：</p><p>[</p><p>(主题1，[(关键词1.1，概率1.1),(关键词1.2，概率1.2)…])，</p><p>(主题2，[(关键词2.1，概率2.1),(关键词2.2，概率2.2)…])，</p><p>()，</p><p>….]</p><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177965964(1).jpg"></p><h3 id="5-4-2tp"><a href="#5-4-2tp" class="headerlink" title="5.4.2tp"></a>5.4.2tp</h3><p>tp[0]–&gt;主题</p><p>tp[1]–&gt;[(关键词1，概率1),(关键词2，概率2)…]</p><h3 id="5-4-3打印每个主题下每个单词的概率"><a href="#5-4-3打印每个主题下每个单词的概率" class="headerlink" title="5.4.3打印每个主题下每个单词的概率"></a>5.4.3打印每个主题下每个单词的概率</h3><p>This content is only supported in a Feishu Docs</p><p>👇用.split()函数</p><ul><li>先按照”+”号进行拆分</li><li>然后对于以”+”号拆分出来的东西，再以”*”号进行拆分</li><li>打印格式：”单词”(单词出现的概率)</li></ul><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177971365.jpg"></p><h3 id="5-4-4计算一致性"><a href="#5-4-4计算一致性" class="headerlink" title="5.4.4计算一致性"></a>5.4.4计算一致性</h3><p><strong>CoherenceModel(model, texts, dictionary, coherence)</strong></p><p>model：指定用于计算一致性的主题模型对象(ldamodel)</p><p>text：指定一个文本列表</p><p>dictionary：指定一个词典对象</p><p>coherence：指定要计算的一致性指标</p><ul><li>C_V：衡量主题内部的一致性和主题之间的互异性</li></ul><p>返回的是一致性评分，分数越高，表示主题模型的主题更具有一致性，一致性评分仅用于比较不同主题模型之间的一致性</p><p>This content is only supported in a Feishu Docs</p><p>发现，当主题数目为10的时候，十个不同的主题之间的coherence值较大，一致性较高。这四个主题下的关键词能够很好地概括所有文档的关键词</p><h1 id="6-没懂的地方"><a href="#6-没懂的地方" class="headerlink" title="6.没懂的地方"></a>6.没懂的地方</h1><ol><li>第四行到第五行</li></ol><p><img src="https://raw.githubusercontent.com/Wabbybabb0/Blog_picture/main/LDA/1702177981781.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> DMIR考核 </tag>
            
            <tag> NLP </tag>
            
            <tag> LDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读写文件</title>
      <link href="/2023/02/10/wen-jian/"/>
      <url>/2023/02/10/wen-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="一-文件的当前位置指针"><a href="#一-文件的当前位置指针" class="headerlink" title="一.文件的当前位置指针"></a>一.文件的当前位置指针</h3><p>文件结构类型<strong>FILE</strong></p><p>其中FILE(结构体)包含</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>_ptr<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>ptr</strong>表示当前的位置指针，指向当前的读写位置</p><h3 id="二-跟踪文件的当前位置指针"><a href="#二-跟踪文件的当前位置指针" class="headerlink" title="二.跟踪文件的当前位置指针"></a>二.跟踪文件的当前位置指针</h3><h4 id="ftell函数"><a href="#ftell函数" class="headerlink" title="ftell函数"></a>ftell函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token function">ftell</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>filepointer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果操作成功，返回filepointer文件地当前位置指针，<code>即相对于文件开头的位移量(字节数)</code></p><p>否则返回-1L</p><h4 id="feof函数"><a href="#feof函数" class="headerlink" title="feof函数"></a>feof函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">feof</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>filepointer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试filepointer文件地位置指针是否指向文件的末尾</p><p>如果filepointer文件的位置指针已指向文件的末尾，则返回逻辑真，否则返回逻辑假</p><h3 id="三-定位文件的当前位置指针"><a href="#三-定位文件的当前位置指针" class="headerlink" title="三.定位文件的当前位置指针"></a>三.定位文件的当前位置指针</h3><h4 id="rewind函数"><a href="#rewind函数" class="headerlink" title="rewind函数"></a>rewind函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">rewind</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>filepointer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>rewind函数将filepointer文件的当前位置指针强行定位到文件的开头</p><h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fseek</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>filepointer<span class="token punctuation">,</span> <span class="token keyword">long</span> offest<span class="token punctuation">,</span> <span class="token keyword">int</span> origin<span class="token punctuation">)</span><span class="token comment">//filepointer是文件指针</span><span class="token comment">/***offset是偏移量，类型为long int文件开头------SEEK_SET--0文件当前位置---SEEK_CUR--1文件末尾------SEEK_END--2//origin是起始位置，类型为int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fseek将filepointer文件的当前位置指针移动到<code>距离origin的offset位置处</code></p><p>offset&gt;0，表示新位置在origin后，反之亦然</p><p>若操作成功则返回0，否则返回非0</p><h3 id="四-文件的打开与关闭"><a href="#四-文件的打开与关闭" class="headerlink" title="四.文件的打开与关闭"></a>四.文件的打开与关闭</h3><h4 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen()函数"></a>fopen()函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">FILE <span class="token operator">*</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//filename是要打开的文件名，文件名前可以带路径</span><span class="token comment">//mode是打开方式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果文件打开成功，则返回指向该文件的指针</p><p>如果文件打开失败，则返回空指针NULL</p><p>e.g.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"f1.txt"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//推荐写法</span><span class="token comment">//r:文件一定要已存在</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"c:\\aaa\\f1.txt"</span><span class="token punctuation">,</span> <span class="token string">"w+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不推荐写法</span><span class="token comment">//w+:若文件不存在则创建文件，可读可写</span><span class="token keyword">char</span> filename<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"file\\f1.txt"</span><span class="token punctuation">;</span><span class="token comment">//存储到当前目录的file子目录下</span>fp <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">"a+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//a+:若文件不存在则创建文件，可读可写</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="fclose-函数"><a href="#fclose-函数" class="headerlink" title="fclose()函数"></a>fclose()函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fclose</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>filepointer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果正常关闭，返回0，否则返回非0</p><h3 id="五-文件读写"><a href="#五-文件读写" class="headerlink" title="五.文件读写"></a>五.文件读写</h3><h4 id="fgetc函数—字符方式文件读写"><a href="#fgetc函数—字符方式文件读写" class="headerlink" title="fgetc函数—字符方式文件读写"></a>fgetc函数—字符方式文件读写</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>filepointer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>fgetc从filepointer文件的<code>当前位置</code>读出一个字符，同时将文件的<code>位置指针_ptr</code>后移一个字节。读出的字节一般要保存到一个字符型变量中</p><p>如果读取成功，返回<strong>读取的字节值</strong>；</p><p>如果读到文件尾或出错，返回<strong>EOF</strong></p><h4 id="fgets函数—字符串方式文件读写"><a href="#fgets函数—字符串方式文件读写" class="headerlink" title="fgets函数—字符串方式文件读写"></a>fgets函数—字符串方式文件读写</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">fgets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> FILE <span class="token operator">*</span>filepointer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//*str是读出的字符串要存放的地方</span><span class="token comment">//n:读取长度为n-1，在末尾加上'\0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>读取成功，返回指向字符串的指针</p><p>失败或出错，返回NULL</p><h4 id="fprintf函数和fscanf函数—格式化读取"><a href="#fprintf函数和fscanf函数—格式化读取" class="headerlink" title="fprintf函数和fscanf函数—格式化读取"></a>fprintf函数和fscanf函数—格式化读取</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fscanf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>filepointer<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">[</span><span class="token punctuation">,</span>adress<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fprintf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>filepointer<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">[</span><span class="token punctuation">,</span>adress<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>e.g.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span><span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span><span class="token string">"%d%s"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从文件中读取</span><span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token keyword">float</span> y <span class="token operator">=</span><span class="token number">5.8</span><span class="token punctuation">;</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span><span class="token string">"%d,%6.2f"</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写入文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>失败返回EOF</p><h4 id="fwrite函数和fread函数—二进制方式文件读写"><a href="#fwrite函数和fread函数—二进制方式文件读写" class="headerlink" title="fwrite函数和fread函数—二进制方式文件读写"></a>fwrite函数和fread函数—二进制方式文件读写</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">unsigned</span> size<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> n<span class="token punctuation">,</span> FILE <span class="token operator">*</span>filepointer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ptr:数据存储位置</span><span class="token comment">//size:数据所占字节数</span><span class="token comment">//n:写入n个数据</span><span class="token comment">//filepointer:向这个文件写</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fread同理</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 闲着没事干 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万年历</title>
      <link href="/2023/02/08/wan-nian-li/"/>
      <url>/2023/02/08/wan-nian-li/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdbool.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">printMonth</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printMonthBody</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getStartDay</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getTotalNumOfDays</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getNumOfDaysInMonth</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> month<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入要查询的年份：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>year<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入要查询的月份：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printMonth</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">printMonth</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span><span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d年%d月份的日历\n"</span><span class="token punctuation">,</span>year<span class="token punctuation">,</span>month<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"--------------------------------\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"日\t一\t二\t三\t四\t五\t六\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printMonthBody</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">printMonthBody</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span><span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> week <span class="token operator">=</span> <span class="token function">getStartDay</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> days <span class="token operator">=</span> <span class="token function">getNumOfDaysInMonth</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> date <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> circulation <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//第一行的日期</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> week <span class="token operator">%</span> <span class="token number">7</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"  \t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> week<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span> date<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从第二行开始的日期</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> date<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> days<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>circulation <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>circulation <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>circulation<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getStartDay</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span><span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> week<span class="token punctuation">;</span>week <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">getTotalNumOfDays</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>week <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> week<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getTotalNumOfDays</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span><span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> yearChange <span class="token operator">=</span> year<span class="token punctuation">;</span><span class="token keyword">int</span> sum1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sum2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> daysOfYear<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> year <span class="token operator">-</span> <span class="token number">1800</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLeapYear</span><span class="token punctuation">(</span>yearChange<span class="token punctuation">)</span><span class="token punctuation">)</span>daysOfYear <span class="token operator">=</span> <span class="token number">366</span><span class="token punctuation">;</span><span class="token keyword">else</span>daysOfYear <span class="token operator">=</span> <span class="token number">365</span><span class="token punctuation">;</span>sum1 <span class="token operator">+=</span> daysOfYear<span class="token punctuation">;</span>yearChange<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> month <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>sum2 <span class="token operator">+=</span> <span class="token function">getNumOfDaysInMonth</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>sum <span class="token operator">=</span> sum1 <span class="token operator">+</span> sum2<span class="token punctuation">;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getNumOfDaysInMonth</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span><span class="token keyword">int</span> month<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>month <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> month <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">||</span> month <span class="token operator">==</span> <span class="token number">5</span> <span class="token operator">||</span> month <span class="token operator">==</span> <span class="token number">7</span> <span class="token operator">||</span> month <span class="token operator">==</span> <span class="token number">8</span> <span class="token operator">||</span> month <span class="token operator">==</span> <span class="token number">10</span> <span class="token operator">||</span> month <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">31</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>month <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">||</span> month <span class="token operator">==</span> <span class="token number">6</span> <span class="token operator">||</span> month <span class="token operator">==</span> <span class="token number">9</span> <span class="token operator">||</span> month <span class="token operator">==</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">31</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>month <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLeapYear</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">29</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> <span class="token number">28</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>bool <span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>year <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 闲着没事干 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2023/02/07/pai-xu/"/>
      <url>/2023/02/07/pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h3 id="一-冒泡排序bubbleSort"><a href="#一-冒泡排序bubbleSort" class="headerlink" title="一.冒泡排序bubbleSort"></a>一.冒泡排序bubbleSort</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> size <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二-选择排序"><a href="#二-选择排序" class="headerlink" title="二.选择排序"></a>二.选择排序</h3><p>每次把最小的找出来跟第一个数值换位置</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span><span class="token keyword">int</span> min<span class="token punctuation">;</span><span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>min <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>min <span class="token operator">=</span> j<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">!=</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>temp <span class="token operator">=</span> a<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三-快速排序"><a href="#三-快速排序" class="headerlink" title="三.快速排序"></a>三.快速排序</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">findPos</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> pos<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>pos <span class="token operator">=</span> <span class="token function">findPos</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> low <span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">findPos</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> val <span class="token operator">=</span> a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> val<span class="token punctuation">)</span><span class="token operator">--</span>high<span class="token punctuation">;</span>a<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> val<span class="token punctuation">)</span><span class="token operator">++</span>low<span class="token punctuation">;</span>a<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四-插入排序-二分法"><a href="#四-插入排序-二分法" class="headerlink" title="四.插入排序+二分法"></a>四.插入排序+二分法</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span><span class="token keyword">int</span> low<span class="token punctuation">,</span> high<span class="token punctuation">,</span>mid<span class="token punctuation">;</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>temp <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>mid <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">!=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> high <span class="token operator">!=</span> low<span class="token punctuation">)</span><span class="token punctuation">{</span>mid <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> mid <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>temp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>high <span class="token operator">==</span> low<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;</span> low<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>temp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span>low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> high <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>temp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 闲着没事干 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FirstGame笔记</title>
      <link href="/2023/01/21/firtgame/"/>
      <url>/2023/01/21/firtgame/</url>
      
        <content type="html"><![CDATA[<p>跟着麦扣老师做的<a href="https://github.com/Wabbybabb0/My-First-Game-Demo">小狐狸demo</a></p><h4 id="Input-GetAxis"><a href="#Input-GetAxis" class="headerlink" title="Input.GetAxis"></a>Input.GetAxis</h4><p>GetAxis()两种：</p><ul><li><p>Vertical:获得垂直方向</p></li><li><p>Horizontal:获得水平方向</p></li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">horizontalmove = Input.GetAxis("Horizontal");//检测水平方向键verticalmove = Input.GetAxis("Vertical"); //检测垂直方向键<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/../../../../medias/blog_picture/Unity/1.png"></p><p>👆Edit-&gt;Project Settings-&gt;Input Manager-&gt;Axes-&gt;Horizontal</p><p>从上图可知<code>Negative Button</code> <code>-1</code>对应<code>left</code>和<code>a</code>；<code>Positive Button</code>对应<code>1</code>和<code>right</code></p><p>所以在程序中分别设置两个变量接收<code>-1</code>或者<code>1</code>来判断是按了<code>a</code> <code>left</code>还是<code>d</code> <code>right</code></p><h4 id="Input-GetAxisRaw"><a href="#Input-GetAxisRaw" class="headerlink" title="Input.GetAxisRaw"></a>Input.GetAxisRaw</h4><p><strong>~ vs Input.GetAxis</strong>👇</p><p>前者获得的数据只有<code>-1</code> <code>0</code> <code>1</code></p><p>后者获得的数据是<code>-1~0</code> <code>0~1</code></p><h4 id="Time-deltaTime"><a href="#Time-deltaTime" class="headerlink" title="Time.deltaTime"></a>Time.deltaTime</h4><p><img src="/../../../../medias/blog_picture/Unity/2.png"></p><p><img src="/../../../../medias/blog_picture/Unity/3.png"></p><h4 id="Mathf-Abs"><a href="#Mathf-Abs" class="headerlink" title="Mathf.Abs()"></a>Mathf.Abs()</h4><p>取绝对值</p><h4 id="transform-Transform"><a href="#transform-Transform" class="headerlink" title="transform&amp;Transform"></a>transform&amp;Transform</h4><ul><li>Transform做函数</li><li>transform才是当前真正需要操作的</li></ul><h4 id="镜头设置的两种方法"><a href="#镜头设置的两种方法" class="headerlink" title="镜头设置的两种方法"></a>镜头设置的两种方法</h4><h5 id="1-在Main-Camera中加new-script"><a href="#1-在Main-Camera中加new-script" class="headerlink" title="1.在Main Camera中加new script"></a>1.在Main Camera中加new script</h5><p>👇Script代码</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class CameraControl : MonoBehaviour{//①设置一个叫"player"的Transform类型的变量    public Transform player;    // Update is called once per frame    void Update()    {    //②把Main Camera中的transform栏目中的position改为一个实例，该实例是3D的，xyz各自对应        transform.position = new Vector3(player.position.x, 0, -10f);      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>👇最后把要给镜头的对象移动到Player处即可</p><p><img src="/../../../../medias/blog_picture/Unity/4.png"></p><h5 id="2-cinimachine"><a href="#2-cinimachine" class="headerlink" title="2.cinimachine"></a>2.cinimachine</h5><p>GameObject-&gt;Cinimachine-&gt;2D Cinima-&gt;得到下图所示的选项</p><p><img src="/../../../../medias/blog_picture/Unity/5.png"></p><p><img src="/../../../../medias/blog_picture/Unity/6.png"></p><ul><li><p>Follow处拉拽上需要跟踪镜头的对象</p></li><li><p>然后在Lens处调整镜头距离等参数</p></li></ul><p><img src="/../../../../medias/blog_picture/Unity/7.png"></p><ul><li><p>Dead Zone</p><ul><li>可以拉拽范围，如果超出范围则镜头移动，未超出则不移动</li></ul></li><li><p>不离开背景图</p><ul><li>CM vcam1-&gt;Body-&gt;Add Extension-&gt;Cinimachine Confiner-&gt;</li><li><img src="/../../../../medias/blog_picture/Unity/8.png"></li></ul></li><li><p>回到Background图层拉拽范围</p></li></ul><h4 id="虚函数与类的使用"><a href="#虚函数与类的使用" class="headerlink" title="虚函数与类的使用"></a>虚函数与类的使用</h4><p><strong>父级</strong></p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class Enemy : MonoBehaviour{    protected Animator Anim;    //👆所有Enemy都需要有“被击杀”的动画，因此先创建一个名为"Anim"的Animator变量    //"protected"→1.1    protected virtual void Start()    //"virtual"父级的"Start"是可以被子级重新编写的(因为子级在"Start"中有一些本体的属性)    {        Anim = GetComponent&lt;Animator&gt;();    }    public void Death()    {        Destroy(gameObject);    }    public void JumpOn()    {        Anim.SetTrigger("death");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>子级</strong></p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">public class Enemy_Frog : Enemy//隶属于Enemy的子级，确定父子关系{protected override void Start()//👆override 呼应virtual{     base.Start();//调用父级的Start}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Player</strong></p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Enemy enemy = collision.gameObject.GetComponent&lt;Enemy&gt;();//可以调用名为"Enemy"的类的父子级<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="1-1protected"><a href="#1-1protected" class="headerlink" title="1.1protected"></a>1.1protected</h5><ul><li><p>自身类和派生类可以访问相当于自身的private型成员 <code>创建的函数或者变量在子父级中都可以使用</code></p></li><li><p>可以被<code>1.该类中的函数</code>、<code>2.子类的函数</code>、以及<code>3.其友元函数</code>访问。但不能被该类的对象访问</p></li><li><p>使用protected继承，父类的protected和public属性在子类中变为protected</p></li></ul><h4 id="场景转换"><a href="#场景转换" class="headerlink" title="场景转换"></a>场景转换</h4><p>从第一关进入第二关</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">using UnityEngine.SceneManagement;//.//.if(Input.GetKeyDown(KeyCode.E)){    SceneManager.LoadScene(SceneManager.GetActiveScene().bulidIndex + 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作符</title>
      <link href="/2023/01/13/cao-zuo-fu/"/>
      <url>/2023/01/13/cao-zuo-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="一-操作符"><a href="#一-操作符" class="headerlink" title="一.操作符"></a>一.操作符</h2><p><strong>操作符函数是方法函数的简记法</strong></p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace CreatOperator{    class Program    {        static void Main(string[] args)        {            Person person1 = new Person();            Person person2 = new Person();            person1.Name = "Deer";            person2.Name = "Deer's wife";            List&lt;Person&gt; nation = Person.GetMarry(person1,person2);            //上面这行改成            //List&lt;Person&gt; nation = person1 + person2;            foreach (var p in nation)            {                Console.WriteLine(p.Name);            }        }    }        class Person    {        public string Name;        public static List&lt;Person&gt;GetMarry(Person p1,Person p2)        //上面这行改成 public static List&lt;Person&gt; operator+(Person p1,Person p2)        {            List&lt;Person&gt; people = new List&lt;Person&gt;();            people.Add(p1);            people.Add(p2);            for (int i = 0; i &lt; 11; i++)            {                Person child = new Person();                child.Name = p1.Name + "&amp;" + p2.Name + "s child";                people.Add(child);            }            return people;        }    }}//两种方法的结果一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有圆括号来提高优先级</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int[] myIntArray = new int[]{};//[]填数组大小，{}(初始化器)填具体数值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Type t = typeof(int);Console.WriteLine(t.Namespace);Console.WriteLine(t.FullName);Console.WriteLine(t.Name);/**SystemSystem.Int32Int32*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><p>获取一个类型的默认值</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int x = default(int);Console.WriteLine(x);//0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Form myForm = default(Form);Console.WriteLine(myForm==null);//true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">class Program{static void Main(string[] args)    {        Level level = default(Level);        Console.WriteLine(level);    }}//①enum Level{Low,Mid,High}//Low//②enum Level{Mid,Low,High}//Mid//③enum Level{Mid = 1,Low = 0,High = 2}//Low//④enum Level{Low = 1,Mid = 2,High = 3}//0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>声明隐式类型变量</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int x = 100;//显式var y = 100;//隐式根据赋的值“100”来给y判断类型Console.WriteLine(y.GetType().Name);//Int32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><ul><li>调用实例构造器</li></ul><p>帮助我们在内存当中<code>创建类型的实例</code></p><p>有<code>()</code>时表示<code>调用它的实例构造器</code></p><p>如果在new操作符<code>左边有赋值符号</code>的话，那么new操作符会把自己拿到的这个<code>实例的内存地址</code>通过<code>赋值操作符</code>交给负责访问这个实例的<code>变量</code></p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Form myForm = new Form();//myForm为该实例的变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>调用实例的初始化器</li></ul><p>花括号<code>{}</code>内可以为这个实例的属性设置它的值，可以通过<code>,</code>来同时设置多个属</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Form myForm = new Form(){Text."Hello"};<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>👆👇</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Form myForm = new Form();myForm.Text = "Hello"; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>一次性访问，没必要创建变量访问实例</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">new Form(){Text = "Hello"}.ShowDialog();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>👆👇</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Form myForm = new Form();myForm.Text = "Hello";myForm.ShowDialog();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>匿名类型创建对象</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">var person = new{Name = "Mr.Okay", Age = 18};//自动判断类型Console.WriteLine(person.Age);Console.WriteLine(person.Name);Console.WriteLine(person.GetType().Name);//Mr.Okay//18//&lt;&gt;f__AnonymousType0`2//类型的解释：//&lt;&gt;f__AnonymousType是约定的一个前缀//0指的是在程序中创建的第一个//`2指的是这个类型是一个泛型类，构成这个类型时需要两个类型来构成它，一个是string，一个是int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>子类隐藏父类(关键字)(了解即可)</li></ul><h4 id="checked-unchecked"><a href="#checked-unchecked" class="headerlink" title="checked&amp;unchecked"></a>checked&amp;unchecked</h4><p>检查是否异常</p><h4 id="取非操作符"><a href="#取非操作符" class="headerlink" title="!取非操作符"></a>!取非操作符</h4><p>实际应用，检查</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace CreatOperator{    class Program    {        static void Main(string[] args)        {            Student stu = new Student(null);            Console.WriteLine(stu.Name);        }    }    class Student    {        public string Name;        public Student(string initName)        {            if(!string.IsNullOrEmpty(initName))            {                this.Name = initName;            }            else             {                throw new ArgumentException("initName cannot be null or empty");            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="T-x强制转换类型操作符"><a href="#T-x强制转换类型操作符" class="headerlink" title="(T)x强制转换类型操作符"></a>(T)x强制转换类型操作符</h4><h2 id="二-数据类型转换"><a href="#二-数据类型转换" class="headerlink" title="二.数据类型转换"></a>二.数据类型转换</h2><h4 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">string str1 = Console.ReadLine();string str2 = Console.ReadLine();int x = Convert.ToInt32(str1);int y = Convert.ToInt32(str2);Console.WriteLine(str1 + str2);Console.WriteLine(x + y);//12//34//1234//46s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><ul><li>不丢失精度的转换</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int x = int.MaxValue;long y = x;Console.WriteLine(y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>C#语言数据文档6.1.2有隐式数值转换</p><p><img src="/../../../../medias/blog_picture/C#/5.png"></p><ul><li>子类向父类的转换</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace CreatOperator{    class Program    {        static void Main(string[] args)        {            Teacher t = new Teacher();            Human h = t;//h仍只有Eat和Animal            Animal a = h;//访问的是Animal，引用不了实例h，只有Eat            a.Eat();        }    }//父类    class Animal    {        public void Eat()        {            Console.WriteLine("Eating");        }    }//子类    class Human:Animal    {        public void Think()        {            Console.WriteLine("Who am I?");        }    }//子类的子类    class Teacher : Human    {        public void Teach()        {            Console.WriteLine("I teach programming.");        }    }}//Eating<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>装箱</li></ul><h4 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h4><ul><li>有可能丢失精度的转换<strong>cast</strong>(铸造)</li></ul><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Console.WriteLine(ushort.MaxValue);uint x = 65536;ushort y = (ushort)x;//强制把较大的值装到小的空间里Console.WriteLine(y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>拆箱</li><li>convert<ul><li>数值类型往字符串类型转换</li></ul></li></ul><h4 id="类型转换操作符"><a href="#类型转换操作符" class="headerlink" title="类型转换操作符"></a>类型转换操作符</h4><p>显式类型转换是一个目标类型的实例的构造器，写在被转换的这个数据类型里</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace CreatOperator{    class Program    {        static void Main(string[] args)        {            Stone stone = new Stone();            stone.Age = 5000;            Monkey wukongSun = (Monkey)stone;            //目标是把一个Stone类型的转变为Monkey类型的            Console.WriteLine(wukongSun.Age);        }    }    class Stone    {        public int Age;        //显式类型转换是一个目标类型的实例的构造器，写在被转换的这个数据类型里        //Monkey(Stone stone)就是一个构造器        public static explicit operator Monkey(Stone stone)        {            Monkey m = new Monkey();            m.Age = stone.Age / 500;//构建Monkey和Stone的关系            return m;        }    }    class Monkey    {        public int Age;    }}//10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对比隐式类型转换</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace CreatOperator{    class Program    {        static void Main(string[] args)        {            Stone stone = new Stone();            stone.Age = 5000;            Monkey wukongSun = stone;//此处去掉了(Monkey)stone的(Monkey)            Console.WriteLine(wukongSun.Age);        }    }    class Stone    {        public int Age;        public static implicit operator Monkey(Stone stone)//此处将"explicit"改为"implicit"        {            Monkey m = new Monkey();            m.Age = stone.Age / 500;            return m;        }    }    class Monkey    {        public int Age;    }}//10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="is"><a href="#is" class="headerlink" title="is"></a>is</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Stone stone = new Stone();var result = stone is Stone;//检验的是变量所引用的实例Console.WriteLine(result.GetType().FullName);Console.WriteLine(result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Nullable可空类型"><a href="#Nullable可空类型" class="headerlink" title="Nullable<>可空类型"></a>Nullable&lt;&gt;可空类型</h4><p>例子：一个同学没交作业，但是不是那种做的极差的0分，想给他空着</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Nullable&lt;int&gt; x = null;//没交作业x = 100;//交了作业<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>👆👇</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int?x = null;x = 100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是如果这个同学一直没交作业，期末需要录入成绩时给0分</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int?x = null;int y = x??0;//赋0分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="ifelse的简写"><a href="#ifelse的简写" class="headerlink" title="?:(ifelse的简写)"></a>?:(ifelse的简写)</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int x = 80;string str = string.Empty;str = (x &gt;= 60)?"Pass":"Failed";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>👆👇</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int x = 80;string str;if(x&gt;60){    str = "Pass";}else{    str = "Failed";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 闲着没事干 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本元素和类型</title>
      <link href="/2023/01/11/ji-ben-yuan-su-he-shu-ju-lei-xing/"/>
      <url>/2023/01/11/ji-ben-yuan-su-he-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="一-基本元素"><a href="#一-基本元素" class="headerlink" title="一.基本元素"></a>一.基本元素</h2><ul><li>标记Token：对编译器有意义的符号<ul><li>关键字Keyword</li><li>操作符Operator</li><li>标识符Identifier<ul><li>允许“@”字符作为前缀以使关键字能够用作标识符</li></ul></li><li>标点符号</li><li>文本(字面值)</li></ul></li><li>注释与空白<ul><li>CTRL+K CTRL+C👉注释</li><li>CTRL+K CTRL+U👉取消注释</li><li>CTRL+K CTRL+D👉设置文档格式(自动对齐)</li></ul></li></ul><h2 id="二-数据类型"><a href="#二-数据类型" class="headerlink" title="二.数据类型"></a>二.数据类型</h2><ul><li><p>值类型</p><ul><li>结构体Structures</li><li>枚举Enumerations<ul><li>只能从一个集合中选取有效值</li></ul></li></ul></li><li><p>引用类型</p><ul><li><p>类Classes</p></li><li><p>接口Interfaces</p></li><li><p>委托Delegates</p></li></ul></li></ul><h2 id="三-变量"><a href="#三-变量" class="headerlink" title="三.变量"></a>三.变量</h2><p>👇从表面看，变量是用来<strong>存储数据</strong>的</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">int x;x = 100;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上，<strong>变量表示了存储位置，并且每个变量都有一个类型，以决定什么样的值能够存入变量</strong></p><p>👆了解为，x是一个<code>标签</code>，对应着内存中的一个地址，100这个值就存在该地址</p><p><strong>变量 = <code>以变量名所对应的内存地址为起点</code>、<code>以其数据类型所要求的存储空间为长度</code>的一块内存区域</strong></p><p><img src="/../../../../medias/blog_picture/C#/2.png" alt="堆，栈，地址的理解"></p><p>引用变量存的是实例的地址</p><h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//装箱int x = 100;object obj;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当发现obj引用的实例在堆上而不在栈上时，把该实例对应的值的内存大小在栈上找一块空间，再把这个地址存储回obj的内存空间</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//拆箱int y = (int)obj;Console.WriteLine(y);//100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../../../../medias/blog_picture/C#/3.png" alt="装箱和拆箱"></p><h2 id="四-方法"><a href="#四-方法" class="headerlink" title="四.方法"></a>四.方法</h2><p>方法是类或结构体的成员</p><p>方法相当于自定义函数</p><p><img src="/../../../../medias/blog_picture/C#/4.png"></p><p>👆复用，如果要更改3.14159为3.14或者Math.PI可以直接在GetCircleArea处改</p><p>实例方法👇</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Calculator c = new Calculator();c.Add(2.0,3.0);class Calculator{    public double Add(double a,double b);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态方法</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Calculator c = new Calculator();//c.Add(2.0,3.0);此时这句话无用class Calculator{    public static double Add(double a,double b);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五-构造器"><a href="#五-构造器" class="headerlink" title="五.构造器"></a>五.构造器</h2><p><strong>不带以0为默认参数的构造器</strong></p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace ConstructExample{    class Program    {        static void Main(string[]args)        {            Student stu = new Student;            Console.WriteLine(stu.ID);            Console.WriteLine(stu.Name);        }    }    class Student    {        //不带参数的构造体    public Student()        {            this.ID = 1;            this.Name = "No name";        }        //        public int ID;        public string Name;    }}//1//No Name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>强制程序员给构造器设置参数</strong>，在这种情况下如果不想设置参数但是要调用该方法，就需要自定义一个默认参数，如上图所示</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">namespace ConstructExample{    class Program    {        static void Main(string[]args)        {            Student stu = new Student(1,"No name");//不能再写成new Student();            Console.WriteLine(stu.ID);            Console.WriteLine(stu.Name);        }    }    class Student    {        //不带参数的构造体    public Student(int initId,string initName)        {            this.ID = initId;            this.Name = initName;        }        //        public int ID;        public string Name;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>构造器快捷键：ctor+tab*2</strong>ctor=Code snippet(小片段)</p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">class Calculator{    //①    public double Add(int a, int b)    {        return a + b;    }    //②    public int Add(int a, int b)    {        return a + b;    }    ③    public double Add(int a, int b, int c)    {        return a + b + c;    } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>👆①与②不能共存，重载与方法的类型无关</p><p>①和③、②和③可共存</p><h2 id="调用方法实际上是压栈的过程"><a href="#调用方法实际上是压栈的过程" class="headerlink" title="调用方法实际上是压栈的过程"></a>调用方法实际上是压栈的过程</h2>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲着没事干 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类和命名空间</title>
      <link href="/2023/01/10/lei-he-ming-ming-kong-jian/"/>
      <url>/2023/01/10/lei-he-ming-ming-kong-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="一-类"><a href="#一-类" class="headerlink" title="一.类"></a>一.类</h2><p>是对<code>现实世界事物</code>进行<strong>抽象</strong>所得到的结果</p><h4 id="1-类和对象的关系👇"><a href="#1-类和对象的关系👇" class="headerlink" title="1.类和对象的关系👇"></a>1.类和对象的关系👇</h4><ul><li><p><code>对象</code>也叫<code>实例</code>，是<code>类</code>经过“实例化”后得到的内存中是实体</p><ul><li>e.g. “飞机”和“一架飞机”，前者是概念，后者是实体</li><li>e.g. 蓝图和建筑</li></ul></li><li><p><code>实例化</code>，使用<code>new</code>操作符创建类的实例</p><ul><li><pre><code class="c#">new + 类名();//实例化格式<pre class="line-numbers language-none"><code class="language-none">* ```c#  (new Form()).ShowDialog();//实例化例子<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></code></pre></li></ul></li><li><p>引用变量与实例的关系</p><ul><li><pre><code class="c#"></code></pre></li></ul><p>  Form myForm;//引用变量小朋友<br>  myForm = new Form();//实例化 =小朋友牵着气球<br>  myForm.Text = “My Form!”;//标题文本<br>  myForm.ShowDialog();//显示表单</p><pre><code>* 引用变量与实例的关系可以视作小朋友和气球的关系</code></pre></li></ul><h4 id="2-类的三大成员"><a href="#2-类的三大成员" class="headerlink" title="2.类的三大成员"></a>2.类的三大成员</h4><ul><li><strong>属性Property</strong><ul><li>存储数据，组合起来表示类或对象当前的状态</li><li>e.g. 身高很高，财富充裕，长相不错，组合为高富帅</li></ul></li><li><strong>方法Method</strong><ul><li>表示类或对象“能做什么”</li></ul></li><li><strong>事件Event</strong></li></ul><h3 id="3-静态成员与实例成员"><a href="#3-静态成员与实例成员" class="headerlink" title="3.静态成员与实例成员"></a>3.静态成员与实例成员</h3><ul><li><strong>静态Static</strong>成员表示它是<code>类的成员</code></li><li><strong>实例</strong>成员表示它是<code>对象的成员</code></li><li><strong>绑定Bing</strong>指的是编译器如何把一个成员与类或对象关联起来<ul><li>**.**成员访问操作符</li></ul></li></ul><h2 id="二-名称空间"><a href="#二-名称空间" class="headerlink" title="二.名称空间"></a>二.名称空间</h2><p>把类用良好的结构组合在一起，以树形结构组织类</p><p><strong>包：某市→类库：图书馆→名称空间：书架→类：书→方法：目录</strong></p><h2 id="三-类库"><a href="#三-类库" class="headerlink" title="三.类库"></a>三.类库</h2><p>类库的引用</p><ul><li><p>DLL引用(无源代码，黑盒类库)</p><ul><li><p>在<strong>解决方案</strong>中的<strong>依赖项</strong>右键<strong>添加项目引用</strong>中可以添加以<code>dll</code>为后缀的文件作为类库引用</p></li><li><p>NuGet</p><ul><li>只有DLL没有源代码很危险，比如引用了一个<code>类库</code>，但是这个<code>类库</code>中一些代码还有一些<code>底层的东西</code>没有引用进来导致报错</li></ul></li></ul></li><li><p>项目引用(有源代码，白盒类库)</p><ul><li>同上，但是是在<code>程序集中</code></li></ul></li></ul><p><img src="/../../../../medias/blog_picture/C#/1.png"></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲着没事干 </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AT24C02</title>
      <link href="/2022/11/27/at24c02/"/>
      <url>/2022/11/27/at24c02/</url>
      
        <content type="html"><![CDATA[<h1 id="一-存储器介绍"><a href="#一-存储器介绍" class="headerlink" title="一.存储器介绍"></a>一.存储器介绍</h1><h2 id="1-易失性存储器-RAM"><a href="#1-易失性存储器-RAM" class="headerlink" title="1.易失性存储器/RAM"></a>1.易失性存储器/RAM</h2><p>全称：RamdomAccessMemory</p><p>百度百科：<strong>它在任何时候都可以读写</strong>，RAM通常是作为操作系统或其他正在运行程序的临时存储介质(可称作系统内存)。不过，<strong>当电源关闭时RAM不能保留数据</strong>，如果需要保存数据，就必须把它们写入到一个<strong>长期的存储器</strong>(如硬盘)中。</p><p>①SRAM(静态RAM) steady</p><ul><li>用电路储存，CPU用到，速度最快，容量小</li></ul><p>②DRAM(动态RAM)</p><ul><li>用电容充放电的高低电平来存储，通常配一个扫描电路，给它补电</li></ul><h2 id="2-非易失性存储器-ROM"><a href="#2-非易失性存储器-ROM" class="headerlink" title="2.非易失性存储器/ROM"></a>2.非易失性存储器/ROM</h2><p>全称：non-volatile memory</p><p>百度百科：是指当<strong>电流关掉后</strong>，<strong>所存储的数据不会消失</strong>的电脑存储器，缺点是存储比较慢</p><p>①Mask ROM（掩膜ROM）：只读不写</p><p><img src="/../../../../medias/blog_picture/51/67.png"></p><p>②PROM(可编程ROM)：只能写一次</p><p><img src="/../../../../medias/blog_picture/51/68.png"></p><ul><li>编程时左边给高电平、下边给0可以把蓝色的二极管<strong>击穿</strong>，实现可写，所以也叫<strong>烧录程序</strong>哈哈</li></ul><p>③EPROM(可擦除可编程ROM)：可写</p><p>④E2PROM(电可擦除可编程ROM)：5V几毫秒就能擦除</p><p>⑤Flash(内存)：</p><p>⑥硬盘、软盘、光盘等：通过磁介质传递</p><h1 id="二-AT24C02介绍"><a href="#二-AT24C02介绍" class="headerlink" title="二.AT24C02介绍"></a>二.AT24C02介绍</h1><p><img src="/../../../../medias/blog_picture/51/69.png"></p><h1 id="三-I2C"><a href="#三-I2C" class="headerlink" title="三.I2C"></a>三.I2C</h1><p><img src="/../../../../medias/blog_picture/51/70.png"></p><h2 id="1-起始-终止"><a href="#1-起始-终止" class="headerlink" title="1.起始&amp;终止"></a>1.起始&amp;终止</h2><p><img src="/../../../../medias/blog_picture/51/71.png"></p><h2 id="2-发送-接受字节"><a href="#2-发送-接受字节" class="headerlink" title="2.发送/接受字节"></a>2.发送/接受字节</h2><p><img src="/../../../../medias/blog_picture/51/72.png"></p><p><img src="/../../../../medias/blog_picture/51/73.png"></p><p>👆注意主机和从机，在SDA中紫色是从机，黑色是主机</p><p>应答可以作为第九位</p><ul><li>主机释放了SDA**(给SDA置1)**变成高电平，把控制权给从机</li><li>此时从机可以操控发1或发0</li><li>当SCL拉低，从机自动将下一位数据放到总线上</li></ul><h2 id="3-发送-接收应答"><a href="#3-发送-接收应答" class="headerlink" title="3.发送/接收应答"></a>3.发送/接收应答</h2><p><img src="/../../../../medias/blog_picture/51/74.png"></p><p>应答可以作为数据的第九位</p><p>用来判断从机是否应答或者主机是否发送应答</p><p><img src="/../../../../medias/blog_picture/51/75.png"></p><p>呜呜呜呜呜呜呜呜呜呜<strong>从1：15：21开始，代码不能正常运行</strong>呜呜呜呜呜呜呜呜呜呜放弃了放弃了</p><h1 id="四-学到了啥"><a href="#四-学到了啥" class="headerlink" title="四.学到了啥"></a>四.学到了啥</h1><hr><p>感觉比较有用的是在定时器里调用函数，同时对不同模块函数计时</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Timer0_Routine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> interrupt <span class="token number">1</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> T0Count1<span class="token punctuation">,</span>T0Count2<span class="token punctuation">;</span>TL0 <span class="token operator">=</span> <span class="token number">0x18</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span>TH0 <span class="token operator">=</span> <span class="token number">0xFC</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span>T0Count1<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>T0Count1<span class="token operator">&gt;=</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token comment">//20ms返回一次1或0</span><span class="token comment">//通过记录上一次和这一次的返回值判断是按下还是松开</span><span class="token punctuation">{</span>T0Count1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token function">Key_Loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这时候Key函数无中生有，有了自己的中断</span><span class="token punctuation">}</span>T0Count2<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>T0Count2<span class="token operator">&gt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>T0Count2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token function">Nixie_Loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Key_Loop</strong>   <strong>Nixie_Loop</strong></p><p>只需要改变T0Count&gt;=x就可以有针对的计时</p><p>这个loop函数相当于绕了一个圈把子函数调用了一次，但是起码起到了计时的作用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2022/11/22/dui-lie/"/>
      <url>/2022/11/22/dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概念"><a href="#一-概念" class="headerlink" title="一.概念"></a>一.概念</h1><h2 id="1-前front-后rear"><a href="#1-前front-后rear" class="headerlink" title="1.前front 后rear"></a>1.前front 后rear</h2><ul><li><p>出队，从头出</p></li><li><p>入队，从尾入</p></li></ul><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><p>链式队列，静态队列，循环队列</p><ul><li>链式队列–用链表实现</li><li>静态队列–用数组实现，通常都必须是循环队列</li></ul><h2 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h2><h3 id="①静态队列为什么必须是循环队列"><a href="#①静态队列为什么必须是循环队列" class="headerlink" title="①静态队列为什么必须是循环队列"></a>①静态队列为什么<strong>必须是循环队列</strong></h3><p>r→r→</p><p>​dd</p><p>​cf→c</p><p>​b==&gt;  b</p><p>f→   a a</p><p>👆a和b出队之后，对于数组a来说，a[0]、a[1]这两个空间就被浪费了，因为f和r一直在往上移动，所以相当于a[0]、a[1]不能再使用了。用传统数组来实现队列，无论是入队还是出队，参数都只能增不能减</p><h3 id="②循环队列需要几个参数及各个参数的含义"><a href="#②循环队列需要几个参数及各个参数的含义" class="headerlink" title="②循环队列需要几个参数及各个参数的含义"></a>②循环队列需要<strong>几个参数</strong>及各个<strong>参数的含义</strong></h3><ul><li><p>需要<strong>2个</strong>参数来确定 <strong>front</strong> <strong>rear</strong></p></li><li><p>2个参数在不同场合有<strong>不同的的定义</strong></p><ul><li><p>场合：</p><blockquote><p> 1）队列初始化</p><p>​front和rear的值都是<strong>零</strong></p><p>2）队列非空</p><p>​front代表的是队列的<strong>第一个元素</strong></p><p>​rear代表的是队列的<strong>最后一个有效元素的下一个</strong></p><p>3）队列空</p><p>​front和rear的<strong>值相等</strong>，但不一定是零</p></blockquote></li></ul></li></ul><h3 id="③循环队列出、入队伪算法讲解"><a href="#③循环队列出、入队伪算法讲解" class="headerlink" title="③循环队列出、入队伪算法讲解"></a>③循环队列<strong>出、入队伪算法</strong>讲解</h3><h4 id="1-入队"><a href="#1-入队" class="headerlink" title="1.入队"></a>1.入队</h4><ul><li><p>将值存入r所代表的位置</p></li><li><p>r=(r+1)%数组的长度</p></li></ul><h4 id="2-出队"><a href="#2-出队" class="headerlink" title="2.出队"></a>2.出队</h4><ul><li>f=(f+1)%数组的长度</li></ul><h3 id="④如何判断循环队列是否为空、已满"><a href="#④如何判断循环队列是否为空、已满" class="headerlink" title="④如何判断循环队列是否为空、已满"></a>④如何判断循环队列是否为<strong>空、已满</strong></h3><h4 id="1-空"><a href="#1-空" class="headerlink" title="1.空"></a>1.空</h4><ul><li>f=r</li></ul><h4 id="2-满"><a href="#2-满" class="headerlink" title="2.满"></a>2.满</h4><ul><li><p>Ⅰ多增加一个标识参数(通常不用这个)</p></li><li><p>Ⅱ少用一个元素。本来可以放n个元素，<strong>定义n-1个是满的</strong>(通常使用这种方式)</p><ul><li><p>如何判断队列已满：r和f的值紧挨着，则队列已满</p></li><li><pre><code class="c">if((r+1)%数组的长度==f)    //已满else    //不满<pre class="line-numbers language-none"><code class="language-none"># 二.代码```c#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;typedef struct Queue{int *pBase;int front;int rear;}QUEUE,*PQUEUE;void init(PQUEUE);//初始化 bool fullQueue(PQUEUE);//判断队列是否满 bool enQueue(PQUEUE,int);//入队 bool emptyQueue(PQUEUE);//判断队列是否为空void traverse(PQUEUE);//遍历bool outQueue(PQUEUE,int*);//出队 int main(){//int val;int *pVal=(int*)malloc(sizeof(int)*4); QUEUE Q;init(&amp;Q);enQueue(&amp;Q,1);enQueue(&amp;Q,2);enQueue(&amp;Q,3);enQueue(&amp;Q,4);enQueue(&amp;Q,5);enQueue(&amp;Q,6);enQueue(&amp;Q,7);traverse(&amp;Q);if(outQueue(&amp;Q,pVal))printf("出队的数字是:%d\n",*pVal);//if (outQueue(&amp;Q,&amp;val))//printf("出队的数字是%d\n",val);elseprintf("出队失败！\n"); traverse(&amp;Q);free(pVal);pVal=NULL;return 0;}void init(PQUEUE pQ){pQ-&gt;pBase=(int*)malloc(sizeof(int)*6);pQ-&gt;front=0;pQ-&gt;rear=0;}bool fullQueue(PQUEUE pQ){if((pQ-&gt;rear+1)%6==pQ-&gt;front)return true;elsereturn false;}bool enQueue(PQUEUE pQ,int val){if(fullQueue(pQ))return false;else{pQ-&gt;pBase[pQ-&gt;rear]=val;pQ-&gt;rear=(pQ-&gt;rear+1)%6;}}bool emptyQueue(PQUEUE pQ){if(pQ-&gt;rear==pQ-&gt;front)return true;elsereturn false;}void traverse(PQUEUE pQ){if(emptyQueue(pQ)){printf("队列为空\n");exit(-1);}else{int i=pQ-&gt;front;while(pQ-&gt;rear!=i){printf("%d",pQ-&gt;pBase[i]); i=(i+1)%6;}printf("\n");}return;}bool outQueue(PQUEUE pQ,int *pVal){if(emptyQueue(pQ))return false;else{*pVal=pQ-&gt;pBase[pQ-&gt;front];pQ-&gt;front=(pQ-&gt;front+1)%6;return true;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2022/11/20/zhan/"/>
      <url>/2022/11/20/zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="一-栈和堆"><a href="#一-栈和堆" class="headerlink" title="一.栈和堆"></a>一.栈和堆</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token operator">*</span>q<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>*q</strong>就是<strong>栈</strong>里的，<strong>200</strong>是堆里的</p><p>动态分配的都在堆里分配，由程序员手动分配</p><p>静态分配的都在栈里分配，由系统自动分配</p><h2 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h2><p>1.定义：</p><ul><li>实现“先进后出”的存储结构</li></ul><p>2.分类：</p><ul><li>静态栈 </li><li>动态栈：内核就是链表</li></ul><p>3.算法</p><ul><li>出栈</li><li>压栈</li></ul><p>4.变量</p><ul><li>pTop</li><li>pBottom</li></ul><p><strong>栈空</strong>：pTop==pBottom</p><p>5.应用</p><ul><li>函数调用</li><li>中断</li><li>表达式求值</li><li>内存分配</li><li>缓冲处理</li><li>迷宫</li></ul><h1 id="二-代码"><a href="#二-代码" class="headerlink" title="二.代码"></a>二.代码</h1><h2 id="1-两个结构体的的定义"><a href="#1-两个结构体的的定义" class="headerlink" title="1.两个结构体的的定义"></a>1.两个结构体的的定义</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span><span class="token keyword">int</span> data<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>pNext<span class="token punctuation">;</span><span class="token punctuation">}</span>NODE<span class="token punctuation">,</span><span class="token operator">*</span>PNODE<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Stack</span><span class="token punctuation">{</span>PNODE pTop<span class="token punctuation">;</span>PNODE pBottom<span class="token punctuation">;</span><span class="token punctuation">}</span>STACK<span class="token punctuation">,</span><span class="token operator">*</span>PSTACK<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>👉对于Stack的理解：</p><p>Stack这个结构体里有两个成员——<strong>名字叫pTop和pBottom、类型为NODE指针</strong></p><h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>PSTACK pS<span class="token punctuation">)</span><span class="token comment">//传参：栈的地址</span><span class="token punctuation">{</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">=</span><span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//给栈顶申请内存空间</span><span class="token keyword">if</span><span class="token punctuation">(</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存分配失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>pS<span class="token operator">-&gt;</span>pBottom<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span><span class="token comment">//此时pT和pB指向同一个内存</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">-&gt;</span>pNext<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//让pT和pB指向同一个节点且该节点的指针域存放的是NULL，该节点作为一个头结点。</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-压栈"><a href="#3-压栈" class="headerlink" title="3.压栈"></a>3.压栈</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>PSTACK pS<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>PNODE pNew<span class="token operator">=</span><span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//为新节点申请空间</span><span class="token keyword">if</span><span class="token punctuation">(</span>pNew<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存分配失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>pNew<span class="token operator">-&gt;</span>data<span class="token operator">=</span>val<span class="token punctuation">;</span>pNew<span class="token operator">-&gt;</span>pNext<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">=</span>pNew<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">pNew<span class="token operator">-&gt;</span>pNext<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>👆理解：</p><p>第一个元素，**pNew-&gt;pNext=pS-&gt;pTop;<strong>和</strong>pNew-&gt;pNext=pS-&gt;pBottom;**都可以 <code>理解为插入的新节点的指针域和pT、pB是一样的，即指向一样，都指向头结点</code></p><p><strong>但是从第二个节点开始</strong>，他的指针域存放的应该得是上一个节点的地址，对应图上的就是<code>右边蓝色的箭头应该==左边被蓝色x覆盖的红色箭头</code>，即<strong>pNew-&gt;pNext=pS-&gt;pTop;</strong></p><h2 id="4-遍历"><a href="#4-遍历" class="headerlink" title="4.遍历"></a>4.遍历</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span>PSTACK pS<span class="token punctuation">)</span><span class="token punctuation">{</span>PNODE p<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span>pS<span class="token operator">-&gt;</span>pBottom<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-出栈"><a href="#5-出栈" class="headerlink" title="5.出栈"></a>5.出栈</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>PSTACK pS<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">==</span>pS<span class="token operator">-&gt;</span>pBottom<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"栈为空！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>PNODE a<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个应该也很好理解：删除a指向的节点，pTop负责往下走，防止因为删掉上面的节点而丢失下面的节点的地址</p><h2 id="6-清空"><a href="#6-清空" class="headerlink" title="6.清空"></a>6.清空</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span>PSTACK pS<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">==</span>pS<span class="token operator">-&gt;</span>pBottom<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"栈为空！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>PNODE p<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span>pS<span class="token operator">-&gt;</span>pBottom<span class="token punctuation">)</span><span class="token punctuation">{</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>p<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大致思路和出栈相似，就是多了个循环，再调换一下语句顺序即可</p><h2 id="7-完整代码"><a href="#7-完整代码" class="headerlink" title="7.完整代码"></a>7.完整代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;malloc.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdbool.h&gt;</span> </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span><span class="token keyword">int</span> data<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>pNext<span class="token punctuation">;</span><span class="token punctuation">}</span>NODE<span class="token punctuation">,</span><span class="token operator">*</span>PNODE<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Stack</span><span class="token punctuation">{</span>PNODE pTop<span class="token punctuation">;</span>PNODE pBottom<span class="token punctuation">;</span><span class="token punctuation">}</span>STACK<span class="token punctuation">,</span><span class="token operator">*</span>PSTACK<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>PSTACK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>PSTACK<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span>PSTACK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>PSTACK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span>PSTACK<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">empty</span><span class="token punctuation">(</span>PSTACK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>STACK S<span class="token punctuation">;</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">traverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n出栈后结果为；\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">traverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">traverse</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"清除成功！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"清除失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>PSTACK pS<span class="token punctuation">)</span><span class="token punctuation">{</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">=</span><span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存分配失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>pS<span class="token operator">-&gt;</span>pBottom<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">-&gt;</span>pNext<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>PSTACK pS<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>PNODE pNew<span class="token operator">=</span><span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pNew<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存分配失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>pNew<span class="token operator">-&gt;</span>data<span class="token operator">=</span>val<span class="token punctuation">;</span>pNew<span class="token operator">-&gt;</span>pNext<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">=</span>pNew<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span>PSTACK pS<span class="token punctuation">)</span><span class="token punctuation">{</span>PNODE p<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span>pS<span class="token operator">-&gt;</span>pBottom<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>PSTACK pS<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">==</span>pS<span class="token operator">-&gt;</span>pBottom<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"栈为空！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>PNODE a<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>bool <span class="token function">empty</span><span class="token punctuation">(</span>PSTACK pS<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">==</span>pS<span class="token operator">-&gt;</span>pBottom<span class="token punctuation">)</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span>PSTACK pS<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">==</span>pS<span class="token operator">-&gt;</span>pBottom<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"栈为空！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>PNODE p<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span>pS<span class="token operator">-&gt;</span>pBottom<span class="token punctuation">)</span><span class="token punctuation">{</span>pS<span class="token operator">-&gt;</span>pTop<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>p<span class="token operator">=</span>pS<span class="token operator">-&gt;</span>pTop<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2022/11/18/lian-biao/"/>
      <url>/2022/11/18/lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="一-typedef"><a href="#一-typedef" class="headerlink" title="一.typedef"></a>一.typedef</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sid<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span>ST<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Student</span> student<span class="token punctuation">;</span><span class="token comment">//&lt;==&gt;ST student;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sid<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">*</span>PST<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Student</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment">//&lt;==&gt;PST *p;</span><span class="token comment">//PST&lt;==&gt;struct Student *</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct Student{    int sid;    int age;}*PST,ST;//效果是上面的整合<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二-链表"><a href="#二-链表" class="headerlink" title="二.链表"></a>二.链表</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><ul><li>n个节点离散分配</li><li>批次通过指针相连</li><li>每隔节点只有一个前驱节点，每个节点只有一个后续节点</li><li>首节点没有前驱节点，尾节点没有后续节点</li><li>[离散存储]</li></ul><h2 id="2-专业术语"><a href="#2-专业术语" class="headerlink" title="2.专业术语"></a>2.专业术语</h2><ul><li>首节点：第一个有效的节点</li><li>尾节点：最后一个有效节点</li><li>头结点：第一个有效节点之前的节点<ul><li>没有存放有效数据</li></ul></li><li>头指针：指向头节点的指针变量</li><li>尾指针：指向尾节点的指针变量</li></ul><h2 id="3-确定一个链表需要的参数"><a href="#3-确定一个链表需要的参数" class="headerlink" title="3.确定一个链表需要的参数"></a>3.确定一个链表需要的参数</h2><p><strong>只需要一个头指针</strong></p><p>👉为什么不用头结点</p><ul><li><p>因为头结点的数据类型和后面有数据域的节点的数据类型是一样的(虽然头结点没有数据域，但是他会有垃圾值，会占内存)</p></li><li><p>头指针只占四个字节来存放头结点的地址</p></li></ul><h2 id="4-节点"><a href="#4-节点" class="headerlink" title="4.节点"></a>4.节点</h2><ul><li>都要有一个指针域和数据域</li><li>结构体的某一个成员指向的是跟它一摸一样的数据类型的数据</li><li>要为创建的每一个节点申请空间</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span><span class="token comment">//数据域</span>    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>pNext<span class="token punctuation">;</span><span class="token comment">//指针域</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-分类"><a href="#5-分类" class="headerlink" title="5.分类"></a>5.分类</h2><ul><li>单链表</li><li>双链表：每个节点有两个指针域</li><li>循环链表：能通过任何一个节点找到其他节点</li><li>非循环链表</li></ul><h1 id="三-作用"><a href="#三-作用" class="headerlink" title="三.作用"></a>三.作用</h1><h2 id="1-创建-初始化"><a href="#1-创建-初始化" class="headerlink" title="1.创建/初始化"></a>1.创建/初始化</h2><ul><li>需要用到的变量：最初创建的链表的长度<strong>len</strong>、每个结构体数据域的数据<strong>val</strong>、头节点<strong>pHead</strong>、尾节点<strong>pTail</strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> len<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">//xxxxxxx</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">pNew<span class="token operator">-&gt;</span>data<span class="token operator">=</span>val<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>pTail=pHead<ul><li>可以理解为用尾指针是针线，把原有链表最后一个节点和新加入的节点连接起来</li></ul></li></ul><h2 id="2-插入"><a href="#2-插入" class="headerlink" title="2.插入"></a>2.插入</h2><ul><li><p>需要用到的参数：头结点，新插入的结构体的位置，新插入的结构体的数据域中的数值</p></li><li><p>需要考虑的问题：要怎么通过输入的<strong>pos</strong>找到要<strong>指向新插入结构体位置的结构体指针</strong></p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">PNODE p<span class="token operator">=</span>pHead<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> i<span class="token operator">&lt;</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//i&lt;p-1就是让p指向要插入位置的上一个结构体 </span><span class="token punctuation">{</span>p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*条件①：确保是在一个不是空的结构体后插入的条件②：p要指向即将要插入的位置的前一个结构体*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们要通过遍历的方式找到目标结构体，假设我们要插入到pos=3</p><ul><li><strong>i&lt;pos=1</strong>这里 i=0时 p=第一个有效结构体</li><li>i=1时，p=第二个有效结构体</li><li>i=2不符合循环条件</li><li>所以while结束后，p就是第二个有效结构体的指针变量</li></ul><h2 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h2><ul><li><p>删除是通过修改前一个结构体指针的指向来删除的</p></li><li><p>所以删除的位置的前一个指针的指向不能是NULL</p></li><li><p>如果要删除的对象的下一个已经是NULL了，那么就不会继续遍历下去 </p></li><li><p><strong>vs插入</strong>，如果要插入的位置是最后一个，即p-&gt;</p></li></ul><h1 id="四-全部代码"><a href="#四-全部代码" class="headerlink" title="四.全部代码"></a>四.全部代码</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;malloc.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdbool.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span><span class="token keyword">int</span> data<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>pNext<span class="token punctuation">;</span><span class="token punctuation">}</span>NODE<span class="token punctuation">,</span><span class="token operator">*</span>PNODE<span class="token punctuation">;</span><span class="token comment">//函数声明</span>PNODE <span class="token function">creatList</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">traverseList</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">isEmpty</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">lengthList</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">insertList</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">deleteList</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>pVal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">sortList</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">lengthList</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> val<span class="token punctuation">;</span>PNODE pHead<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>pHead<span class="token operator">=</span><span class="token function">creatList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//traverseList(pHead);</span><span class="token comment">/*if(isEmpty(pHead))printf("链表为空！\n");elseprintf("链表不空！\n");return 0;*/</span><span class="token comment">/*int len=lengthList(pHead);printf("长链表的长度是%d",len);*/</span><span class="token comment">//sortList(pHead);</span><span class="token comment">//traverseList(pHead);</span><span class="token comment">//insertList(pHead,4,23);</span><span class="token comment">//traverseList(pHead);</span><span class="token function">deleteList</span><span class="token punctuation">(</span>pHead<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">traverseList</span><span class="token punctuation">(</span>pHead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>PNODE <span class="token function">creatList</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> len<span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> val<span class="token punctuation">;</span>PNODE pHead<span class="token operator">=</span><span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pHead<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存分配失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>PNODE pTail<span class="token operator">=</span>pHead<span class="token punctuation">;</span>pTail<span class="token operator">-&gt;</span>pNext<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入您需要生成的链表节点的个数：len="</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%请输入第%d个节点的值"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>PNODE pNew<span class="token operator">=</span><span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pNew<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存分配失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>pNew<span class="token operator">-&gt;</span>data<span class="token operator">=</span>val<span class="token punctuation">;</span>pTail<span class="token operator">-&gt;</span>pNext<span class="token operator">=</span>pNew<span class="token punctuation">;</span>pNew<span class="token operator">-&gt;</span>pNext<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>pTail<span class="token operator">=</span>pNew<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> pHead<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">traverseList</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">{</span>PNODE p<span class="token operator">=</span>pHead<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">}</span>bool <span class="token function">isEmpty</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>pHead<span class="token operator">-&gt;</span>pNext<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">lengthList</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">{</span>PNODE p<span class="token operator">=</span>pHead<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span><span class="token keyword">int</span> len<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">++</span>len<span class="token punctuation">;</span>p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">sortList</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">)</span><span class="token punctuation">{</span>PNODE p<span class="token operator">=</span>pHead<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span>PNODE q<span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> temp<span class="token punctuation">;</span><span class="token keyword">int</span> len<span class="token operator">=</span><span class="token function">lengthList</span><span class="token punctuation">(</span>pHead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>data <span class="token operator">&gt;</span> q<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>temp<span class="token operator">=</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>data<span class="token operator">=</span>q<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>q<span class="token operator">-&gt;</span>data<span class="token operator">=</span>temp<span class="token punctuation">;</span><span class="token punctuation">}</span>q<span class="token operator">=</span>q<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span><span class="token punctuation">}</span>p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bool <span class="token function">insertList</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>PNODE p<span class="token operator">=</span>pHead<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> i<span class="token operator">&lt;</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//i&lt;p-1就是让p指向要插入位置的上一个结构体 </span><span class="token punctuation">{</span>p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&gt;</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span><span class="token constant">NULL</span><span class="token operator">==</span>p<span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span>PNODE pNew<span class="token operator">=</span><span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pNew<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"分配失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> pNew<span class="token operator">-&gt;</span>data<span class="token operator">=</span>val<span class="token punctuation">;</span>PNODE q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>pNext<span class="token operator">=</span>pNew<span class="token punctuation">;</span>pNew<span class="token operator">-&gt;</span>pNext<span class="token operator">=</span>q<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span> bool <span class="token function">deleteList</span><span class="token punctuation">(</span>PNODE pHead<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>pVal<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>PNODE p<span class="token operator">=</span>pHead<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>pNext<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> i<span class="token operator">&lt;</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//i&lt;p-1就是让p指向要删除位置的上一个结构体 </span><span class="token punctuation">{</span>p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&gt;</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span><span class="token constant">NULL</span><span class="token operator">==</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span>PNODE pNew<span class="token operator">=</span><span class="token punctuation">(</span>PNODE<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>NODE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pNew<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"分配失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> PNODE q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span><span class="token operator">*</span>pVal<span class="token operator">=</span>q<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>pNext<span class="token operator">=</span>p<span class="token operator">-&gt;</span>pNext<span class="token operator">-&gt;</span>pNext<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续储存数组</title>
      <link href="/2022/11/13/lian-xu-chu-cun-shu-zu/"/>
      <url>/2022/11/13/lian-xu-chu-cun-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="一-数组"><a href="#一-数组" class="headerlink" title="一.数组"></a>一.数组</h1><ul><li>存放类型相同，大小相等的元素</li></ul><h1 id="二-代码部分"><a href="#二-代码部分" class="headerlink" title="二.代码部分"></a>二.代码部分</h1><h2 id="1-对于传参"><a href="#1-对于传参" class="headerlink" title="1.对于传参"></a>1.对于传参</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">Arr</span><span class="token punctuation">{</span><span class="token keyword">int</span> <span class="token operator">*</span>pBase<span class="token punctuation">;</span><span class="token comment">//存储的是数组第一个元素的地址 </span><span class="token keyword">int</span> len<span class="token punctuation">;</span><span class="token comment">//数组所能容纳的最大元素的个数 </span><span class="token keyword">int</span> cnt<span class="token punctuation">;</span><span class="token comment">//当前数组有效元素的个数 </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">initArr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> arr<span class="token punctuation">;</span><span class="token function">initArr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//地址只用第一个字节的地址表示，第一个字节的地址占4个字节 </span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">initArr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">)</span><span class="token comment">//此时指向arr的第一个地址，现在pArr存放的是arr第一个字节的地址 </span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token operator">*</span>pArr<span class="token punctuation">)</span><span class="token punctuation">.</span>len<span class="token operator">=</span><span class="token number">99</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">initArr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*对于这一行，如果写的是👇initArr(arr);在定义变量时传参传的是(struct Arr array)此时返回到主函数里的arr的len是垃圾值，因为是静态分配内存，当调用完initArr之后传参的就不存在了所以要用到"&amp;arr"，将指针的地址传给initArr中那么在initArr函数里，*pArr就是arr这样做的优点：对比用arr传参(需要用到12个字节)，这样子传参省空间(arr的第一个地址只占4个字节)*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-对结构体的理解"><a href="#2-对结构体的理解" class="headerlink" title="2.对结构体的理解"></a>2.对结构体的理解</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Arr</span><span class="token punctuation">{</span><span class="token keyword">int</span> <span class="token operator">*</span>pBase<span class="token punctuation">;</span><span class="token comment">//存储的是数组第一个元素的地址 </span><span class="token keyword">int</span> len<span class="token punctuation">;</span><span class="token comment">//数组所能容纳的最大元素的个数 </span><span class="token keyword">int</span> cnt<span class="token punctuation">;</span><span class="token comment">//当前数组有效元素的个数 </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>👉因为数组名就是数组首地址元素，所以在定义*<em>int <em>pBase</em></em> 时，pBase是指针变量，也就是地址，同时它是一个数组名</p><p>👉其实也可以理解为，这个结构体，主体部分是pBase，其他成员是这个数组的一些属性的说明</p><p>👉为了把这些属性和数组主体联系起来，搞了一个结构体把它们放在一起</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">initArr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token comment">//此时指向arr的第一个地址，现在pArr存放的是arr第一个字节的地址 </span><span class="token punctuation">{</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token operator">==</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"动态内存分配失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>pArr<span class="token operator">-&gt;</span>len<span class="token operator">=</span>length<span class="token punctuation">;</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">//告诉程序这个函数结束了 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>👉pBase是一个数组，先给他分配空间</p><ul><li>对pBase内存是否分配成功要做一个判定</li><li>判定成功了就给他这个结构体赋值</li></ul><h2 id="4-打印"><a href="#4-打印" class="headerlink" title="4.打印"></a>4.打印</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">showArr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>pArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数组为空！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-判断数组里是否有元素"><a href="#5-判断数组里是否有元素" class="headerlink" title="5.判断数组里是否有元素"></a>5.判断数组里是否有元素</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-判断数组是否是满的"><a href="#6-判断数组是否是满的" class="headerlink" title="6.判断数组是否是满的"></a>6.判断数组是否是满的</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token operator">==</span>pArr<span class="token operator">-&gt;</span>len<span class="token punctuation">)</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-追加元素"><a href="#7-追加元素" class="headerlink" title="7.追加元素"></a>7.追加元素</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">appendArr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token comment">//val是要加入的元素</span><span class="token punctuation">{</span><span class="token comment">//满时返回false，不加</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span>pArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token comment">//不满时追加</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token punctuation">]</span><span class="token operator">=</span>val<span class="token punctuation">;</span> <span class="token punctuation">(</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>👉cnt的值=最后一个元素的下标+1</p><p>👉最后记得要给有效值+1</p><h2 id="8-插入元素"><a href="#8-插入元素" class="headerlink" title="8.插入元素"></a>8.插入元素</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">insertArr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span>pArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>pos<span class="token operator">&gt;</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>val<span class="token punctuation">;</span><span class="token punctuation">(</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>满了、输入的位置不符合数组现有的→返回错误，在主程序里不执行</li></ul><p>👉对于for里的</p><ul><li><strong>i=pArr-&gt;cnt-1</strong> i对应着下标</li><li><strong>i=pos-1</strong> 插入时只变动要插入位置的该位上和该位后的元素</li><li><strong>–i</strong> 进行插入的逻辑是，先对最后一位操作，最后一位先往后移动，然后前面的再往后移动，最后空出一个位置给要插入的元素插入</li></ul><p>👉然后</p><ul><li><p>前一个元素移动到后一个元素上</p></li><li><p>放置新元素</p></li><li><p>有效值+1</p></li></ul><h2 id="9-删除元素"><a href="#9-删除元素" class="headerlink" title="9.删除元素"></a>9.删除元素</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">deleteArr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>pVal<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>pArr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>pos<span class="token operator">&gt;</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token punctuation">)</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token operator">*</span>pVal<span class="token operator">=</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>pos<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>空的、输入不符合数组现有的→返回错误，再主程序中不执行</li></ul><p>感觉跟插入一个意思….</p><h2 id="10-元素倒置"><a href="#10-元素倒置" class="headerlink" title="10.元素倒置"></a>10.元素倒置</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">inversionArr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span> <span class="token operator">*</span>pArr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> j<span class="token operator">=</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> t<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>t<span class="token operator">=</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-元素排序"><a href="#11-元素排序" class="headerlink" title="11.元素排序"></a>11.元素排序</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sortArr</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Arr</span><span class="token operator">*</span> pArr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>t<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>pArr<span class="token operator">-&gt;</span>cnt<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>t<span class="token operator">=</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>pArr<span class="token operator">-&gt;</span>pBase<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DS1302时钟</title>
      <link href="/2022/11/12/ds1302-shi-zhong/"/>
      <url>/2022/11/12/ds1302-shi-zhong/</url>
      
        <content type="html"><![CDATA[<p><strong>DS1302</strong></p><h1 id="一-引脚分装"><a href="#一-引脚分装" class="headerlink" title="一.引脚分装"></a>一.引脚分装</h1><p>1.DIP直插</p><p>2.SO贴片</p><p><img src="/../../../../medias/blog_picture/51/59.png"></p><p><img src="/../../../../medias/blog_picture/51/60.png"></p><p>其中，<strong>CE为高电平的时候下面的命令(io和SCLK)才有用。</strong>时间存储在实时时钟里，在左边被访问和读写</p><h1 id="二-内部寄存器"><a href="#二-内部寄存器" class="headerlink" title="二.内部寄存器"></a>二.内部寄存器</h1><p><img src="/../../../../medias/blog_picture/51/61.png"></p><p>WP是读写保护</p><h1 id="三-考虑的问题"><a href="#三-考虑的问题" class="headerlink" title="三.考虑的问题"></a>三.考虑的问题</h1><p>在哪(xx寄存器) 写入 什么</p><p>在哪(xx寄存器) 读出 什么(1302芯片返回的，单片机需要读到)</p><p><img src="/../../../../medias/blog_picture/51/62.png"></p><p>第六位：给1——RAM，给0——CK</p><p>6~1完成“在哪”的任务</p><p>第零位：完成“读/写”的任务，给1——读，给0——写</p><p>在<strong>二</strong>的表中已经把“读/写”的命令列出来了</p><h2 id="1-时序定义"><a href="#1-时序定义" class="headerlink" title="1.时序定义"></a>1.时序定义</h2><p><img src="/../../../../medias/blog_picture/51/63.png"></p><p>上升沿(io口的电平被)写入(/向时钟芯片写入数据)，下降沿(DS1302把他的数据)输出(时钟芯片向单片机写入数据)，<strong>所以，只有READ中的D0~D7是芯片写入的</strong></p><p>写入时，先写入数据再进行上升沿。</p><h2 id="2-每个按键的功能"><a href="#2-每个按键的功能" class="headerlink" title="2.每个按键的功能"></a>2.每个按键的功能</h2><ul><li>K1选择模式 MODE=1👉设置时间 MODE=0👉显示流动的时间</li><li>K2选择要更改的时间值(年月日时分秒)</li><li>K3更改某个时间值，+</li><li>K4更改某个时间值，-</li></ul><h1 id="四-代码"><a href="#四-代码" class="headerlink" title="四.代码"></a>四.代码</h1><h2 id="DS1302-C"><a href="#DS1302-C" class="headerlink" title="DS1302.C"></a>DS1302.C</h2><p><strong>1.</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void DS1302_WriteByte(unsigned char Command,Data)//写入{unsigned char i;DS1302_CE=1;for(i=0;i&lt;8;i++){DS1302_IO=Command&amp;(0x01&lt;&lt;i);//1~7位直接清零，只留第0位DS1302_SCLK=1;DS1302_SCLK=0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于每一位，先写入操作指令再给上升沿</p><p><strong>2.</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token function">DS1302_ReadByte</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Command<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span>Data<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span>Command<span class="token operator">|=</span><span class="token number">0x01</span><span class="token punctuation">;</span><span class="token comment">//将指令转换为读指令</span>DS1302_CE<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//读出-指令</span><span class="token punctuation">{</span>DS1302_IO<span class="token operator">=</span>Command<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">0x01</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>DS1302_SCLK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>DS1302_SCLK<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//读出-数据</span><span class="token punctuation">{</span>DS1302_SCLK<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//看时序图，先少一个高电平</span>DS1302_SCLK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//最后是低电平</span><span class="token keyword">if</span><span class="token punctuation">(</span>DS1302_IO<span class="token punctuation">)</span><span class="token punctuation">{</span>Data<span class="token operator">|=</span><span class="token punctuation">(</span><span class="token number">0x01</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>DS1302_CE<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>DS1302_IO<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//读取后将IO设置为0，否则读出的数据会出错</span><span class="token keyword">return</span> Data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于为什么要return DataX，👇我的理解</p><ul><li>首先在<strong>DS1302_WriteByte</strong>中写入数据，是多少秒(0~15)，就输入0x xx，然后16进制转2进制</li><li>在<strong>DS1302_ReadByte</strong>中读取数据，对每一位进行判断</li><li>e.g. 写入时写入了0x03—16转2—&gt;0000 0100，然后在read函数里对每一位进行判断，执行完读命令字后，数据传输到IO口上，是1的，Data就置1，否则置0，所以Data就是个接收数据的中转站罢了。</li><li>然后return之后，LCD那里的定义是<strong>unsigned int Number</strong>在传参时，已经自动把2进制转换为10进制了，所以显示出来的数据就是10进制的。</li></ul><p><strong>3.自动清零</strong></p><p>e.g.希望让a超过5之后清零，从0开始再递增</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&gt;</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;=</span><span class="token operator">=</span><span class="token operator">&gt;</span>a<span class="token operator">=</span><span class="token operator">%</span><span class="token number">6</span><span class="token punctuation">;</span><span class="token comment">//a=6%6=0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>4.</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">3</span><span class="token operator">||</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">5</span><span class="token operator">||</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">7</span><span class="token operator">||</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">8</span><span class="token operator">||</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">10</span><span class="token operator">||</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">31</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">{</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//12-31调回11-xx时会显示11-31，所以需要加上这句话</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于为什么要在K4-这里复制一部分K3+的代码</p><ul><li>从12-31调回11月份时，会显示为11-31，所以要加上那部分代码</li></ul><p><strong>5.</strong></p><p>某个时间值被选中后跳动</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>TimeSetSelect<span class="token operator">==</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>TimeSetFlashFlag<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">LCD_ShowString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"  "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>DS1302_Time<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定时器每隔500ms对TimeSetFlashFlag置1或0，当TSFF为1且时间值选中的是0–时 时，在原本显示时的时间那一块地方显示空格；如果不符合if的条件，则显示时间，所以TSFF在0和1跳动时，决定了频闪的显示。</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCD1602</title>
      <link href="/2022/10/30/lcd1602/"/>
      <url>/2022/10/30/lcd1602/</url>
      
        <content type="html"><![CDATA[<h1 id="LCD1602-16-2"><a href="#LCD1602-16-2" class="headerlink" title="LCD1602(16*2)"></a>LCD1602(16*2)</h1><h2 id="一-原理部分"><a href="#一-原理部分" class="headerlink" title="一.原理部分"></a>一.原理部分</h2><h3 id="1-引脚"><a href="#1-引脚" class="headerlink" title="1.引脚"></a>1.引脚</h3><p>显示容量：16*2个字符</p><p><img src="/../../../../medias/blog_picture/51/76.png"></p><p>VO(对比度)：<strong>值太小</strong>显示会很浅，<strong>看不清</strong>，<strong>值太大</strong>每个像素都显示出来，<strong>无法辨别</strong>哪些是我们想要的，<strong>我们用R1来调节</strong></p><p>D1~D7：<strong>并行传送模式</strong>，最好接在<strong>一组io口</strong>上，D0–P0_1，D7–P0_7(高位对高位，低位对低位)</p><p>RS(在哪写)&amp;RW(写什么)&amp;E：控制引脚，控制D1~D7</p><p>E：上升沿的时候把数据传到D1~D7，下降沿的时候执行命令</p><h3 id="2-内部结构"><a href="#2-内部结构" class="headerlink" title="2.内部结构"></a>2.内部结构</h3><p><img src="/../../../../medias/blog_picture/51/77.png"></p><p>C(character)G(generater)字符生成</p><p>CGRAM是可写的，是自定义存储数据</p><p>CGROM不可写，早已规定，相当于字典</p><p>字模库就是段码表</p><p>D(data)D(display)数据显示</p><p>DDRAM，用户可写，对应到屏幕的话只会显示前16列(前16列映射到屏幕上)，从第17列开始可以写，因为屏幕不够大所以显示不了(问题不大)</p><h3 id="3-段码表"><a href="#3-段码表" class="headerlink" title="3.段码表"></a>3.段码表</h3><p>我们先要有一个段码表，然后找索引对应屏幕里的</p><p><img src="/../../../../medias/blog_picture/51/78.png"></p><p>可写的只有八个，在0001 0000-0001 0111</p><p>不可写e.g.比如A，对应0100 0001–转16进制–&gt;0x41</p><h3 id="4-时序图"><a href="#4-时序图" class="headerlink" title="4.时序图"></a>4.时序图</h3><p><img src="/../../../../medias/blog_picture/51/79.png"></p><p><img src="/../../../../medias/blog_picture/51/80.png"></p><p>最高位为1位置不同可以区分不同的指令</p><ul><li>特别是在DB7置1绝对是要操作DDRAM</li></ul><h3 id="5-设置光标位置DDRAM-数据显示"><a href="#5-设置光标位置DDRAM-数据显示" class="headerlink" title="5.设置光标位置DDRAM(数据显示)"></a>5.设置光标位置DDRAM(数据显示)</h3><p><img src="/../../../../medias/blog_picture/51/81.png"></p><p>第一行：<strong>1</strong>000 0000 –&gt;0x80</p><p>第二行：<strong>1</strong>100 0000 –&gt;0xC0</p><p>两串的第一个<strong>1</strong>都代表要进入DDRAM这个指令</p><p>因为第一行的地址是00所以后接000 0000，第二行的地址是40所以后接100(二转十就是4) 0000</p><h2 id="二-代码部分"><a href="#二-代码部分" class="headerlink" title="二.代码部分"></a>二.代码部分</h2><h3 id="1-子函数"><a href="#1-子函数" class="headerlink" title="1.子函数"></a>1.子函数</h3><h4 id="①LCD-WriteCommand"><a href="#①LCD-WriteCommand" class="headerlink" title="①LCD_WriteCommand"></a>①LCD_WriteCommand</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">LCD_WriteCommand</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Command<span class="token punctuation">)</span><span class="token punctuation">{</span>LCD_RS<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//0为指令</span>LCD_RW<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//0为输入</span>LCD_DataPort<span class="token operator">=</span>Command<span class="token punctuation">;</span>LCD_E<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token function">LCD_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延缓快速上下拉</span>LCD_E<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token function">LCD_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延缓快速上下拉</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="②LCD-DataCommand"><a href="#②LCD-DataCommand" class="headerlink" title="②LCD_DataCommand"></a>②LCD_DataCommand</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">LCD_WriteData</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Data<span class="token punctuation">)</span><span class="token punctuation">{</span>LCD_RS<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//0为数据</span>LCD_RW<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//0为输入</span>LCD_DataPort<span class="token operator">=</span>Data<span class="token punctuation">;</span>LCD_E<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token function">LCD_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延缓快速上下拉</span>LCD_E<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token function">LCD_Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延缓快速上下拉</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="③LCD-Init"><a href="#③LCD-Init" class="headerlink" title="③LCD_Init"></a>③LCD_Init</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">LCD_Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">LCD_WriteCommand</span><span class="token punctuation">(</span><span class="token number">0x38</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//八位数据接口，两行显示，5x7点阵屏</span><span class="token function">LCD_WriteCommand</span><span class="token punctuation">(</span><span class="token number">0x0C</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//显示开，光标关，闪烁关</span><span class="token function">LCD_WriteCommand</span><span class="token punctuation">(</span><span class="token number">0x06</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//数据读写操作后，光标自动加一，画面不动</span><span class="token function">LCD_WriteCommand</span><span class="token punctuation">(</span><span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//清屏</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="④-LCD-ShowChar"><a href="#④-LCD-ShowChar" class="headerlink" title="④.LCD_ShowChar"></a>④.LCD_ShowChar</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">LCD_WriteCommand</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token operator">|</span>Column<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>👆理解：Column是列。列-1再并上0x80才转换为对应的地址</p><ul><li>e.g. 当选择**(1,2)<strong>时，由</strong>DDRAM**的表格我们得知该位置的地址是01H</li><li>此时传参到Column的是2，2-1=1，1–10进制转2进制–&gt;0001</li><li>1000 0000|0000 0001=1000 0001</li><li>把<code>1</code> <code>000 0001</code>分成两个模块</li><li><code>1</code>是指进入DDRAM模式</li><li><code>000 0001</code>对应01H，写入到(1,2)位上</li></ul>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
            <tag> 大云屋考核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蜂鸣器</title>
      <link href="/2022/10/18/feng-ming-qi/"/>
      <url>/2022/10/18/feng-ming-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h1><p><img src="/../../../../medias/blog_picture/51/64.png"></p><p>无源蜂鸣器不能一直通电流，它内部置了线圈，要给他交流震荡</p><p><img src="/../../../../medias/blog_picture/51/65.png"></p><p>VCC高电平，只有蜂鸣器接口处为0才能驱动；白色三角是非门，左边给1/0右边反0/1</p><p><img src="/../../../../medias/blog_picture/51/66.png"></p><h2 id="经典上代码"><a href="#经典上代码" class="headerlink" title="经典上代码"></a>经典上代码</h2><h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Key.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Nixie.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Buzzer.h"</span></span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> KeyNum<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>KeyNum<span class="token operator">=</span><span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Buzzer_Time</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>KeyNum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Key-c"><a href="#Key-c" class="headerlink" title="Key.c"></a>Key.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token comment">/**  * @brief  获取独立按键键码  * @param  无  * @retval 按下按键的键码，范围：0~4，无按键按下时返回值为0  */</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> KeyNumber<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_1<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_1<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_0<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_0<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_2<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_2<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_3<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_3<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> KeyNumber<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Nixie-c"><a href="#Nixie-c" class="headerlink" title="Nixie.c"></a>Nixie.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span><span class="token comment">//包含Delay头文件</span></span><span class="token comment">//数码管段码表</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> NixieTable<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0x3F</span><span class="token punctuation">,</span><span class="token number">0x06</span><span class="token punctuation">,</span><span class="token number">0x5B</span><span class="token punctuation">,</span><span class="token number">0x4F</span><span class="token punctuation">,</span><span class="token number">0x66</span><span class="token punctuation">,</span><span class="token number">0x6D</span><span class="token punctuation">,</span><span class="token number">0x7D</span><span class="token punctuation">,</span><span class="token number">0x07</span><span class="token punctuation">,</span><span class="token number">0x7F</span><span class="token punctuation">,</span><span class="token number">0x6F</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//数码管显示子函数</span><span class="token keyword">void</span> <span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Location<span class="token punctuation">,</span>Number<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span><span class="token punctuation">(</span>Location<span class="token punctuation">)</span><span class="token comment">//位码输出</span><span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>P2_4<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>P2_3<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>P2_2<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>P2_4<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>P2_3<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>P2_2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>P2_4<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>P2_3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>P2_2<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>P2_4<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>P2_3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>P2_2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>P2_4<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>P2_3<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>P2_2<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span>P2_4<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>P2_3<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>P2_2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span>P2_4<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>P2_3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>P2_2<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">8</span><span class="token operator">:</span>P2_4<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>P2_3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>P2_2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>P0<span class="token operator">=</span>NixieTable<span class="token punctuation">[</span>Number<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//段码输出</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Buzzer-c"><a href="#Buzzer-c" class="headerlink" title="Buzzer.c"></a>Buzzer.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;INTRINS.H&gt;</span></span><span class="token comment">//蜂鸣器端口：</span>sbit Buzzer<span class="token operator">=</span>P2<span class="token operator">^</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">/**  * @brief  蜂鸣器私有延时函数，延时500ms  * @param  无  * @retval 无  */</span><span class="token keyword">void</span> <span class="token function">Buzzer_Delay500us</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//@11.0592MHz，专门为蜂鸣器写了一个</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">;</span><span class="token function">_nop_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token number">227</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**  * @brief  蜂鸣器发声  * @param  ms，发声的时长  * @retval 无  */</span><span class="token keyword">void</span> <span class="token function">Buzzer_Time</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> ms<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//原来的Delay最小是1ms(半个周期)，那么1个周期是2ms，能达到的蜂鸣器最大频率是1/2*0.1^3=500Hz，蜂鸣器标准提示音是1000Hz</span><span class="token comment">//根据f=1/T，Delay(模块，不建议修改)的应该要更小，但是1已经是最小的</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ms<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//用for循环是为了让蜂鸣器响的久一点</span>        <span class="token comment">//*2的原因：现在的ms代表500us，不乘二，它只响ms/2毫秒，乘以二才是响ms毫秒</span><span class="token punctuation">{</span>Buzzer<span class="token operator">=</span><span class="token operator">!</span>Buzzer<span class="token punctuation">;</span><span class="token comment">//发声需要翻转两次io口</span><span class="token function">Buzzer_Delay500us</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//半个周期500us，一个周期1000us，频率1000Hz=1/1000*0.1^6</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Buzzer-h"><a href="#Buzzer-h" class="headerlink" title="Buzzer.h"></a>Buzzer.h</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__Buzzer_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__Buzzer_H__</span></span>sbit Buzzer<span class="token operator">=</span>P2<span class="token operator">^</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Buzzer_Time</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><p>音符–&gt;频率(Hz)–&gt;周期(us)–&gt;周期/2(us)–&gt;取整–&gt;<strong>重装数值(用到定时器)</strong></p><p><strong>周期</strong>=1/频率</p><p><strong>周期/2</strong>：半个周期翻转一次</p><p>周期/2-小数点=<strong>取整</strong></p><p>65535-取整=<strong>重装数值</strong></p><h4 id="用定时器操控频率"><a href="#用定时器操控频率" class="headerlink" title="用定时器操控频率"></a>用定时器操控频率</h4><h4 id="main-c-1"><a href="#main-c-1" class="headerlink" title="main.c"></a>main.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Time0.h"</span></span>sbit Buzzer<span class="token operator">=</span>P2<span class="token operator">^</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> FreqTable<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">63628</span><span class="token punctuation">,</span><span class="token number">63731</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//存放每个音的重载数值</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> FreqSelect<span class="token punctuation">;</span><span class="token comment">//对于数组FreqTable中每个数据对应的Index</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Timer0Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>FreqSelect<span class="token operator">++</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在中断里每个500ms自动切换到下一个音</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Timer0_Routine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> interrupt <span class="token number">1</span><span class="token comment">//定时器初始化每隔1ms进行一次，所以每隔1ms中断一次</span><span class="token punctuation">{</span>TL0 <span class="token operator">=</span> FreqTable<span class="token punctuation">[</span>FreqSelect<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">256</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span>TH0 <span class="token operator">=</span> FreqTable<span class="token punctuation">[</span>FreqSelect<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">256</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span><span class="token comment">//跟子函数里的设置不同在于，之后的溢出都是这里管理的，子函数那只管理一次</span>Buzzer<span class="token operator">=</span><span class="token operator">!</span>Buzzer<span class="token punctuation">;</span> <span class="token comment">//直接翻转，一个周期是2*1ms(翻转两次才是一个周期)，频率=1/2*1*0.1^3=500Hz</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Timer0-c"><a href="#Timer0-c" class="headerlink" title="Timer0.c"></a>Timer0.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token comment">/**  * @brief  定时器0初始化，1ms@11.0592MH  * @param  无  * @retval 无  */</span><span class="token keyword">void</span> <span class="token function">Timer0Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//1毫秒@11.0592MHz</span><span class="token punctuation">{</span>TMOD <span class="token operator">&amp;=</span> <span class="token number">0xF0</span><span class="token punctuation">;</span><span class="token comment">//设置定时器模式</span>TMOD <span class="token operator">|=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>TL0 <span class="token operator">=</span> <span class="token number">0x66</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span>TH0 <span class="token operator">=</span> <span class="token number">0xFC</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span><span class="token comment">//TH0和TL0无关紧要，他们只决定第一次中断时间，因为溢出之后他们不清零，所以这里可以不改，只改主函数里的</span>TF0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//清除TF0标志</span>TR0 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//定时器0开始计时</span>ET0<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">//允许中断</span>EA<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>PT0<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*定时器中断函数模板void Timer0_Routine() interrupt 1{static unsigned int T0Count;//为了不丢失这个数字TL0 = 0x66;//设置定时初值TH0 = 0xFC;//设置定时初值T0Count++;if(T0Count&gt;=1000){T0Count=0;}}*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
            <tag> 大云屋考核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Calculator简易计算器</title>
      <link href="/2022/10/13/jian-yi-ji-suan-qi/"/>
      <url>/2022/10/13/jian-yi-ji-suan-qi/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;windows.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">int</span> o_top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//符号栈头</span><span class="token keyword">int</span> num_top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//数字栈头 </span><span class="token keyword">char</span> o_s<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//符号栈 </span><span class="token keyword">int</span> num_s<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//数字栈 </span><span class="token keyword">int</span> <span class="token function">jop</span><span class="token punctuation">(</span><span class="token keyword">char</span> o<span class="token punctuation">)</span><span class="token comment">//判断符号等级 judge_operator_priority</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">||</span> o <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token char">'*'</span> <span class="token operator">||</span> o <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token char">'^'</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//操作符出栈 </span><span class="token keyword">void</span> <span class="token function">o_push</span><span class="token punctuation">(</span><span class="token keyword">char</span> o<span class="token punctuation">)</span><span class="token punctuation">{</span>o_top<span class="token operator">++</span><span class="token punctuation">;</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span> <span class="token operator">=</span> o<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//操作数出栈 </span><span class="token keyword">void</span> <span class="token function">num_push</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>num_top<span class="token operator">++</span><span class="token punctuation">;</span>num_s<span class="token punctuation">[</span>num_top<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//自定义两元运算</span><span class="token comment">//说明:operand1先进后出，operand2后进先出，所以运算的表达式应该为&lt;operand1&gt;&lt;oeprator&gt;&lt;operand2&gt; </span><span class="token keyword">int</span> <span class="token function">math</span><span class="token punctuation">(</span><span class="token keyword">int</span> n1<span class="token punctuation">,</span> <span class="token keyword">int</span> n2<span class="token punctuation">,</span> <span class="token keyword">char</span> o<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token char">'+'</span><span class="token punctuation">)</span><span class="token keyword">return</span> n1 <span class="token operator">+</span> n2<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span><span class="token keyword">return</span> n1 <span class="token operator">-</span> n2<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token char">'*'</span><span class="token punctuation">)</span><span class="token keyword">return</span> n1 <span class="token operator">*</span> n2<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token char">'/'</span> <span class="token operator">&amp;&amp;</span> n2 <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> n1 <span class="token operator">/</span> n2<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token char">'/'</span> <span class="token operator">&amp;&amp;</span> n2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"出错！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token char">'^'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">pow</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"WB版计算器由于技术原因，仅支持以下运算....\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Sleep(1500);</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1.带括号的+-*/运算\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Sleep(1500);</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2.进制转换计算\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Sleep(1500);</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"现在，请你输入“1”或“2”进行运算:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> choice<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>choice<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*当用户输入1时，进入4+1运算*/</span><span class="token comment">/*浅谈规则：1.操作符栈栈顶为空 或 栈顶操作符优先级&lt;当前操作符 时，当前操作符入栈2.栈顶操作符优先级&gt;目前操作符 且 数据栈至少有2个操作数 且 栈顶不为( 时，栈顶操作符出栈3.whlie循环次数是&lt;而不是&lt;= 的原因:最后出现x1(由这个while循环计算得到的数据)o x2(原表达式最后的操作数)4.每次运算后(调用了math函数后)，将该次运算结果放回栈中(补到栈顶下面那个)，然后再声明栈顶设其为0，进行栈顶--，使栈顶回到含有有效数据那*/</span><span class="token keyword">if</span> <span class="token punctuation">(</span>choice <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//记录算式</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Please enter the equation(no space):\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">o_push</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>t <span class="token operator">=</span> t <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">num_push</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//+ -</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">||</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o_top <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">jop</span><span class="token punctuation">(</span>num_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">o_push</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span> <span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">||</span> <span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o_top <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> num_top <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> n1 <span class="token operator">=</span> num_s<span class="token punctuation">[</span>num_top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n2 <span class="token operator">=</span> num_s<span class="token punctuation">[</span>num_top<span class="token punctuation">]</span><span class="token punctuation">;</span>num_s<span class="token punctuation">[</span>num_top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">math</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num_s<span class="token punctuation">[</span>num_top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>num_top<span class="token operator">--</span><span class="token punctuation">;</span> o_top<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">o_push</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//* /</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'*'</span> <span class="token operator">||</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o_top <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">o_push</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span> <span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o_top <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> num_top <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> n1 <span class="token operator">=</span> num_s<span class="token punctuation">[</span>num_top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n2 <span class="token operator">=</span> num_s<span class="token punctuation">[</span>num_top<span class="token punctuation">]</span><span class="token punctuation">;</span>num_s<span class="token punctuation">[</span>num_top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">math</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num_s<span class="token punctuation">[</span>num_top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>num_top<span class="token operator">--</span><span class="token punctuation">;</span> o_top<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">o_push</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// ^ </span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'^'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o_top <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span> <span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">o_push</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>o_top <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> num_top <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> n1 <span class="token operator">=</span> num_s<span class="token punctuation">[</span>num_top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n2 <span class="token operator">=</span> num_s<span class="token punctuation">[</span>num_top<span class="token punctuation">]</span><span class="token punctuation">;</span>num_s<span class="token punctuation">[</span>num_top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">math</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num_s<span class="token punctuation">[</span>num_top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>num_top<span class="token operator">--</span><span class="token punctuation">;</span> o_top<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">o_push</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// )</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n1 <span class="token operator">=</span> num_s<span class="token punctuation">[</span>num_top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n2 <span class="token operator">=</span> num_s<span class="token punctuation">[</span>num_top<span class="token punctuation">]</span><span class="token punctuation">;</span>num_s<span class="token punctuation">[</span>num_top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">math</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num_s<span class="token punctuation">[</span>num_top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>num_top<span class="token operator">--</span><span class="token punctuation">;</span> o_top<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">jop</span><span class="token punctuation">(</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> o_top <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> num_top <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>o_top<span class="token operator">--</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//最后只剩下两个操作数和一个操作符，直接二元运算 </span><span class="token keyword">while</span> <span class="token punctuation">(</span>o_top <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> num_top <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> n1 <span class="token operator">=</span> num_s<span class="token punctuation">[</span>num_top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n2 <span class="token operator">=</span> num_s<span class="token punctuation">[</span>num_top<span class="token punctuation">]</span><span class="token punctuation">;</span>num_s<span class="token punctuation">[</span>num_top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">math</span><span class="token punctuation">(</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>num_s<span class="token punctuation">[</span>num_top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>o_s<span class="token punctuation">[</span>o_top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>num_top<span class="token operator">--</span><span class="token punctuation">;</span> o_top<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> num_s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*当用户输入2时，进行进制转换*/</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>choice <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">/**  n进制转10进制*/</span><span class="token keyword">int</span> pr<span class="token punctuation">;</span><span class="token comment">//previous,先前的进制 </span><span class="token keyword">int</span> fn<span class="token punctuation">;</span><span class="token comment">//final，最后的进制</span><span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment">//用于测量长度 </span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> ch<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"即将输入三个数字，输入每个数字后，按回车转跳下一个输入内容......\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入原进制："</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入原数据："</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入想要转换成的数据的进制："</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>size <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> temp1 <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>pr<span class="token punctuation">,</span> size <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> temp2 <span class="token operator">=</span> ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token char">'A'</span><span class="token operator">:</span>sum <span class="token operator">+=</span> <span class="token punctuation">(</span>temp2 <span class="token operator">-</span> <span class="token number">55</span><span class="token punctuation">)</span> <span class="token operator">*</span> temp1<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'B'</span><span class="token operator">:</span>sum <span class="token operator">+=</span> <span class="token punctuation">(</span>temp2 <span class="token operator">-</span> <span class="token number">55</span><span class="token punctuation">)</span> <span class="token operator">*</span> temp1<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'C'</span><span class="token operator">:</span>sum <span class="token operator">+=</span> <span class="token punctuation">(</span>temp2 <span class="token operator">-</span> <span class="token number">55</span><span class="token punctuation">)</span> <span class="token operator">*</span> temp1<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'D'</span><span class="token operator">:</span>sum <span class="token operator">+=</span> <span class="token punctuation">(</span>temp2 <span class="token operator">-</span> <span class="token number">55</span><span class="token punctuation">)</span> <span class="token operator">*</span> temp1<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'E'</span><span class="token operator">:</span>sum <span class="token operator">+=</span> <span class="token punctuation">(</span>temp2 <span class="token operator">-</span> <span class="token number">55</span><span class="token punctuation">)</span> <span class="token operator">*</span> temp1<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'F'</span><span class="token operator">:</span>sum <span class="token operator">+=</span> <span class="token punctuation">(</span>temp2 <span class="token operator">-</span> <span class="token number">55</span><span class="token punctuation">)</span> <span class="token operator">*</span> temp1<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span>sum <span class="token operator">+=</span> <span class="token punctuation">(</span>temp2 <span class="token operator">-</span> <span class="token number">48</span><span class="token punctuation">)</span> <span class="token operator">*</span> temp1<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/**10进制转n进制*/</span><span class="token keyword">char</span> ans<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">;</span><span class="token comment">//答案存放 </span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>sum <span class="token operator">%</span> fn<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">10</span><span class="token operator">:</span>ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'A'</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">11</span><span class="token operator">:</span>ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'B'</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">12</span><span class="token operator">:</span>ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'C'</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">13</span><span class="token operator">:</span>ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'D'</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">14</span><span class="token operator">:</span>ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'E'</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">15</span><span class="token operator">:</span>ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'F'</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span>ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">%</span> fn<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">48</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>j<span class="token operator">++</span><span class="token punctuation">;</span>sum <span class="token operator">/=</span> fn<span class="token punctuation">;</span><span class="token punctuation">}</span>j<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大云屋考核 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点阵屏</title>
      <link href="/2022/10/12/dian-zhen-ping/"/>
      <url>/2022/10/12/dian-zhen-ping/</url>
      
        <content type="html"><![CDATA[<h1 id="点阵屏"><a href="#点阵屏" class="headerlink" title="点阵屏"></a>点阵屏</h1><p>跟数码管原理有一些类似</p><p><img src="/../../../../medias/blog_picture/51/4.png" alt="显示原理"></p><p><img src="/../../../../medias/blog_picture/51/5.png" alt="行与列的控制关系"></p><p>圈起来部分用来控制<strong>行</strong>或<strong>列</strong></p><p><img src="/../../../../medias/blog_picture/51/6.png" alt="开发板引脚对应关系"></p><p>列直接给P0赋值来控制</p><p>但是行要用到74HC595</p><p>提出：若是单片机上只有这个LED点阵屏，其他都不要，可不可以把D1-D7的接在P1口上</p><p>回答：不行，因为单片机的IO口是弱上拉特性</p><p>弱上拉：输出**低电平(直接接GND)<strong>时电流可以很大，输出</strong>高电平(相当于接了一个电阻再接VCC)**时电流很小</p><p><img src="/../../../../medias/blog_picture/51/7.png" alt="IO口">用到三极管，接IO口就可以</p><p>IO口低电平，VCC直接通到4那，IO起控制作用，自己干不动不干活而指使别人干活</p><p>IO口给高电平的时候就会截止，相当于没有接</p><h2 id="IO口扩展"><a href="#IO口扩展" class="headerlink" title="IO口扩展"></a>IO口扩展</h2><h3 id="OE-output-enable输出使能"><a href="#OE-output-enable输出使能" class="headerlink" title="OE(output enable输出使能)"></a>OE(output enable输出使能)</h3><p><img src="/../../../../medias/blog_picture/51/8.png" alt="OE"></p><h3 id="寄存器时钟，RCLK-register-clock"><a href="#寄存器时钟，RCLK-register-clock" class="headerlink" title="寄存器时钟，RCLK(register clock)"></a>寄存器时钟，RCLK(register clock)</h3><p>上方有—，表示它要接低电平，所以JOE那要和GND短接，才能有输出</p><p><img src="/../../../../medias/blog_picture/51/9.png" alt="RCLK"></p><h3 id="SRCLR串行清零端"><a href="#SRCLR串行清零端" class="headerlink" title="SRCLR串行清零端"></a>SRCLR串行清零端</h3><p>接了VCC代表它不清空</p><p><img src="/../../../../medias/blog_picture/51/10.png" alt="SRCLR"></p><h3 id="SRCLK串行时钟"><a href="#SRCLK串行时钟" class="headerlink" title="SRCLK串行时钟"></a>SRCLK串行时钟</h3><p>上升沿是PWM波的从低电平到高电平的一瞬间</p><p><img src="/../../../../medias/blog_picture/51/11.png" alt="SRCLK"></p><h3 id="SER串行数据"><a href="#SER串行数据" class="headerlink" title="SER串行数据"></a>SER串行数据</h3><p><img src="/../../../../medias/blog_picture/51/12.png" alt="SER"></p><p>主要用这三个引脚控制八个输出</p><p><img src="/../../../../medias/blog_picture/51/13.png" alt="三个引脚控制八个输出"></p><h3 id="串行vs并行"><a href="#串行vs并行" class="headerlink" title="串行vs并行"></a>串行vs并行</h3><p><img src="/../../../../medias/blog_picture/51/14.png" alt="串行是这样子一个一个出去的"></p><p>并行是用那八个输出端同时输出</p><h3 id="串行输入-并行输出"><a href="#串行输入-并行输出" class="headerlink" title="串行输入 并行输出"></a>串行输入 并行输出</h3><p>每上升沿移位，从SER进的数据就向下沿移位，SERCLK高电平的时候移进，数据一位一位地往前走，等有了八位数据之后同时搬过去输出缓存那，串行那里每输入一位，SER清零，数据下移</p><p><img src="/../../../../medias/blog_picture/51/15.png" alt="74HC595"></p><p>当寄存器满位后，给RCLK高电平，把数据搬运到输出缓存那</p><h3 id="多片级联"><a href="#多片级联" class="headerlink" title="多片级联"></a>多片级联<img src="/../../../../medias/blog_picture/51/16.png" alt="多片级联"></h3><p>在寄存器的数据传到QH’，然后多片级联到下一个SER，当所有数据就位了，来一个上升沿锁存，所有数据都相应地输出，实现了IO口的扩展，但是速率会有所减慢(时间换时空)</p><h2 id="sfr和sbit可位寻址-不可位寻址"><a href="#sfr和sbit可位寻址-不可位寻址" class="headerlink" title="sfr和sbit可位寻址/不可位寻址"></a>sfr和sbit可位寻址/不可位寻址</h2><p>sfr：特殊功能寄存器声明(声明寄存器地址)相当于把某个元件的操作地址赋给一个自定义的变量名，把相应的名称和地址给声明出来，我们才能操作那个名称</p><p>sbit：特殊位声明(声明地址的某一位)</p><p><img src="/../../../../medias/blog_picture/51/17.png" alt="C51的sfr、sbit"></p><p>可位寻址和不可位寻址就类比于C语言的数组，可位寻址的就是数组的首地址，不是首地址的就不能位寻址</p><h2 id="上代码-笑脸"><a href="#上代码-笑脸" class="headerlink" title="上代码(笑脸)"></a>上代码(笑脸)</h2><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token comment">//给IO口改名</span>sbit RCK<span class="token operator">=</span>P3<span class="token operator">^</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">//RCLK,应该是赋值的时候用_，给地址的时候用^，这里是让rclk直接找到p3_5的地址所以用^</span>sbit SCK<span class="token operator">=</span>P3<span class="token operator">^</span><span class="token number">6</span><span class="token punctuation">;</span><span class="token comment">//SRCLK</span>sbit SER<span class="token operator">=</span>P3<span class="token operator">^</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">//SER</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MATRIX_LED_PORT</span> <span class="token expression">P0</span><span class="token comment">//如果以后自己焊板子玩接口不对，直接改上面sbit，不用再在下面改了</span></span><span class="token comment">/**  * @brief  74HC595写入一个字节  * @param  要写入的字节  * @retval 无  */</span><span class="token keyword">void</span> <span class="token function">_74JHC595_WriteByte</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Byte<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>SER<span class="token operator">=</span>Byte<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token operator">&gt;&gt;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//0x80--&gt;1000 0000</span>SCK<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//给高电平形成上升沿传入数据</span>SCK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//置零为下一次传入做准备</span><span class="token punctuation">}</span>RCK<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//高电平，形成上升沿锁存</span>RCK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//置零</span><span class="token punctuation">}</span><span class="token comment">/*** @brief  LED点阵屏显示一列数据* @param  Column 要选择的列，范围0~7，0在最左边* @param  Data 选择列显示的数据，高位在上，1为亮，0为灭* @retval 无  */</span><span class="token keyword">void</span> <span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Cloumn<span class="token punctuation">,</span>Data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">_74JHC595_WriteByte</span><span class="token punctuation">(</span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//放数据</span>MATRIX_LED_PORT<span class="token operator">=</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token operator">&gt;&gt;</span>Cloumn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//位选；选择列，然后把数据0xAA传到LED列中；</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延时</span>MATRIX_LED_PORT<span class="token operator">=</span><span class="token number">0xFF</span><span class="token punctuation">;</span><span class="token comment">//位清零，下一步是段选，这样下次段选就不会串位到上一个位选了</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>SCK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//因为上电默认高电平,先置0，才能给高电平；需要一个上升沿才能传入数据</span>RCK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始化为低电平</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0x3C</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0x42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0xA9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0x85</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0x85</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0xA9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">0x42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">0x3C</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="抠-理-解-开抠！！！"><a href="#抠-理-解-开抠！！！" class="headerlink" title="抠 理 解      开抠！！！"></a>抠 理 解      开抠！！！</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>SER<span class="token operator">=</span>Byte<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token operator">&gt;&gt;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//0x80--&gt;1000 0000</span>SCK<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//给高电平形成上升沿传入数据</span>SCK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//置零为下一次传入做准备</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SER是一位而Byte是8位，涉及到位对齐问题</p><p>理解：假如Byte是0x55(0101 0101)</p><p>i=0(0x80&gt;&gt;i)=1000 0000</p><p>SER=<strong>0</strong>101 0101 &amp; <strong>1</strong>000 0000 =<strong>0</strong>000 0000——-根据非<strong>0</strong>即1，SER为<strong>0</strong></p><p>i=1(0x80&gt;&gt;i)=0100 0000</p><p>SER=0<strong>1</strong>01 0101 &amp; 0<strong>1</strong>00 0000 =0<strong>1</strong>00 0000——-根据非0即<strong>1</strong>，SER为<strong>1</strong></p><p>.</p><p>.</p><p>.</p><p>i=7(0x80&gt;&gt;i)=0000 0001</p><p>SER=0101 010<strong>1</strong> &amp; 0000 0001 =0000 0001——-根据非0即<strong>1</strong>，SER为<strong>1</strong></p><p><img src="/../../../../medias/blog_picture/51/18.png" alt="最后变成这样"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">SCK<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//给高电平形成上升沿传入数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/../../../../medias/blog_picture/51/19.png" alt="."></p><p>段选 位选 <strong>延时</strong> <strong>位清零</strong> 段选 位选</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*** @brief  LED点阵屏显示一列数据* @param  Column 要选择的列，范围0~7，0在最左边* @param  Data 选择列显示的数据，高位在上，1为亮，0为灭* @retval 无*/</span><span class="token keyword">void</span> <span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Cloumn<span class="token punctuation">,</span>Data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">_74JHC595_WriteByte</span><span class="token punctuation">(</span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//放数据</span>MATRIX_LED_PORT<span class="token operator">=</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token operator">&gt;&gt;</span>Cloumn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//位选；选择列，然后把数据0xAA传到LED列中；</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延时</span>MATRIX_LED_PORT<span class="token operator">=</span><span class="token number">0xFF</span><span class="token punctuation">;</span><span class="token comment">//位清零，下一步是段选，这样下次段选就不会串位到上一个位选了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">MATRIX_LED_PORT<span class="token operator">=</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token operator">&gt;&gt;</span>Cloumn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里取反是为了让1表示亮，0表示灭，同时&gt;&gt;补位补的是0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="上代码-Hello-滚屏"><a href="#上代码-Hello-滚屏" class="headerlink" title="上代码(Hello!滚屏)"></a>上代码(Hello!滚屏)</h2><h3 id="main-c-1"><a href="#main-c-1" class="headerlink" title="main.c"></a>main.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"MatrixLED.h"</span></span><span class="token comment">//code 把Animation的数据放在flash里(内存大)，把run的空间腾出来做其他事情，缺点是Animation的数据不能再更改了(只能读取不能写入)</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> code Animation<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0xFF</span><span class="token punctuation">,</span><span class="token number">0x08</span><span class="token punctuation">,</span><span class="token number">0x08</span><span class="token punctuation">,</span><span class="token number">0x08</span><span class="token punctuation">,</span><span class="token number">0xFF</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x0E</span><span class="token punctuation">,</span><span class="token number">0x15</span><span class="token punctuation">,</span><span class="token number">0x15</span><span class="token punctuation">,</span><span class="token number">0x15</span><span class="token punctuation">,</span><span class="token number">0x08</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x7E</span><span class="token punctuation">,</span><span class="token number">0x01</span><span class="token punctuation">,</span><span class="token number">0x02</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x7E</span><span class="token punctuation">,</span><span class="token number">0x01</span><span class="token punctuation">,</span><span class="token number">0x02</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x0E</span><span class="token punctuation">,</span><span class="token number">0x11</span><span class="token punctuation">,</span><span class="token number">0x11</span><span class="token punctuation">,</span><span class="token number">0x0E</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x7D</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span>Offset<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//offset偏移量</span><span class="token function">MartrixLED_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>Animation<span class="token punctuation">[</span>i<span class="token operator">+</span>Offset<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//不能用Delay,不然会出现闪屏现象</span><span class="token keyword">if</span><span class="token punctuation">(</span>Count<span class="token operator">&gt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>Offset<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Offset<span class="token operator">&gt;</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token comment">//写这个为了不让Offset溢出产生乱码</span><span class="token punctuation">{</span>Offset<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//相当于扫了10遍后移向下一帧</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>①先解释主函数的for</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>Animation<span class="token punctuation">[</span>i<span class="token operator">+</span>Offset<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个<strong>MatrixLED_ShowColumn</strong>是放数据，安排每一列的，i表示列，Animation[]是数组，<strong>i+Offset</strong>是要把<strong>一幕中的八列</strong>都打出来</p><p><strong>②if</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//不能用Delay,不然会出现闪屏现象</span><span class="token keyword">if</span><span class="token punctuation">(</span>Count<span class="token operator">&gt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>Offset<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Offset<span class="token operator">&gt;</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token comment">//写这个为了不让Offset溢出产生乱码</span><span class="token punctuation">{</span>Offset<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用Count来计时，当Count&gt;10后，<strong>Offset++，屏幕中的画面开始往右移，每次移动一列，</strong>Offset&gt;40，这个40=<strong>8*6(全部)—8(第一幕的不需要移动)</strong></p><p><strong>③有16个0x00</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> code Animation<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让**H的左边的|<strong>从最后一列出现，让</strong>!**从第一列离开</p><h3 id="MatrixLED-c-是上一个主函数里扒拉下来的"><a href="#MatrixLED-c-是上一个主函数里扒拉下来的" class="headerlink" title="MatrixLED.c(是上一个主函数里扒拉下来的)"></a>MatrixLED.c(是上一个主函数里扒拉下来的)</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token comment">//给IO口改名</span>sbit RCK<span class="token operator">=</span>P3<span class="token operator">^</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">//RCLK,应该是赋值的时候用_，给地址的时候用^，这里是让rclk直接找到p3_5的地址所以用^</span>sbit SCK<span class="token operator">=</span>P3<span class="token operator">^</span><span class="token number">6</span><span class="token punctuation">;</span><span class="token comment">//SRCLK</span>sbit SER<span class="token operator">=</span>P3<span class="token operator">^</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token comment">//SER</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MATRIX_LED_PORT</span> <span class="token expression">P0</span><span class="token comment">//如果以后自己焊板子玩接口不对，直接改上面sbit，不用再在下面改了</span></span><span class="token comment">/**  * @brief  74HC595写入一个字节  * @param  要写入的字节  * @retval 无  */</span><span class="token keyword">void</span> <span class="token function">_74JHC595_WriteByte</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Byte<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">8</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>SER<span class="token operator">=</span>Byte<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token operator">&gt;&gt;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//0x80--&gt;1000 0000</span>SCK<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//给高电平形成上升沿传入数据</span>SCK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//置零为下一次传入做准备</span><span class="token punctuation">}</span>RCK<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//高电平，形成上升沿锁存</span>RCK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//置零</span><span class="token punctuation">}</span><span class="token comment">/**  * @brief  点阵屏初始化  * @param  无  * @retval 无  */</span><span class="token keyword">void</span> <span class="token function">MartrixLED_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>SCK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//因为上电默认高电平,先置0，才能给高电平；需要一个上升沿才能传入数据</span>RCK<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始化为低电平</span><span class="token punctuation">}</span><span class="token comment">/*** @brief  LED点阵屏显示一列数据* @param  Column 要选择的列，范围0~7，0在最左边* @param  Data 选择列显示的数据，高位在上，1为亮，0为灭* @retval 无  */</span><span class="token keyword">void</span> <span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Cloumn<span class="token punctuation">,</span>Data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">_74JHC595_WriteByte</span><span class="token punctuation">(</span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//放数据</span>MATRIX_LED_PORT<span class="token operator">=</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token operator">&gt;&gt;</span>Cloumn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//位选；选择列，然后把数据0xAA传到列中；</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//延时</span>MATRIX_LED_PORT<span class="token operator">=</span><span class="token number">0xFF</span><span class="token punctuation">;</span><span class="token comment">//位清零，下一步是段选，这样下次段选就不会串位到上一个位选了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MatrixLED-h"><a href="#MatrixLED-h" class="headerlink" title="MatrixLED.h"></a>MatrixLED.h</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__MATRIXLED_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__MATRIXLED_H__</span></span><span class="token keyword">void</span> <span class="token function">MatrixLED_ShowColumn</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Cloumn<span class="token punctuation">,</span>Data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">MartrixLED_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
            <tag> 大云屋考核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串口通信</title>
      <link href="/2022/10/11/chuan-kou-tong-xin/"/>
      <url>/2022/10/11/chuan-kou-tong-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><p><img src="/../../../../medias/blog_picture/51/32.png" alt="硬件电路"></p><h3 id="电平标准"><a href="#电平标准" class="headerlink" title="电平标准"></a>电平标准</h3><p>TTL：+5V表示1，0V表示0</p><p><img src="E:\Users\Wabby\AppData\Roaming\Typora\typora-user-images\1665028662515.png" alt="1665028662515"></p><p>异步：A发了1s的1和1s的0，那B就可以连续两次0.5s发1和两次0.5s的0</p><p><img src="/../../../../medias/blog_picture/51/33.png"></p><p><img src="/../../../../medias/blog_picture/51/34.png" alt="串口参数及时序图"></p><h3 id="检验位-9位"><a href="#检验位-9位" class="headerlink" title="检验位(9位)"></a>检验位(9位)</h3><p>奇校验</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//收：0000 0011 1</span><span class="token comment">//发：0000 0011 1</span><span class="token comment">//但是如果是0000 1010 1就也会补1，排错率不高</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//收：1110 0000 0</span><span class="token comment">//发：1100 0000 0</span><span class="token comment">//这时就是错误的，说明数据出了问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../../../../medias/blog_picture/51/35.png" alt="串口模式图"></p><p>中间圈起来那块是控制波特率的</p><p>发送寄存器： X=SBUF</p><p>接收寄存器：SBUF=X</p><h2 id="通信初实现"><a href="#通信初实现" class="headerlink" title="通信初实现"></a>通信初实现</h2><p><strong>16位定时器/计时器</strong>和<strong>8位自动重装载</strong>的区别</p><p>就是十六位记的数多，但每次都需要自己写的代码赋初值，浪费时间。双八位就是将十六位分开，一个计数，另一个存放初值，每次计数完成后AR会自动将值赋给CNT，不用代码处理，比较快，但只有八位所以记的数少了。</p><h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token keyword">void</span> <span class="token function">UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//4800bps@11.0592MHz</span><span class="token punctuation">{</span><span class="token comment">//串口部分</span>SCON <span class="token operator">=</span> <span class="token number">0x40</span><span class="token punctuation">;</span><span class="token comment">//8位数据,可变波特率</span>PCON <span class="token operator">&amp;=</span> <span class="token number">0x7F</span><span class="token punctuation">;</span><span class="token comment">//定时器1部分，T1是串口专用的定时器</span>TMOD <span class="token operator">&amp;=</span> <span class="token number">0x0F</span><span class="token punctuation">;</span><span class="token comment">//设置定时器模式</span>TMOD <span class="token operator">|=</span> <span class="token number">0x20</span><span class="token punctuation">;</span><span class="token comment">//设置定时器模式</span>TL1 <span class="token operator">=</span> <span class="token number">0xFA</span><span class="token punctuation">;</span><span class="token comment">//设定定时初值</span>TH1 <span class="token operator">=</span> <span class="token number">0xFA</span><span class="token punctuation">;</span><span class="token comment">//设定定时器重装值</span>ET1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//禁止定时器1中断</span>TR1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//启动定时器1</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">UART_SendByte</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Byte<span class="token punctuation">)</span><span class="token punctuation">{</span>SBUF<span class="token operator">=</span>Byte<span class="token punctuation">;</span><span class="token comment">//SBUF写入,被赋值</span><span class="token keyword">while</span><span class="token punctuation">(</span>TI<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//本来TI=0，但是在数据传输完成之后串口会自动将1赋给TI,因此需要软件进行复位。</span>TI<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//软件复位</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">UART_SendByte</span><span class="token punctuation">(</span><span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="①串口部分SCON-serial-control-PCON-power-control"><a href="#①串口部分SCON-serial-control-PCON-power-control" class="headerlink" title="①串口部分SCON(serial control)&amp;PCON(power control)"></a>①串口部分SCON(serial control)&amp;PCON(power control)</h4><p><img src="/../../../../medias/blog_picture/51/36.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">SCON <span class="token operator">=</span> <span class="token number">0x40</span><span class="token punctuation">;</span><span class="token comment">//8位数据,可变波特率</span>PCON <span class="token operator">&amp;=</span> <span class="token number">0x7F</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="SM0-SM1"><a href="#SM0-SM1" class="headerlink" title="SM0&amp;SM1"></a>SM0&amp;SM1</h5><p><img src="/../../../../medias/blog_picture/51/37.png"></p><p><img src="/../../../../medias/blog_picture/51/38.png"></p><p><strong>REN给0/1都可以</strong></p><p><img src="/../../../../medias/blog_picture/51/39.png"></p><p><img src="/../../../../medias/blog_picture/51/40.png"></p><p><strong>SM2，TB8，RB8跟模式1无关，给0</strong></p><p><img src="/../../../../medias/blog_picture/51/41.png"></p><p>就是发送结束后，硬件给T1置1，表示发送完了，然后请求中断的时候TI=0，必须用软件复位是指要人为在软件中使TI=1</p><p><strong>TI=0</strong> —发送–完毕—-硬件–&gt; <strong>T1=1</strong> –请求中断–&gt; <strong>TI=1</strong> –主机响应中断—-软件复位&gt; <strong>TI=0</strong></p><p>TI最开始为0</p><p><img src="/../../../../medias/blog_picture/51/42.png"></p><p>对RI的理解和TI一样</p><p><strong>所以SCON=0100 0000 –&gt; 0x40</strong></p><h4 id="②PCON，用波特率计算搞出来的"><a href="#②PCON，用波特率计算搞出来的" class="headerlink" title="②PCON，用波特率计算搞出来的"></a>②PCON，用波特率计算搞出来的</h4><h3 id="定时器部分"><a href="#定时器部分" class="headerlink" title="定时器部分"></a>定时器部分</h3><p>要改为定时器1</p><p><img src="/../../../../medias/blog_picture/51/43.png"></p><p><img src="/../../../../medias/blog_picture/51/44.png"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">TMOD <span class="token operator">&amp;=</span> <span class="token number">0x0F</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span> <span class="token number">0000</span> <span class="token number">1111</span>TMOD <span class="token operator">|=</span> <span class="token number">0x20</span><span class="token punctuation">;</span>    <span class="token operator">|</span> <span class="token number">0010</span> <span class="token number">0000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="小小问题"><a href="#小小问题" class="headerlink" title="小小问题"></a>小小问题</h3><p>当我把下面这串</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">UART_SendByte</span><span class="token punctuation">(</span><span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改成</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">UART_SendByte</span><span class="token punctuation">(</span><span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当为0x11时正常且不断输出11，当为0x66时异常且不断输出96，是因为波特率的误差，此时我们让它翻慢点就可以正常输出了(让他稳定点)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">UART_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">UART_SendByte</span><span class="token punctuation">(</span><span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//让他慢慢翻</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../../../../medias/blog_picture/51/45.png" alt="串口和中断系统"></p><p>我们要启用串口中断，而不是定时器中断，定时器中断是到点了就中断，串口中断是有数据过来中断，所以要配置定时器不中断即ET1等于0，然后开启串口中断</p><h2 id="中断服务函数"><a href="#中断服务函数" class="headerlink" title="中断服务函数"></a>中断服务函数</h2><p>模板</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">UART_Rountine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> interrupt <span class="token number">4</span><span class="token comment">//中断服务子函数</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>RI<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>RI<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例子</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">UART_Rountine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> interrupt <span class="token number">4</span><span class="token comment">//中断服务子函数</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>RI<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//区分发送和接收，发送和接收都会触发中断</span> <span class="token comment">//而且二者占用同一个通道，写这个是为了判断，然后把发送和接受分开</span><span class="token punctuation">{</span>P2<span class="token operator">=</span><span class="token operator">~</span>SBUF<span class="token punctuation">;</span><span class="token function">UART_SendByte</span><span class="token punctuation">(</span>SBUF<span class="token punctuation">)</span><span class="token punctuation">;</span>RI<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算波特率"><a href="#算波特率" class="headerlink" title="算波特率"></a>算波特率</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">TL1 <span class="token operator">=</span> <span class="token number">0xFA</span><span class="token punctuation">;</span><span class="token comment">//设定定时初值</span>TH1 <span class="token operator">=</span> <span class="token number">0xFA</span><span class="token punctuation">;</span><span class="token comment">//设定定时器重装值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>FA–16转10–&gt; 250</p><p>那么一个TL1/TH1对应8byte，也就是256，定时器每隔256-250=6µs溢出一次(每计6个数就溢出一次)，11.0529MHz晶振对应12T模式下的0.924µs计数一次</p><p>溢出的频率=0.924/6=0.154MHz</p><p>0.154MHz/16=0.009625MHz</p><p>0.009625×1000×1000=9625？<strong>应该是接近4800的才对</strong>………up主用的12MHz来算，算到了4807</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
            <tag> 大云屋考核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时器和定时器时钟</title>
      <link href="/2022/10/10/ding-shi-qi-he-ding-shi-qi-shi-zhong/"/>
      <url>/2022/10/10/ding-shi-qi-he-ding-shi-qi-shi-zhong/</url>
      
        <content type="html"><![CDATA[<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p><img src="/../../../../medias/blog_picture/51/46.png" alt="定时器框图"></p><p><img src="/../../../../medias/blog_picture/51/47.png"></p><p>按视频中的去理解，up主的板子晶振为12MHz，如果分频接了÷12的线路，那么传给计数器的就会是1µs计数一次(计算:<strong>1/(12MHz/12)=1/1*10^9s=1µs</strong>)</p><p>CT选择开关：那里给<strong>1</strong>是<strong>counter计数器</strong>  给<strong>0</strong>是<strong>timer定时器</strong></p><p>GATE那里：三角是异门(1–&gt;0  0—&gt;1)，第二个是或门(只有00情况给0，其余给1)，第三个是与门<strong>跟C的异或与的与意思差不多</strong></p><p><img src="/../../../../medias/blog_picture/51/48.png"></p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="1-TMOD-TIME-MODE"><a href="#1-TMOD-TIME-MODE" class="headerlink" title="1.TMOD(TIME_MODE)"></a>1.TMOD(TIME_MODE)</h3><p><img src="/../../../../medias/blog_picture/51/49.png"></p><p>由于TMOD不可寻址，所以要<strong>整体</strong>表示</p><p>(对于**(不)可寻址<strong>的理解，</strong>可寻址<strong>像之前的点LED灯，直接P2=0x01&lt;==&gt;P2_1=1然后P2_2~8=0，</strong>不可寻址**就是只能一坨地表示，就像P2=0x00这样)</p><p><strong>目的</strong>：我们要实现<strong>定时器0</strong>运行且进入<strong>模式1</strong></p><h4 id="①M0-M1"><a href="#①M0-M1" class="headerlink" title="①M0&amp;M1"></a>①M0&amp;M1</h4><p><img src="/../../../../medias/blog_picture/51/50.png"></p><p>所以<strong>M0–&gt;1</strong>，<strong>M1–&gt;0</strong></p><h4 id="②C-T"><a href="#②C-T" class="headerlink" title="②C/T"></a>②C/T</h4><p><img src="/../../../../medias/blog_picture/51/51.png"></p><p>因为是定时器 <strong>C/T–&gt;0</strong></p><h4 id="③GATE"><a href="#③GATE" class="headerlink" title="③GATE"></a>③GATE</h4><p><img src="/../../../../medias/blog_picture/51/52.png"></p><p>要让TR0参与控制，所以<strong>GATE–&gt;0</strong></p><p><strong>附GATE的运行模式</strong></p><p><img src="/../../../../medias/blog_picture/51/53.png"></p><h4 id="因此"><a href="#因此" class="headerlink" title="因此"></a>因此</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">TMOD=0X01;//0000 0001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="TMOD的优化"><a href="#TMOD的优化" class="headerlink" title="TMOD的优化"></a>TMOD的优化</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">TMOD <span class="token operator">&amp;=</span> <span class="token number">0xF0</span><span class="token punctuation">;</span><span class="token comment">//设置定时器模式       0xF0--&gt;1111 0000</span>TMOD <span class="token operator">|=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>      <span class="token comment">//                    0x01--&gt;0000 0001</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于TMOD是<strong>同时控制定时器0和定时器1</strong>，我们希望在控制定时器0的时候，<strong>不影响到可能正在工作的定时器1</strong>，于是用到了以下操作</p><p>e.g.</p><p>原TMOD=1010 0011—我们希望把它转换为—&gt;1010 0001</p><p><strong>1st——-1010 0011 &amp; 1111 0000 =1010 0000</strong></p><p><strong>理解</strong>：<strong>n &amp; 1 <strong>时，n为几就返回几(此时不影响定时器1)；</strong>n &amp; 0 <strong>时，全为0(有点</strong>初始化</strong>定时器0的感觉)</p><p><strong>2nd——1010 0000 | 0000 0001 =1010 0001</strong></p><p><strong>理解</strong>：<strong>n | 0 <strong>时，n为几就返回几(还是不影响定时器1)；</strong>0 | n</strong> 时，n为几也返回几(n是人工决定的，这时可以自行操控定时器0了)</p><h3 id="2-TCON"><a href="#2-TCON" class="headerlink" title="2.TCON"></a>2.TCON</h3><p><img src="/../../../../medias/blog_picture/51/54.png"></p><h4 id="①TR0"><a href="#①TR0" class="headerlink" title="①TR0"></a>①TR0</h4><p><img src="/../../../../medias/blog_picture/51/55.png"></p><p><strong>省流</strong>：GATE=0 &amp;&amp; TR0=1时允许T0计数，开始工作</p><pre class="line-numbers language-none"><code class="language-none">TR0=1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="②TF0"><a href="#②TF0" class="headerlink" title="②TF0"></a>②TF0</h4><p><img src="/../../../../medias/blog_picture/51/56.png"></p><p><strong>省流</strong>：TF0=1时就产生中断，所以要=0，防止刚配置好就产生中断</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">TF0<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="③TH0-TL0"><a href="#③TH0-TL0" class="headerlink" title="③TH0&amp;TL0"></a>③TH0&amp;TL0</h4><p><img src="/../../../../medias/blog_picture/51/57.png"></p><p>来自弹幕大佬：两个寄存器TH0、TL0为<strong>二进制八位</strong>(2^8)，<strong>单独</strong>可计256次，<strong>低八位计满256次后高八位进1</strong>，所以<strong>除以256</strong>可得<strong>高八位</strong>得次数，<strong>取余</strong>就是<strong>低八位</strong>的次数，合并在一起就是所赋的初始值</p><p>来自UP主：<strong>123</strong>要放到两个<strong>容量</strong>为100的盒子里，<strong>高位次</strong>的盒子存储—<strong>123/100=1</strong>，<strong>低位次</strong>的盒子存储—<strong>123%100=23</strong>，<strong>合并</strong>之后就是123(初始值)</p><p><strong>对应项目，就是两个容量为256的小盒子要存储64535这个庞然大物</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">TH0<span class="token operator">=</span><span class="token number">64535</span><span class="token operator">/</span><span class="token number">256</span><span class="token punctuation">;</span><span class="token comment">//high，拿出高八位</span>TL0<span class="token operator">=</span><span class="token number">64535</span><span class="token operator">%</span><span class="token number">256</span><span class="token punctuation">;</span><span class="token comment">//low，拿出低八位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="④ET0-EA-PT0"><a href="#④ET0-EA-PT0" class="headerlink" title="④ET0&amp;EA&amp;PT0"></a>④ET0&amp;EA&amp;PT0</h4><p><img src="/../../../../medias/blog_picture/51/58.png"></p><p>把通道打通</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">ET0=1;EA=1;PT0=0;//虽然默认PT0为0，但还是说明一下比较好<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-Time0-c"><a href="#3-Time0-c" class="headerlink" title="3.Time0.c"></a>3.Time0.c</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token comment">/**  * @brief  定时器0初始化，1ms@11.0592MH  * @param  无  * @retval 无  */</span><span class="token keyword">void</span> <span class="token function">Timer0Init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//1毫秒@11.0592MHz</span><span class="token punctuation">{</span>TMOD <span class="token operator">&amp;=</span> <span class="token number">0xF0</span><span class="token punctuation">;</span><span class="token comment">//设置定时器模式       0xF0--&gt;1111 0000</span>TMOD <span class="token operator">|=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>     <span class="token comment">//                     0x0x--&gt;0000 0001</span>TL0 <span class="token operator">=</span> <span class="token number">0x66</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span>TH0 <span class="token operator">=</span> <span class="token number">0xFC</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span>    <span class="token comment">/**    64535/256=252    252--10进制转16进制--&gt;FC        64535%256=23    23--10进制转16进制--&gt;17    但是我们这个有0.04%的偏差，所以...问题...应该不大吧...    */</span>TF0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//清除TF0标志</span>TR0 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//定时器0开始计时</span>ET0<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">//允许中断</span>EA<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>PT0<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*定时器中断函数模板void Timer0_Routine() interrupt 1{static unsigned int T0Count;//为了不丢失这个数字TL0 = 0x66;//设置定时初值TH0 = 0xFC;//设置定时初值T0Count++;if(T0Count&gt;=1000){//这里要写具体实现什么T0Count=0;}}*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对定时器中断函数模板的理解：</p><p>首先，中断程序本身可视为一个while循环，会一直执行这个函数</p><p>其次，对于秒数，这个计时器(TH0 TL0)<strong>最高可达到65535µs</strong>，我们设置定时初值时，用的是64535，它<strong>距离65535还有1000才即将溢出归零</strong>，所以我们让计时器计时1000µs(=1ms)，**每过1ms，T0Count++**，当它加了1000次，此时已经过去1000ms(=1s)</p><p>最后，进入if执行具体实现，然后把T0Count归零，进入下一次中断程序(循环)</p><h3 id="4-新学两个函数"><a href="#4-新学两个函数" class="headerlink" title="4.新学两个函数"></a>4.新学两个函数</h3><p><strong>要用到#include&lt;INTRINS.H&gt;头文件</strong></p><h4 id="crol函数-cror函数-头尾都要"><a href="#crol函数-cror函数-头尾都要" class="headerlink" title="crol函数&amp;cror函数(..头尾都要_.."></a>crol函数&amp;cror函数(..头尾都要_..</h4><p>循环移位</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> a<span class="token operator">=</span><span class="token number">0x80</span><span class="token punctuation">;</span>a<span class="token operator">=</span><span class="token function">_crol_</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//a为0x01，循环回去开头了</span><span class="token comment">//如果是&lt;&lt;的话，移到边界就溢出越界</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-最终呈现"><a href="#5-最终呈现" class="headerlink" title="5.最终呈现"></a>5.最终呈现</h3><h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Timer0.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Key.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;INTRINS.H&gt;</span></span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> KeyNum<span class="token punctuation">,</span>LEDMode<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>P2<span class="token operator">=</span><span class="token number">0xFE</span><span class="token punctuation">;</span><span class="token comment">//P2是LED模块噢，一端接了VCC，那么只有给P2_n赋值为0的时候才亮，0xFE转二进制为1111 1110</span><span class="token function">Timer0Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>KeyNum<span class="token operator">=</span><span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>LEDMode<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>LEDMode<span class="token operator">&gt;=</span><span class="token number">2</span><span class="token punctuation">)</span>LEDMode<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//定时器和主程序的耦合性比较大，所以直接放到主函数使用</span><span class="token keyword">void</span> <span class="token function">Timer0_Routine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> interrupt <span class="token number">1</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> T0Count<span class="token punctuation">;</span><span class="token comment">//为了不丢失这个数字</span>TL0 <span class="token operator">=</span> <span class="token number">0x66</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span>TH0 <span class="token operator">=</span> <span class="token number">0xFC</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span>T0Count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>T0Count<span class="token operator">&gt;=</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token comment">//0.5s亮一次</span><span class="token punctuation">{</span>T0Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>LEDMode<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>P2<span class="token operator">=</span><span class="token function">_crol_</span><span class="token punctuation">(</span>P2<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>LEDMode<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>P2<span class="token operator">=</span><span class="token function">_cror_</span><span class="token punctuation">(</span>P2<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对<strong>流水</strong>效果，我们添加了这些</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>T0Count<span class="token operator">&gt;=</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">{</span>T0Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>LEDMode<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>           P2<span class="token operator">=</span><span class="token function">_crol_</span><span class="token punctuation">(</span>P2<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//往左流</span><span class="token keyword">if</span><span class="token punctuation">(</span>LEDMode<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>P2<span class="token operator">=</span><span class="token function">_cror_</span><span class="token punctuation">(</span>P2<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//往右流</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配合主函数食用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> KeyNum<span class="token punctuation">,</span>LEDMode<span class="token punctuation">;</span> <span class="token comment">//一开始初始化了KeyNum和LEDMode，这两个玩意初始值都为0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么，当开关被按下的时候，<strong>LEDMode==0</strong>，开始往左流，对应下面这句</p><pre class="line-numbers language-none"><code class="language-none">if(LEDMode==0)           P2=_crol_(P2,1);//往左流<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后接收KeyNum，当我不按P3_1时，LEDMode就一直为0，一直往左流</p><p>我按下P3_1时，配合Key.c食用，此时<strong>返回KeyNumber=1</strong></p><h4 id="Key-c"><a href="#Key-c" class="headerlink" title="Key.c"></a>Key.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token comment">/**  * @brief  获取独立按键键码  * @param  无  * @retval 按下按键的键码，范围：0~4，无按键按下时返回值为0  */</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token function">Key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> KeyNumber<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_1<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_1<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//介里介里！</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_0<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_0<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_2<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_2<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_3<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_3<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> KeyNumber<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>KeyNum==1</strong>后，执行</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>LEDMode<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>LEDMode<span class="token operator">&gt;=</span><span class="token number">2</span><span class="token punctuation">)</span>LEDMode<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候LEDMode++，<strong>LEDMode==1</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>LEDMode<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>P2<span class="token operator">=</span><span class="token function">_cror_</span><span class="token punctuation">(</span>P2<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//往右流</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次按下P3_1时，LEDMode++，<strong>LEDMode==2</strong>，然后执行if让LEDMode归零</p><h1 id="定时器时钟"><a href="#定时器时钟" class="headerlink" title="定时器时钟"></a>定时器时钟</h1><h3 id="main-c-1"><a href="#main-c-1" class="headerlink" title="main.c"></a>main.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"LCD1602.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Timer0.h"</span></span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Sec<span class="token punctuation">,</span>Min<span class="token punctuation">,</span>Hour<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">LCD_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Timer0Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">LCD_ShowString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"Clock:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">LCD_ShowString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"  :  :"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>Hour<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>Min<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span>Sec<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Timer0_Routine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> interrupt <span class="token number">1</span><span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> T0Count<span class="token punctuation">;</span><span class="token comment">//为了不丢失这个数字</span>TL0 <span class="token operator">=</span> <span class="token number">0x66</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span>TH0 <span class="token operator">=</span> <span class="token number">0xFC</span><span class="token punctuation">;</span><span class="token comment">//设置定时初值</span>T0Count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>T0Count<span class="token operator">&gt;=</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">{</span>T0Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>Sec<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Sec<span class="token operator">&gt;=</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Sec<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>Min<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Min<span class="token operator">&gt;=</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Min <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>Hour<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>Hour<span class="token operator">&gt;=</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Hour<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个，不难理解，dddd</p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
            <tag> 大云屋考核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵键盘</title>
      <link href="/2022/10/10/ju-zhen-jian-pan/"/>
      <url>/2022/10/10/ju-zhen-jian-pan/</url>
      
        <content type="html"><![CDATA[<h1 id="6-1矩阵键盘"><a href="#6-1矩阵键盘" class="headerlink" title="6-1矩阵键盘"></a>6-1矩阵键盘</h1><p><img src="/../../../../medias/blog_picture/51/20.png" alt="矩阵按键"></p><p><img src="/../../../../medias/blog_picture/51/21.png" alt="芯片引脚"></p><p>前四根线(P17~P14)判断行，给0相当于接地**(由上面这幅图我们知道P1的一端已经接在了VCC，所以要让P1_x运行，要给它低电平，即0)**，此时io口为低电平</p><p>后四根(P13~P10)判断该行对应的某一个按键</p><h2 id="下面的代码主要是实现控制矩阵键盘，并把按下去的键位对应的数字在LCD1602上显示出来"><a href="#下面的代码主要是实现控制矩阵键盘，并把按下去的键位对应的数字在LCD1602上显示出来" class="headerlink" title="下面的代码主要是实现控制矩阵键盘，并把按下去的键位对应的数字在LCD1602上显示出来"></a>下面的代码主要是实现控制矩阵键盘，并把按下去的键位对应的数字在LCD1602上显示出来</h2><p>ps:常见的Delay就不放出来了，懂得都懂</p><p>matrix矩阵</p><h3 id="MatrixKey-h"><a href="#MatrixKey-h" class="headerlink" title="MatrixKey.h"></a>MatrixKey.h</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__MATRIXKEY_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__MATRIXKEY_H__</span></span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token function">MatrixKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MatrixKey-c"><a href="#MatrixKey-c" class="headerlink" title="MatrixKey.c"></a>MatrixKey.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token function">MatrixKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> KeyNumber<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>P1<span class="token operator">=</span><span class="token number">0xFF</span><span class="token punctuation">;</span><span class="token comment">//有点相当于初始化</span>P1_3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_7<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_7<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_6<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_6<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_5<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_5<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_4<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_4<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">13</span><span class="token punctuation">;</span><span class="token punctuation">}</span>P1<span class="token operator">=</span><span class="token number">0xFF</span><span class="token punctuation">;</span>P1_2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_7<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_7<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_6<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_6<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_5<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_5<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_4<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_4<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">14</span><span class="token punctuation">;</span><span class="token punctuation">}</span>P1<span class="token operator">=</span><span class="token number">0xFF</span><span class="token punctuation">;</span>P1_1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_7<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_7<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_6<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_6<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_5<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_5<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_4<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_4<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">;</span><span class="token punctuation">}</span>P1<span class="token operator">=</span><span class="token number">0xFF</span><span class="token punctuation">;</span>P1_0<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_7<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_7<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_6<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_6<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_5<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_5<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_4<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_4<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> KeyNumber<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以发现这个函数代码是由<strong>四组模板一样</strong>的小代码组成的，下面将拎一组出来解释</p><p><img src="/../../../../medias/blog_picture/51/22.png" alt="矩阵按键"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">P1<span class="token operator">=</span><span class="token number">0xFF</span><span class="token punctuation">;</span><span class="token comment">//让所有的P1口都为1，就是不对他们进行操作，让他们处于standby状态</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">P1_3<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//"唤醒"列，我们先控制P1_3,让他为0，处于运行状态--①</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//然后逐个判断用户按下了哪个键位+按键消抖，检测松手，赋相应的值给KeyNumber</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_7<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_7<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//--②</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_6<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_6<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//--③</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_5<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_5<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//--④</span><span class="token keyword">if</span><span class="token punctuation">(</span>P1_4<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P1_4<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>KeyNumber<span class="token operator">=</span><span class="token number">13</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//--⑤</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"LCD1602.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"MatrixKey.h"</span></span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> KeyNum<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">LCD_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//初始化</span><span class="token function">LCD_ShowString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"Martix:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//从第一行第一列开始输入</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>KeyNum<span class="token operator">=</span><span class="token function">MatrixKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//把返回的KeyNumber赋值给KeyNum</span><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token punctuation">)</span>  <span class="token punctuation">{</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>KeyNum<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//我们要在这句话中才能让灯亮起来，关键在于让KeyNum为0的时候根本读不到这句话</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**对于if的解释       iiiiiiimportant!!!!!!    **</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>KeyNum<span class="token operator">=</span><span class="token function">MatrixKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//把返回的KeyNumber赋值给KeyNum</span>     <span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>KeyNum<span class="token punctuation">.</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​如果没有<strong>if</strong>，先进入<strong>while(1)<strong>循环中，那么当用户</strong>按下S1</strong>的时候，<strong>Matrix函数</strong>返回<strong>KeyNumber</strong>的值给主函数的<strong>KeyNum</strong>，此时<strong>KeyNum为1</strong>，LCD1602<strong>迅速地显示“1”</strong>(很快啊！肉眼根本看不见的那种)，随即<strong>跳出此次的while(1)循环并进入下一次while(1)循环</strong>，因为下一刻用户不可能速速按下某个键位，所以这时候<strong>Matrix函数</strong>中初始化的那句</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> KeyNumber<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就会直接被返回到主函数的<strong>KeyNum</strong>中，即<strong>KeyNum为0</strong>，所以，我们看到的现象是，无论怎么按都只会显示0，其实有显示过1的，但是太快了，看不见。</p><p>​那么，我们加了**if(KeyNum)**后，当默认为0的时候，if判断为假，就不会出现0，因为为0的时候，根本不会进入到LCD_ShowNum中执行，所以一直显示的是按下去的键位的辣个数字。</p><h2 id="强迫症-专业注释"><a href="#强迫症-专业注释" class="headerlink" title="强迫症+专业注释"></a>强迫症+专业注释</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**  * @brief  简介  * @param  参数1  * @param  参数2  * @param  参数n  * @retval 返回值  */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-2-矩阵键盘密码锁"><a href="#6-2-矩阵键盘密码锁" class="headerlink" title="6-2 矩阵键盘密码锁"></a>6-2 矩阵键盘密码锁</h1><p><strong>以下代码是在6-1的基础上修改的</strong>，所以不再放出Matrix函数，直接上main.c</p><p>ps:注释不会改中文哈哈哈打出来全是”?”，因此以后的<strong>注释</strong>都是<strong>全(塑料/工地)英制</strong></p><h2 id="main-c-1"><a href="#main-c-1" class="headerlink" title="main.c"></a>main.c</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"LCD1602.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"MatrixKey.h"</span></span><span class="token comment">//初始定义未赋初值时默认赋值为0</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> KeyNum<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> Password<span class="token punctuation">,</span>Count<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">LCD_Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">LCD_ShowString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"Password:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>KeyNum<span class="token operator">=</span><span class="token function">MatrixKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment">//if S1~S10keys are pressed ,input password</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>Count<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">//if the time of inout &lt; 4 </span><span class="token punctuation">{</span>Password<span class="token operator">*=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//password RL </span>Password<span class="token operator">+=</span>KeyNum<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//consider the situation of when user press s10 then output 0 ,and get one password</span>Count<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">//metering +1</span><span class="token punctuation">}</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>Password<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//when finishe the enter,updata the display</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token operator">==</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token comment">//if press S11---&gt;confirm</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>Password<span class="token operator">==</span><span class="token number">2345</span><span class="token punctuation">)</span>  <span class="token comment">//if the password == the correct password</span><span class="token punctuation">{</span><span class="token function">LCD_ShowString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token string">"OK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Password<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//the password zero clearing</span>Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//metering zero clearing</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>Password<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//updata the display0</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">LCD_ShowSrting</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token string">"ERR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Password<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//the password zero clearing</span>Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//metering zero clearing</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>Password<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//updata the display</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token comment">//if press S12---&gt; cancel</span><span class="token punctuation">{</span>Password<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//the password zero clearing</span>Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//metering zero clearing</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>Password<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//updata the display</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们一节一节地看，以下从用户按下某个键位开始，即从**if(KeyNum)**开始往下看</p><h3 id="输入Password"><a href="#输入Password" class="headerlink" title="输入Password"></a>输入Password</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">)</span>  <span class="token comment">//if S1~S10keys are pressed ,input password</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>Count<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">//if the time of inout &lt; 4 </span><span class="token punctuation">{</span>Password<span class="token operator">*=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//password RL </span>Password<span class="token operator">+=</span>KeyNum<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//consider the situation of when user press s10 then ouput 0 ,and get one password</span>Count<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">//metering +1</span><span class="token punctuation">}</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>Password<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//updata the display</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的设定是，<strong>按下S1~S10时</strong>，对应1~0，这里用到的很妙的一招是</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Password<span class="token operator">*=</span><span class="token number">10</span><span class="token punctuation">;</span>Password<span class="token operator">+=</span>KeyNum<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Password自×10，则相当于<strong>所有数字往左移动一位</strong>，<strong>待输入的数字由0占据</strong></p><p>再输入的数字<strong>一定是从个位开始</strong>，然后在按下下一个按键时，往左移动，就，<strong>很妙啊！</strong></p><p>然后再设定只能输入4次，噢对了，我们<strong>在一开始设置了全局变量</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> Password<span class="token punctuation">,</span>Count<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以Password和Count<strong>初始值都是0</strong>，因此<strong>Count&lt;4</strong>即<strong>输入四次</strong></p><h3 id="确认键"><a href="#确认键" class="headerlink" title="确认键"></a>确认键</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token operator">==</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token comment">//if press S11---&gt;confirm</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>Password<span class="token operator">==</span><span class="token number">2345</span><span class="token punctuation">)</span>  <span class="token comment">//if the password == the correct password</span><span class="token punctuation">{</span><span class="token function">LCD_ShowString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token string">"OK"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Password<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//the password zero clearing</span>Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//metering zero clearing</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>Password<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//updata the display</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token function">LCD_ShowSrting</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token string">"ERR"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Password<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//the password zero clearing</span>Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//metering zero clearing</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>Password<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//updata the display</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们<strong>约定了2345是正确密码</strong>，当输入了2345时按下S11会<strong>出现”OK”</strong></p><p>然后，就是输入完毕后<strong>一切归零</strong>，即让用户<strong>再次输入(无论输入正确与否)</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Password<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//the password zero clearing</span>Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//metering zero clearing</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>Password<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//updata the display</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>先让Password重置为0</p><p>然后计数Count也为0</p><p>一切都回到最开始的样子，即全局变量初始化的样子</p><h3 id="取消键"><a href="#取消键" class="headerlink" title="取消键"></a>取消键</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>KeyNum<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token comment">//if press S12---&gt; cancel</span><span class="token punctuation">{</span>Password<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//the password zero clearing</span>Count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//metering zero clearing</span><span class="token function">LCD_ShowNum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>Password<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//updata the display</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了上面的解释，这个应该不难理解吧</p><h1 id="关于LCD1602-c"><a href="#关于LCD1602-c" class="headerlink" title="关于LCD1602.c"></a>关于LCD1602.c</h1><p><img src="/../../../../medias/blog_picture/51/23.png" alt="LCD1602内部显示地址"></p><p><img src="/../../../../medias/blog_picture/51/24.png" alt="举例说明"></p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
            <tag> 大云屋考核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块化编程</title>
      <link href="/2022/10/02/mo-kuai-hua-bian-cheng/"/>
      <url>/2022/10/02/mo-kuai-hua-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1模块化编程"><a href="#5-1模块化编程" class="headerlink" title="5-1模块化编程"></a>5-1模块化编程</h1><p><img src="/../../../../medias/blog_picture/51/1.png" alt="模块化编程框图"></p><p><img src="/../../../../medias/blog_picture/51/2.png" alt="模块化编程注意事项"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Delay函数的声明就在第一行那</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../../../../medias/blog_picture/51/3.png" alt="C预编译"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_DELAY_H_</span><span class="token comment">//如果没有定义就执行编译(第一次没有定义才参与编译定义)防止多次编译</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_DELAY_H_</span></span><span class="token keyword">void</span> <span class="token function">Delay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> xms<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h2><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token comment">//调用函数</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Nixie.h"</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Delay-c"><a href="#Delay-c" class="headerlink" title="Delay.c"></a>Delay.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Delay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> xms<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>xms<span class="token punctuation">)</span><span class="token punctuation">{</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>j <span class="token operator">=</span> <span class="token number">199</span><span class="token punctuation">;</span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>xms<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Delay-h"><a href="#Delay-h" class="headerlink" title="Delay.h"></a>Delay.h</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__DELAY_H__</span><span class="token comment">//如果没有定义过这个函数</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__DELAY_H__</span><span class="token comment">//则开始定义</span></span><span class="token keyword">void</span> <span class="token function">Delay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> xms<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//声明</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Nixie-c"><a href="#Nixie-c" class="headerlink" title="Nixie.c"></a>Nixie.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span><span class="token comment">//因为在声明时用到了P0 P2这种没有被说明的量，所以要引入这个头文件说明</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Delay.h"</span></span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> NixieTable<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0x3F</span><span class="token punctuation">,</span><span class="token number">0x06</span><span class="token punctuation">,</span><span class="token number">0x5B</span><span class="token punctuation">,</span><span class="token number">0x4F</span><span class="token punctuation">,</span><span class="token number">0x66</span><span class="token punctuation">,</span><span class="token number">0x6D</span><span class="token punctuation">,</span><span class="token number">0x7D</span><span class="token punctuation">,</span><span class="token number">0x07</span><span class="token punctuation">,</span><span class="token number">0x7F</span><span class="token punctuation">,</span><span class="token number">0x6F</span><span class="token punctuation">,</span><span class="token number">0x5E</span><span class="token punctuation">,</span><span class="token number">0x6E</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Location<span class="token punctuation">,</span>Number<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span><span class="token punctuation">(</span>Location<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//111-8</span><span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//110-7</span><span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">8</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>P0<span class="token operator">=</span>NixieTable<span class="token punctuation">[</span>Number<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P0 <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Nixie-h"><a href="#Nixie-h" class="headerlink" title="Nixie.h"></a>Nixie.h</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__NIXIE_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__NIXIE_H__</span></span><span class="token keyword">void</span> <span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Location<span class="token punctuation">,</span>Number<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
            <tag> 大云屋考核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最初的笔记</title>
      <link href="/2022/10/02/zui-chu-de-bi-ji/"/>
      <url>/2022/10/02/zui-chu-de-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1点亮一个LED"><a href="#2-1点亮一个LED" class="headerlink" title="2-1点亮一个LED"></a>2-1点亮一个LED</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;INTRINS.H&gt;</span></span><span class="token keyword">void</span> <span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//@11.0592MHz</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span><span class="token function">_nop_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>j <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span>k <span class="token operator">=</span> <span class="token number">119</span><span class="token punctuation">;</span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>P2 <span class="token operator">=</span> <span class="token number">0xFE</span><span class="token punctuation">;</span><span class="token comment">//对应1111 1110即只有D1亮</span><span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//亮了后等500ms</span>P2 <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span><span class="token comment">//对应 1111 1111 即都不亮</span><span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不亮后等500ms</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/../../../../medias/blog_picture/51/25.png" alt="LED模块"></p><p>解释：为什么1不亮0亮，是因为LED一端接了VCC高电平，则另一端应该给低电平即0，才有电流输出</p><h1 id="2-3流水灯"><a href="#2-3流水灯" class="headerlink" title="2-3流水灯"></a>2-3流水灯</h1><h2 id="①"><a href="#①" class="headerlink" title="①"></a>①</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;REGX52.H&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;INTRINS.H&gt;</span></span><span class="token keyword">void</span> <span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//@11.0592MHz</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span><span class="token function">_nop_</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>j <span class="token operator">=</span> <span class="token number">129</span><span class="token punctuation">;</span>k <span class="token operator">=</span> <span class="token number">119</span><span class="token punctuation">;</span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>P2 <span class="token operator">=</span> <span class="token number">0xFE</span><span class="token punctuation">;</span><span class="token comment">//1111 1110</span><span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xFD</span><span class="token punctuation">;</span><span class="token comment">//1111 1101</span><span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xFB</span><span class="token punctuation">;</span><span class="token comment">//1111 1011</span><span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xF7</span><span class="token punctuation">;</span><span class="token comment">//1111 0111</span><span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xEF</span><span class="token punctuation">;</span><span class="token comment">//1110 1111</span><span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xDF</span><span class="token punctuation">;</span><span class="token comment">//1101 1111</span><span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xBF</span><span class="token punctuation">;</span><span class="token comment">//1011 1111</span><span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0x7F</span><span class="token punctuation">;</span><span class="token comment">//0111 1111</span><span class="token function">Delay500ms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="②"><a href="#②" class="headerlink" title="②"></a>②</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token keyword">void</span> <span class="token function">Delay1ms</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> xms<span class="token punctuation">)</span><span class="token comment">//@11.0592MHz</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token comment">/**对while循环的理解:这个Delay1ms是针对1ms的，当下面程序需要n个1ms，就会循环n次1ms延时的程序*/</span><span class="token keyword">while</span><span class="token punctuation">(</span>xms<span class="token punctuation">)</span><span class="token punctuation">{</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>j <span class="token operator">=</span> <span class="token number">199</span><span class="token punctuation">;</span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>xms<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//上面自定义函数</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>P2 <span class="token operator">=</span> <span class="token number">0xFE</span><span class="token punctuation">;</span><span class="token comment">//1111 1110</span><span class="token function">Delay1ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xFD</span><span class="token punctuation">;</span><span class="token comment">//1111 1101</span><span class="token function">Delay1ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xFB</span><span class="token punctuation">;</span><span class="token comment">//1111 1011</span><span class="token function">Delay1ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xF7</span><span class="token punctuation">;</span><span class="token comment">//1111 0111</span><span class="token function">Delay1ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xEF</span><span class="token punctuation">;</span><span class="token comment">//1110 1111</span><span class="token function">Delay1ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xDF</span><span class="token punctuation">;</span><span class="token comment">//1101 1111</span><span class="token function">Delay1ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0xBF</span><span class="token punctuation">;</span><span class="token comment">//1011 1111</span><span class="token function">Delay1ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2 <span class="token operator">=</span> <span class="token number">0x7F</span><span class="token punctuation">;</span><span class="token comment">//0111 1111</span><span class="token function">Delay1ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-1独立按键控制LED灯亮灭"><a href="#3-1独立按键控制LED灯亮灭" class="headerlink" title="3-1独立按键控制LED灯亮灭"></a>3-1独立按键控制LED灯亮灭</h1><p><img src="/../../../../medias/blog_picture/51/26.png" alt="独立按键"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//P_3对应第一个独立按键，表示按下该按键时，执行下面语句</span><span class="token punctuation">{</span>P2_0 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>P2_0 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token keyword">void</span> <span class="token function">Delay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> xms<span class="token punctuation">)</span><span class="token comment">//@11.0592MHz</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>xms<span class="token punctuation">)</span><span class="token punctuation">{</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>j <span class="token operator">=</span> <span class="token number">199</span><span class="token punctuation">;</span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>xms<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果还按着，就不执行下面的，进入死循环</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>P2_0 <span class="token operator">=</span> <span class="token operator">~</span>P2_0<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token number">3.3</span>独立按键控制LED显示二进制①<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token keyword">void</span> <span class="token function">Delay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> xms<span class="token punctuation">)</span><span class="token comment">//@11.0592MHz</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>xms<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>j <span class="token operator">=</span> <span class="token number">199</span><span class="token punctuation">;</span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> LEDNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//P2 1111 1111 (初始化)</span>P2<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//P2溢出变为0000 0000</span>P2<span class="token operator">=</span><span class="token operator">~</span>P2<span class="token punctuation">;</span><span class="token comment">//取反1111 1111</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>②<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token keyword">void</span> <span class="token function">Delay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> xms<span class="token punctuation">)</span><span class="token comment">//@11.0592MHz</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>xms<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>j <span class="token operator">=</span> <span class="token number">199</span><span class="token punctuation">;</span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> LEDNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LEDNum<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//初始时LEDNum为0000 0000？</span>P2<span class="token operator">=</span><span class="token operator">~</span>LEDNum<span class="token punctuation">;</span><span class="token comment">//取反</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于<strong>按键消抖，检测松手</strong>的理解：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//如果按了P3_1</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先延时20ms，跳过抖动阶段(消抖)</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//如果还按着P3_1，则进入while的空循环，没有任何执行任务</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//松开手后，跳出while循环，再次进入抖动阶段(消抖)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-4独立按键控制LED位移"><a href="#3-4独立按键控制LED位移" class="headerlink" title="3-4独立按键控制LED位移"></a>3-4独立按键控制LED位移</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> LEDNum<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Delay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> xms<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>xms<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>j <span class="token operator">=</span> <span class="token number">199</span><span class="token punctuation">;</span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>P2 <span class="token operator">=</span> <span class="token operator">~</span><span class="token number">0x01</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//把P2 =~0x01; 挪过来也一样</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_1 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>LEDNum<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//实现每次右移，++几次就右移几下</span><span class="token keyword">if</span><span class="token punctuation">(</span>LEDNum <span class="token operator">&gt;=</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">{</span>LEDNum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>P2 <span class="token operator">=</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">0x01</span><span class="token operator">&lt;&lt;</span>LEDNum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>P3_0 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>P3_0 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>LEDNum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//即此时亮的灯为D1，P2为0000 0001，当num=7后，0x01&lt;&lt;LEDNum&lt;==&gt;0000 0001的1往左移动7位，即1000 0000，亮的是D8，左移成功</span><span class="token punctuation">{</span>LEDNum <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>LEDNum<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment">//实现每次左移，++几次就左移几下</span><span class="token punctuation">}</span>P2 <span class="token operator">=</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">0x01</span><span class="token operator">&lt;&lt;</span>LEDNum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-1静态数码管位移"><a href="#4-1静态数码管位移" class="headerlink" title="4-1静态数码管位移"></a>4-1静态数码管位移</h1><p>共阴极，亮的为1(共阴极–高电平)</p><p>1011 1110为段码(显示6)</p><p>共阳极，亮的为0(共阳极–低电平)</p><p>段码为0100 0001 </p><p>共阴极:</p><p>当只需要亮第三个数字时，第124的共阴极处连接高电平(给1)，而第3的共阴极给0，则只有第三个灯会亮，至于怎么亮，看上面两个例子</p><p>ps:四组A/B/C….都接在同一个1174211053那里(共用引脚，四个数字只能是一样的  )</p><p>74HC245为双向数据缓冲器：VDD和GND为电源，OE为芯片使能端,A0与B0对应….</p><p>DIR–&gt;direction，数据读取方向</p><p>当LE接VCC时，A0传数据给B0</p><p>高电平驱动能力弱，低电平驱动能力强，所以这个缓冲器可以增强信号，使数码管更亮</p><p><strong>//以上是之前没在typora写的笔记，不再做过多的补充和修改</strong></p><h1 id="4-1静态数码管位移-1"><a href="#4-1静态数码管位移-1" class="headerlink" title="4-1静态数码管位移"></a>4-1静态数码管位移</h1><p><strong>目的：实现第三个数码管亮起</strong></p><p><img src="/../../../../medias/blog_picture/51/27.png" alt="数码管"></p><p><strong>第三个灯</strong>对应的是<strong>LED6</strong></p><p><img src="/../../../../medias/blog_picture/51/28.png" alt="138译码器"></p><p><strong>P2_4 P2_3 P2_2—–&gt;Y5—–&gt;LED6</strong></p><p>根据十进制转二进制，Y5的5转为二进制是101，则有</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/../../../../medias/blog_picture/51/29.png" alt="数码管"></p><p>此时要让LED6亮起6，则acdefg为1(共阴极)<strong>因为他们后面接到了GND(低电平)，要给他高电平对应)<strong>，对应到P0口则是(要</strong>从下往上</strong>读，即从<strong>P0_7</strong>读到<strong>P0_0</strong>)<strong>0111 1101</strong>二进制转十六进制，则为0x7D</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//下面的三步操作是让P2接口对应到Y5，“101”是因为5(10进制)转为二进制时对应的值是101</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//P0这看代码前面的解释</span>P0 <span class="token operator">=</span> <span class="token number">0x7D</span><span class="token punctuation">;</span><span class="token comment">//为了让第三个位置的灯亮起</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用数组实现"><a href="#使用数组实现" class="headerlink" title="使用数组实现"></a>使用数组实现</h2><p><code>对于Number</code></p><p><img src="/../../../../medias/blog_picture/51/30.png" alt="显示的字母转为2进制推算"></p><p><strong>静态显示(只能有一个数字)</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> NixieTable<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0x3F</span><span class="token punctuation">,</span><span class="token number">0x06</span><span class="token punctuation">,</span><span class="token number">0x5B</span><span class="token punctuation">,</span><span class="token number">0x4F</span><span class="token punctuation">,</span><span class="token number">0x66</span><span class="token punctuation">,</span><span class="token number">0x6D</span><span class="token punctuation">,</span><span class="token number">0x7D</span><span class="token punctuation">,</span><span class="token number">0x07</span><span class="token punctuation">,</span><span class="token number">0x7F</span><span class="token punctuation">,</span><span class="token number">0x6F</span><span class="token punctuation">,</span><span class="token number">0x5E</span><span class="token punctuation">,</span><span class="token number">0x6E</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//0~9--&gt;0~9 10-d 11-y</span><span class="token comment">//自定义函数</span><span class="token keyword">void</span> <span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Location<span class="token punctuation">,</span>Number<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span><span class="token punctuation">(</span>Location<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//单片机上第一个位置的灯对应的是LED8</span>        <span class="token comment">//这里用138译码器实现，取值顺序CBA</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//111-8-第一盏灯</span><span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//110-7-第二盏灯</span><span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">8</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>P0<span class="token operator">=</span>NixieTable<span class="token punctuation">[</span>Number<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//在该位置上亮起的数字</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//位置(第几个数码管)，数字(如果是字母的话，那就是所要的字母对应数组的位置的位次)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三位对应138译码器的ABC口</p><p><img src="/../../../../medias/blog_picture/51/31.png" alt="138译码器"></p><p><strong>动态显示(多个数字，需要消影)</strong></p><p>消影</p><p>位选 段选 位选 段选**(进行下一次位选时，段选没有改变)**</p><p>改成：位选 段选 <strong>清零</strong> 位选 段选</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;REGX52.H&gt;</span></span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> NixieTable<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0x3F</span><span class="token punctuation">,</span><span class="token number">0x06</span><span class="token punctuation">,</span><span class="token number">0x5B</span><span class="token punctuation">,</span><span class="token number">0x4F</span><span class="token punctuation">,</span><span class="token number">0x66</span><span class="token punctuation">,</span><span class="token number">0x6D</span><span class="token punctuation">,</span><span class="token number">0x7D</span><span class="token punctuation">,</span><span class="token number">0x07</span><span class="token punctuation">,</span><span class="token number">0x7F</span><span class="token punctuation">,</span><span class="token number">0x6F</span><span class="token punctuation">,</span><span class="token number">0x5E</span><span class="token punctuation">,</span><span class="token number">0x6E</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//0~9--&gt;0~9 10-d 11-y</span><span class="token keyword">void</span> <span class="token function">Delay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> xms<span class="token punctuation">)</span><span class="token comment">//@11.0592MHz</span><span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>xms<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>j <span class="token operator">=</span> <span class="token number">199</span><span class="token punctuation">;</span><span class="token keyword">do</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> Location<span class="token punctuation">,</span>Number<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span><span class="token punctuation">(</span>Location<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//1st light--&gt; LED8</span><span class="token comment">//8th light--&gt; LED1</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">6</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">7</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">8</span><span class="token operator">:</span>P2_4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>P2_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> P2_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>P0<span class="token operator">=</span>NixieTable<span class="token punctuation">[</span>Number<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//把这句话删掉的话就没那么亮，应该是让一个位置上的数据管亮完1ms后迅速清零，然后再亮下一个，三个管都亮完只需要3ms，且中间有清零过程，所以视觉上看到的时三管灯同时亮</span>P0 <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span><span class="token comment">//清零过程，不让别的数码管瞎亮</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">Nixie</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
            <tag> 大云屋考核 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
